<?xml-stylesheet type="text/xsl" href="C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Xsl\CodeItRightProfileTemplate.xsl"?>
<CodeItRightProfile Version="1.0">
  <Profile name="[User] Microsoft Guidlines (Modified)" date="12/18/2013 6:30:04 PM">
    <RuleInstance ruleID="AN00006">
      <Name>Error handling -&gt; Always define a global error handler</Name>
      <Title>Always define a global error handler</Title>
      <ClassName>AlwaysDefineGlobalErrorHandler</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00006</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AlwaysDefineGlobalErrorHandler.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[<b>Global.asax</b> file does not contain global error handler.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Global error handler in <b>Global.asax</b> file should always be defined.
  It will allow to recover from an unhandled exception that occured in the current ASP.NET application.<br />
  <br />
  Having a global error handler enables you to implement a common error recovery strategy for the entire 
  application and and saves you from trapping the <b>Error</b> event in each page.<br />
  <br />
  The code inside the <b>Error</b> event handler can access all the usual properties in the <b>Request</b> 
  object, what helps to find the source of the problem, and the methods of the <b>Response</b> object, which
  allow sending an alternative error message.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<LI>Add global error handler.</LI>
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Always define a global error handler.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that implement global error handler.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' Custom error page implemtnation</SPAN>

  Private Sub Application_Error(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Error
	  
    ' Prepare an error report.
    Response.Clear()
    Response.Write("&lt;h1&gt;An exception has occurred:&lt;/h1&gt;")

    ' Display information on the page being processed.
    Response.Write("&lt;b&gt;URL = &lt;/b>&gt; & Request.Path & "&lt;br /&gt;")
    Response.Write("&lt;b&gt;QueryString = &lt;/b&gt;" & Request.QueryString.ToString() & "&lt;p&gt;")
    Response.Write("&lt;b&gt;Error details&lt;/b&gt;&lt;p&gt;")

    ' Display information on the (real) error that occurred.
    Dim ex As Exception = Server.GetLastError.InnerException
    Dim errMsg As String = Server.HtmlEncode(ex.ToString)
    errMsg = errMsg.Replace(ControlChars.CrLf, "&lt;br /&gt;")
    Response.Write(errMsg)
    Response.End()
	  
  End Sub
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// Custom error page implemtnation</SPAN>

  private void Application_Error(object sender, EventArgs e) 
  {
     // Prepare an error report.
     Response.Clear();
     Response.Write("&lt;h1&gt;An exception has occurred:&lt;/h1&gt;");
     
     // Display information on the page being processed.
     Response.Write("&lt;b&gt;URL = &lt;/b&gt;" + Request.Path + "&lt;br /&gt;");
     Response.Write("&lt;b&gt;QueryString = &lt;/b&gt;" + Request.QueryString.ToString() + "&lt;p&gt;");
     Response.Write("&lt;b&gt;Error details&lt;/b&gt;&lt;p&gt;");

     // Display information on the (real) error that occurred.
     Exception ex = Server.GetLastError().InnerException;
     string errMsg = Server.HtmlEncode(ex.ToString());
     errMsg = errMsg.Replace("\n", "&lt;br /&gt;");
     Response.Write(errMsg);
     Response.End();
  }

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00002">
      <Name>Expression -&gt; Avoid the DataBinder.Eval method</Name>
      <Title>Avoid the DataBinder.Eval method</Title>
      <ClassName>AvoidDataBinderEvalMethod</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Expression</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet</RuleCategory>
      <RuleModificationDate>12/28/2009</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidDataBinderEvalMethod.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[<b>System.Web.UI.DataBinder.Eval</b> method is invoked.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Avoid using <b>System.Web.UI.DataBinder.Eval</b> method. It uses reflection and, therefore, is slower than strong-typed access.<br />
  <br />
  Cast the <b>Container.DataItem</b> object to <b>DataRowView</b> object when binding to a <b>DataSet</b>, <b>DataTable</b>, 
  or <b>DataView</b>, or cast to a <b>DbDataRecord</b> object if you are binding to a <b>DataReader</b>.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<LI>Modify your code manually to cast the <b>Container.DataItem</b> object to a specific object.</LI>
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid the DataBinder.Eval method.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

&lt;ItemTemplate&gt;
  &lt;asp:Label runat="server"
    Text='&lt;%# DataBinder.Eval(Container, "DataItem.ProductID") %&gt;'&gt;
  &lt;/asp:Label&gt;
&lt;/ItemTemplate&gt;

<SPAN class="code-selected">' This is the correct implementation</SPAN>

&lt;ItemTemplate&gt;
  &lt;asp:Label runat="server"
    Text='&lt;%# <span class=code-changed>DirectCast(Container.DataItem, System.Data.DataRowView)("ProductID")</span> %&gt;'&gt;
  &lt;/asp:Label&gt;
&lt;/ItemTemplate&gt;
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

&lt;ItemTemplate&gt;
  &lt;asp:Label runat="server"
    Text='&lt;%# DataBinder.Eval(Container, "DataItem.ProductID") %&gt;'&gt;
  &lt;/asp:Label&gt;
&lt;/ItemTemplate&gt;

<SPAN class="code-selected">// This is the correct implementation</SPAN>

&lt;ItemTemplate&gt;
  &lt;asp:Label runat="server"
    Text='&lt;%# <span class=code-changed>(Container.DataItem as System.Data.DataRowView)["ProductID"]</span> %&gt;'&gt;
  &lt;/asp:Label&gt;
&lt;/ItemTemplate&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00003">
      <Name>Expression -&gt; Avoid the Page.DataBind method</Name>
      <Title>Avoid the Page.DataBind method</Title>
      <ClassName>AvoidPageDataBindMethod</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Expression</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet</RuleCategory>
      <RuleModificationDate>10/29/2010</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidPageDataBindMethod.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[<b>Page.DataBind</b> method is invoked.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Avoid <b>Page.DataBind</b> method; instead, invoke the <b>DataBind</b> method for each control that you want to bind to its data source.<br />
  <br />
  The page-level <b>DataBind</b> method must recursively call the <b>DataBind</b> method of all controls on the page.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<LI>Invoke the <b>DataBind</b> method for each control that you want to bind to its data source.</LI>
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid the Page.DataBind method.</li>
  </ul>
  <p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="AN00005">
      <Name>Server Controls -&gt; Avoid setting the AutoPostBack property to True</Name>
      <Title>Avoid setting the AutoPostBack property to True</Title>
      <ClassName>AvoidSettingAutoPostBackPropertyToTrue</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Expression</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00005</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidSettingAutoPostBackPropertyToTrue.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[<b>AutoPostBack</b> property of a server control is set to <b>True</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The <b>AutoPostBack</b> feature relies on client-side JavaScript code; if a Web Forms page 
  contains one or more controls whose <b>AutoPostBack</b> property is set to <b>True</b> and 
  the user has disabled JavaScript support, the user has no means to submit the form unless 
  you also provide one or more button controls.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<LI>Make sure that user can submit form if client-side JavaScript support is disabled.</LI>
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid setting the AutoPostBack property to True.</li>
  </ul>
  <p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="AN00018">
      <Name>Web.Config -&gt; Compilation Debug should be False</Name>
      <Title>Compilation Debug should be False in web.config</Title>
      <ClassName>CompilationDebugMustBeDisabled</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5400:DebugCompilationMustBeDisabled</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00018</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/CompilationDebugMustBeDisabled.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>debug</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/compilation</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>false</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Debug compilation must be disabled in <b>web.config</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Make sure that debug compilation is set to <b>false</b> in <b>web.config</b>. 
  This eliminates potential performance and security issues related to debug code enabled and additional extensive error messages being returned. 
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'DebugCompilationMustBeDisabled', CheckId <b>CA5400</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">debug</span> attribute value of the <b>compilation</b> element to <b>false</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Compilation Debug should be False in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;compilation debug="true" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;compilation debug="<SPAN class=code-changed>false</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00035">
      <Name>Web.Config -&gt; Disable anonymous access</Name>
      <Title>Disable anonymous access in web.config</Title>
      <ClassName>AnonymousAccessShouldBeDisabled</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5410:AnonymousAccessIsEnabled</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00035</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AnonymousAccessShouldBeDisabled.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>users</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/authorization/deny</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>?</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value>system.web/authorization/deny[@users!="?"]</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Authorization section in <b>web.config</b> allows anonymous access.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Make sure that <b>web.config</b> authorization section is configured to disallow anonymous access.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'AnonymousAccessIsEnabled', CheckId <b>CA5410</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">users</span> attribute value of the <b>system.web.authorization.deny</b> element to <b>?</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Disable anonymous access in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;authorization&gt;
   &lt;allow users="Kim" /&gt;
   &lt;allow users="Admins" /&gt;
   &lt;!-- Deny all anonymous users--&gt;
   &lt;deny users="?"/&gt;
  &lt;/authorization&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00036">
      <Name>MVC controller action -&gt; Use ValidateAntiforgeryTokenAttribute</Name>
      <Title>Use ValidateAntiforgeryTokenAttribute to protect against potential CSRF attacks in MVC controller action</Title>
      <ClassName>MarkVerbHandlersWithValidateAntiforgeryTokenAttribute</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>11/10/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.MVC.Security, CA5332:MarkVerbHandlersWithValidateAntiforgeryToken</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00036</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/MarkVerbHandlersWithValidateAntiforgeryTokenAttribute.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[MVC Controller action method does not contain <b>System.Web.Mvc.ValidateAntiForgeryTokenAttribute</b> but defined <b>HttpVerbs.Post</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Rule that verifies that if the <b>System.Web.Mvc.ValidateAntiForgeryTokenAttribute</b> is used to protect against Potential <b>CSRF</b> attack in MVC.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'MarkVerbHandlersWithValidateAntiforgeryToken', CheckId <b>CA5332</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Add <b>System.Web.Mvc.HttpGetAttribute</b> to method</LI>
    <LI>Add <b>System.Web.Mvc.ValidateAntiForgeryTokenAttribute</b> and <b>System.Web.Mvc.HttpPostAttribute</b> to method</LI>
    <LI>Add <b>System.Web.Mvc.HttpPostAttribute</b> to method</LI>
    <LI>Comment out <b>System.Web.Mvc.HttpGetAttribute</b> in method</LI>
    <LI>Comment out <b>System.Web.Mvc.ValidateAntiForgeryTokenAttribute</b> in method</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Use ValidateAntiforgeryTokenAttribute to protect against potential CSRF attacks in MVC controller action.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Function SubmitUpdate() As ViewResult

  ...

End Function


<SPAN class=code-selected>' This is the correct implementation</SPAN>

<SPAN class=code-changed>&lt;HttpPost&gt;</SPAN> _
<SPAN class=code-changed>&lt;ValidateAntiForgeryToken&gt;</SPAN> _
Public Function SubmitUpdate() As ViewResult

  ...

End Function

	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public ViewResult SubmitUpdate()
{

  ...

}

<SPAN class=code-selected>// This is the correct implementation</SPAN>

<SPAN class=code-changed>[HttpPost]</SPAN>
<SPAN class=code-changed>[ValidateAntiForgeryToken]</SPAN>
public ViewResult SubmitUpdate()
{

  ...

}
	
	</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00034">
      <Name>Web.Config -&gt; Form authentication SlidingExpiration should be False</Name>
      <Title>Form authentication SlidingExpiration should be False in web.config</Title>
      <ClassName>FormAuthenticationSlidingExpirationShouldBeFalse</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5406:FormAuthenticationSlidingExpirationShouldBeFalse</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00034</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/FormAuthenticationSlidingExpirationShouldBeFalse.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>slidingExpiration</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/authentication/forms</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>false</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value>system.web/authentication[@mode="Forms"]/forms[@requireSSL!="true" and (@slidingExpiration="true" or not(@slidingExpiration))]</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<b>system.web.authentication.forms</b> <span class="code-fragment">slidingExpiration</span> should be set to <b>false</b> when the site is being serviced over HTTP.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that if the <b>system.web.authentication.forms</b> <span class="code-fragment">slidingExpiration</span> be set to <b>false</b> when the site is being serviced over HTTP. 
  <br />This will force the authentication cookie to have a fix timeout value instead of being refreshed by each request. Since the cookie will traverse over clear text network and can be sniffed, having a fix timeout value on the cookie will limit the amount of time the cookie can be replayed. 
  If the cookie is traversing over HTTPS, it is less likely to be intercepted and having the <span class="code-fragment">slidingExpiration</span> setting to True will cause the timeout to be refreshed after each request which gives a better user experience.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'FormAuthenticationSlidingExpirationShouldBeFalse', CheckId <b>CA5406</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">slidingExpiration</span> attribute value of the <b>system.web.authentication.forms</b> element to <b>false</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Form authentication SlidingExpiration should be False in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;authentication mode="Forms"&gt;
   &lt;forms loginUrl="~/login.aspx" protection="All" slidingExpiration="true" /&gt;
  &lt;/authentication&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;authentication mode="Forms"&gt;
   &lt;forms loginUrl="~/login.aspx" protection="All" slidingExpiration="<SPAN class=code-changed>false</SPAN>" /&gt;
  &lt;/authentication&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00033">
      <Name>Web.Config -&gt; Http runtime EnableHeaderChecking should be True</Name>
      <Title>Http runtime EnableHeaderChecking should be True in web.config</Title>
      <ClassName>HttpRuntimeEnableHeaderCheckingShouldBeTrue</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5416:HttpRuntimeEnableHeaderCheckingShouldBeTrue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00033</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/HttpRuntimeEnableHeaderCheckingShouldBeTrue.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>enableHeaderChecking</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/httpRuntime</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">system.web.httpRuntime.enableHeaderChecking</span> attribute is disabled in <b>web.config</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that the <b>system.web.httpRuntime</b> <span class="code-fragment">enableHeaderChecking</span> attribute is set to <b>true</b>.   <br />The setting indicates whether ASP.NET should check the request header for potential injection attacks. If an attack is detected, ASP.NET responds with an error. This forces ASP.NET to apply the <b>ValidateRequest</b> protection to headers sent by the client. If an attack is detected the application throws <b>HttpRequestValidationException</b>.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'HttpRuntimeEnableHeaderCheckingShouldBeTrue', CheckId <b>CA5416</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">enableHeaderChecking</span> attribute value of the <b>system.web.httpRuntime</b> element to <b>true</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Http runtime EnableHeaderChecking should be True in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;httpRuntime enableHeaderChecking="false" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;httpRuntime enableHeaderChecking="<SPAN class=code-changed>true</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00032">
      <Name>Web.Config -&gt; Page ViewStateEncryptionMode should be Always</Name>
      <Title>Page ViewStateEncryptionMode should be Always in web.config</Title>
      <ClassName>PageViewStateEncryptionModeShouldBeAlways</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5418:PagesViewStateEncryptionModeShouldBeAlways</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00032</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/PageViewStateEncryptionModeShouldBeAlways.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>viewStateEncryptionMode</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/pages</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>Always</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value>Auto</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">system.web.pages.viewStateEncryptionMode</span> attribute should be configured to <b>Always</b> in <b>web.config</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that the view state is always encrypted.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'PagesViewStateEncryptionModeShouldBeAlways', CheckId <b>CA5418</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">viewStateEncryptionMode</span> attribute value of the <b>system.web.pages</b> element to <b>Always</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Page ViewStateEncryptionMode should be Always in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;pages viewStateEncryptionMode="Auto" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;pages viewStateEncryptionMode="<SPAN class=code-changed>Always</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00031">
      <Name>Web.Config -&gt; Page ValidateRequest should be True</Name>
      <Title>Page ValidateRequest should be True in web.config</Title>
      <ClassName>PageValidateRequestShouldBeEnabled</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5417:PagesValidateRequestShouldBeEnabled</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00031</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/PageValidateRequestShouldBeEnabled.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>validateRequest</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/pages</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">system.web.pages.validateRequest</span> attribute is disabled in <b>web.config</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that <span class="code-fragment">system.web.pages.validateRequest</span> attribute is set to <b>true</b> which indicates that ASP.NET examines all input from the browser for potentially dangerous data. Request validation is performed by comparing all input data to a list of potentially dangerous values. If a match occurs, ASP.NET raises an HttpRequestValidationException exception.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'PagesValidateRequestShouldBeEnabled', CheckId <b>CA5417</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">validateRequest</span> attribute value of the <b>system.web.pages</b> element to <b>true</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Page ValidateRequest should be True in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;pages validateRequest="false" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;pages validateRequest="<SPAN class=code-changed>true</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00030">
      <Name>Web.Config -&gt; Page EnableEventValidation should be True</Name>
      <Title>Page EnableEventValidation should be True in web.config</Title>
      <ClassName>PageEnableEventValidationMustBeTrue</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5415:PagesEnableEventValidationMustBeTrue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00030</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/PageEnableEventValidationMustBeTrue.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>enableEventValidation</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/pages</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">system.web.pages.enableEventValidation</span> attribute is disabled in <b>web.config</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Make sure that event validation is enabled. If so, the page validates postback and callback events. 
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'PagesEnableEventValidationMustBeTrue', CheckId <b>CA5415</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">enableEventValidation</span> attribute value of the <b>system.web.pages</b> element to <b>true</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Page EnableEventValidation should be True in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;pages enableEventValidation="false" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;pages enableEventValidation="<SPAN class=code-changed>true</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00029">
      <Name>Web.Config -&gt; Page EnableViewStateMac should be True</Name>
      <Title>Page EnableViewStateMac should be True in web.config</Title>
      <ClassName>PageEnableViewStateMacShouldBeTrue</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5414:PagesEnableViewStateMacShouldBeTrue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00029</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/PageEnableViewStateMacShouldBeTrue.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>enableViewStateMac</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/pages</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">system.web.pages.enableViewStateMac</span> attribute is disabled in <b>web.config</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[<span class="code-fragment">EnableViewStateMac</span> attribute specifies whether ASP.NET should run a message authentication code (MAC) on the view state for the page when the page is posted back from the client. 
  The directive should be set to <b>True</b>. If so, the encrypted view state is checked to verify that it has not been tampered with on the client.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'PagesEnableViewStateMacShouldBeTrue', CheckId <b>CA5414</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">enableViewStateMac</span> attribute value of the <b>system.web.pages</b> element to <b>true</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Page EnableViewStateMac should be True in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;pages enableViewStateMac="false" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;pages enableViewStateMac="<SPAN class=code-changed>true</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00028">
      <Name>Web.Config -&gt; Role manager CookieSlidingExpiration should be False</Name>
      <Title>Role manager CookieSlidingExpiration should be False in web.config</Title>
      <ClassName>RoleManagerCookieSlidingExpirationShouldBeFalse</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5413:RoleManagerCookieSlidingExpirationShouldBeFalse</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00028</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/RoleManagerCookieSlidingExpirationShouldBeFalse.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>cookieSlidingExpiration</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/roleManager</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>false</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value>system.web/roleManager[@enabled="true" and @cookieRequireSSL!="true" and (@cookieSlidingExpiration="true" or not(@cookieSlidingExpiration))]</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<b>system.web.rolemanager</b> <span class="code-fragment">cookieSlidingExpiration</span> should be set to <b>false</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that the <b>system.web.roleManager</b> <span class="code-fragment">cookieSlidingExpiration</span> is set to <b>false</b> when the site is being serviced over HTTP. 
  <br />This will force the authentication cookie to have a fix timeout value instead of being refreshed by each request. Since the cookie will traverse over clear text network and can be sniffed, having a fix timeout value on the cookie will limit the amount of time the cookie can be replayed. If the cookie is traversing over HTTPS, it is less likely to be intercepted and having the <span class="code-fragment">cookieSlidingExpiration</span> setting to <b>True</b> will cause the timeout to be refreshed after each request which gives a better user experience.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'RoleManagerCookieSlidingExpirationShouldBeFalse', CheckId <b>CA5413</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">cookieSlidingExpiration</span> attribute value of the <b>system.web.roleManager</b> element to <b>false</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Role manager CookieSlidingExpiration should be False in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;roleManager enabled="true" cookieRequireSSL="true" cookieSlidingExpiration="true" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;roleManager enabled="true" cookieRequireSSL="true" cookieSlidingExpiration="<SPAN class=code-changed>false</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00027">
      <Name>Web.Config -&gt; Role manager CookieRequireSSL should be True</Name>
      <Title>Role manager CookieRequireSSL should be True in web.config</Title>
      <ClassName>RoleManagerCookieRequireSSLShouldBeTrue</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5412:RoleManagerCookieRequireSSLShouldBeTrue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00027</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/RoleManagerCookieRequireSSLShouldBeTrue.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>cookieRequireSSL</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/roleManager</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value>false</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value>system.web/roleManager[@enabled="true"]</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<b>system.web.rolemanager</b> <span class="code-fragment">cookieRequireSSL</span> attribute should be set to <b>true</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that the <b>system.web.roleManager</b> <span class="code-fragment">cookieRequireSSL</span> attribute is set to <b>true</b> which force the role manager cookie to specify the secure attribute. 
  <br />This indicates the browser to only provide the cookie over SSL.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'RoleManagerCookieRequireSSLShouldBeTrue', CheckId <b>CA5412</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">cookieRequireSSL</span> attribute value of the <b>system.web.roleManager</b> element to <b>true</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Role manager CookieRequireSSL should be True in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;roleManager enabled="true" cookieRequireSSL="false" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;roleManager enabled="true" cookieRequireSSL="<SPAN class=code-changed>true</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00026">
      <Name>Web.Config -&gt; Role manager CookieProtection should be All</Name>
      <Title>Role manager CookieProtection should be All in web.config</Title>
      <ClassName>RoleManagerCookieProtectionShouldBeAll</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5411:RoleManagerCookieProtectionShouldBeAll</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00026</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/RoleManagerCookieProtectionShouldBeAll.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>cookieProtection</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/roleManager</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>All</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value>system.web/roleManager[@enabled="true"]</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<b>system.web.rolemanager</b> <span class="code-fragment">cookieProtection</span> should be set to <b>All</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that the <b>system.web.roleManager</b> <span class="code-fragment">cookieProtection</span> is set to <b>All</b> which enforce both the cookie to be encrypted and validated by the server.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'RoleManagerCookieProtectionShouldBeAll', CheckId <b>CA5411</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">cookieProtection</span> attribute value of the <b>system.web.roleManager</b> element to <b>All</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Role manager CookieProtection should be All in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;roleManager enabled="true" cookieProtection="None" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;roleManager enabled="true" cookieProtection="<SPAN class=code-changed>All</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00025">
      <Name>Web.Config -&gt; Trace should be disabled</Name>
      <Title>Trace should be disabled in web.config</Title>
      <ClassName>TraceShouldBeDisabled</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5409:TraceShouldBeDisabled</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00025</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/TraceShouldBeDisabled.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>enabled</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/trace</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>false</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">system.web.trace</span> should be set to <b>false</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that the <b>system.web.trace</b> is set to <b>false</b> which disable tracing. It is recommended to disable tracing on production servers to make sure that an attacker cannot gain information from the trace about your application. Trace information can help an attacker probe and compromise your application.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'TraceShouldBeDisabled', CheckId <b>CA5409</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">enabled</span> attribute value of the <b>system.web.trace</b> element to <b>false</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Trace should be disabled in web.config.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;trace enabled="true" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;trace enabled="<SPAN class=code-changed>false</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00024">
      <Name>Web.Config -&gt; Http cookies RequireSSL should be True</Name>
      <Title>Http cookies RequireSSL should be True in web.config</Title>
      <ClassName>HttpCookiesRequireSSLShouldBeTrue</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5408:HttpCookiesRequireSSLShouldBeTrue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00024</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/HttpCookiesRequireSSLShouldBeTrue.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>requireSSL</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/httpCookies</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value>false</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<b>system.web.httpCookies</b> <span class="code-fragment">requireSSL</span> configuration should be set to <b>true</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that the <b>system.web.httpCookies</b> <span class="code-fragment">requireSSL</span> configuration is set to <b>true</b> which force all cookies to be sent with the secure attribute. 
  <br />This indicates the browser to only provide the cookie over SSL.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'HttpCookiesRequireSSLShouldBeTrue', CheckId <b>CA5408</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">requireSSL</span> attribute value of the <b>system.web.httpCookies</b> element to <b>true</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Http cookies RequireSSL should be True in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;httpCookies requireSSL="false" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;httpCookies requireSSL="<SPAN class=code-changed>true</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00023">
      <Name>Web.Config -&gt; Http cookies HttpOnlyCookies should be True</Name>
      <Title>Http cookies HttpOnlyCookies should be True in web.config</Title>
      <ClassName>HttpOnlyCookiesShouldBeTrue</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5407:HttpCookiesHttpOnlyCookiesShouldBeTrue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00023</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/HttpOnlyCookiesShouldBeTrue.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>httpOnlyCookies</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/httpCookies</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value>false</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">system.web.httpCookies.httpOnlyCookies</span> configuration should be set to <b>true</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that the <b>system.web.httpCookies</b> <span class="code-fragment">httpOnlyCookies</span> configuration is set to <b>true</b> which force all cookies to be sent with the HttpOnly attribute.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'HttpCookiesHttpOnlyCookiesShouldBeTrue', CheckId <b>CA5407</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">httpOnlyCookies</span> attribute value of the <b>system.web.httpCookies</b> element to <b>true</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Http cookies HttpOnlyCookies should be True in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;httpCookies requireSSL="true" httpOnlyCookies="false" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;httpCookies requireSSL="true" httpOnlyCookies="<SPAN class=code-changed>true</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00022">
      <Name>Web.Config -&gt; Form authentication RequireSSL should be True</Name>
      <Title>Form authentication RequireSSL should be True in web.config</Title>
      <ClassName>FormAuthenticationRequireSSLShouldBeTrue</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5405:FormAuthenticationRequireSSLShouldBeTrue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00022</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/FormAuthenticationRequireSSLShouldBeTrue.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>requireSSL</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/authentication/forms</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value>false</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value>system.web/authentication[@mode="Forms"]</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">requireSSL</span> attribute on the <b>system.web.authentication.forms</b> configuration element should be set to <b>true</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that the <span class="code-fragment">RequireSSL</span> attribute on the <b>system.web.authentication.forms</b> configuration element is set to <b>true</b> which force the authentication cookie to specify the secure attribute. 
  <br />This indicates the browser to only provide the cookie over SSL.  
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'FormAuthenticationRequireSSLShouldBeTrue', CheckId <b>CA5405</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">RequireSSL</span> attribute value of the <b>system.web.authentication.forms</b> element to <b>true</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Form authentication RequireSSL should be True in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;authentication mode="Forms"&gt;
   &lt;forms loginUrl="~/login.aspx" protection="All" requireSSL="false" /&gt;
  &lt;/authentication&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;authentication mode="Forms"&gt;
   &lt;forms loginUrl="~/login.aspx" protection="All" requireSSL="<SPAN class=code-changed>true</SPAN>" /&gt;
  &lt;/authentication&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00021">
      <Name>Web.Config -&gt; Disable form authentication EnableCrossAppRedirects</Name>
      <Title>Disable form authentication EnableCrossAppRedirects in web.config</Title>
      <ClassName>EnableCrossAppRedirectsShouldBeFalse</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5403:EnableCrossAppRedirectsShouldBeTrue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00021</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/EnableCrossAppRedirectsShouldBeFalse.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>enableCrossAppRedirects</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/authentication/forms</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>false</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value>system.web/authentication[@mode="Forms"]</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Form authentication EnableCrossAppRedirects should be disabled in <b>web.config</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Make sure that the <span class="code-fragment">system.web.authentication.forms enableCrossAppRedirects</span> is set to <b>false</b>.
  <br/>The settings indicate if the user should be redirected to another application url after the authentication process. 
  If the setting is <b>false</b>, the authentication process will not allow redirection to another application or host.   
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'EnableCrossAppRedirectsShouldBeTrue', CheckId <b>CA5403</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">enableCrossAppRedirects</span> attribute value of the <b>system.web.authentication.forms</b> element to <b>false</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Disable form authentication EnableCrossAppRedirects in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;authentication mode="Forms"&gt;
   &lt;forms loginUrl="~/login.aspx" protection="All" requireSSL="true" enableCrossAppRedirects="true" /&gt;
  &lt;/authentication&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;authentication mode="Forms"&gt;
   &lt;forms loginUrl="~/login.aspx" protection="All" requireSSL="true" enableCrossAppRedirects="<SPAN class=code-changed>false</SPAN>" /&gt;
  &lt;/authentication&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00020">
      <Name>Web.Config -&gt; Form authentication Protection should be All</Name>
      <Title>Form authentication Protection should be All in web.config</Title>
      <ClassName>FormAuthenticationProtectionShouldBeAll</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5404:FormAuthenticationProtectionShouldBeAll</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00020</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/FormAuthenticationProtectionShouldBeAll.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>protection</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/authentication/forms</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>All</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value>system.web/authentication[@mode="Forms"]</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">protection</span> attribute on the <b>system.web.authentication.forms</b> protection should be set to <b>All</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that the protection attribute on the <b>system.web.authentication.forms</b> protection is set to <b>All</b> which specifies that the application use both data validation and encryption to help protect the authentication cookie.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'FormAuthenticationProtectionShouldBeAll', CheckId <b>CA5404</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">protection</span> attribute value of the <b>system.web.authentication.forms</b> element to <b>All</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Form authentication Protection should be All in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;authentication mode="Forms"&gt;
   &lt;forms loginUrl="~/login.aspx" protection="None" /&gt;
  &lt;/authentication&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;authentication mode="Forms"&gt;
   &lt;forms loginUrl="~/login.aspx" protection="<SPAN class=code-changed>All</SPAN>" /&gt;
  &lt;/authentication&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00019">
      <Name>Web.Config -&gt; Do not disable custom errors</Name>
      <Title>Do not disable custom errors in web.config</Title>
      <ClassName>CustomErrorsModeShouldBeOn</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5419:CustomErrorsModeShouldBeOn</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00019</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/CustomErrorsModeShouldBeOn.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>mode</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/customErrors</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value>On;RemoteOnly</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Custom errors should be enabled in <b>web.config</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Make sure that the <b>customErrors</b> <span class="code-fragment">mode</span> is set to <b>On</b> or <b>RemoteOnly</b>. 
  This disable detailed error message returned by ASP.NET to remote users.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'CustomErrorsModeShouldBeOn', CheckId <b>CA5419</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">mode</span> attribute value of the <b>customErrors</b> element to <b>On</b> in <b>web.config</b></LI>
    <LI>Set <span class="code-fragment">mode</span> attribute value of the <b>customErrors</b> element to <b>RemoteOnly</b> in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not disable custom errors in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;customErrors mode="Off" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;customErrors mode="<SPAN class=code-changed>On</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00017">
      <Name>Type -&gt; EnableViewState should be True</Name>
      <Title>EnableViewState should be True</Title>
      <ClassName>EnableViewStateShouldBeTrue</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>File</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security, CA5331:EnableViewStateShouldBeTrue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00017</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/EnableViewStateShouldBeTrue.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>DirectiveToCheck</Name>
          <Value>EnableViewState</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>DirectiveExpectedValue</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">EnableViewState</span> directive is disabled on the page.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The directive should be set to <b>True</b>.
  <span class="code-fragment">EnableViewState</span> directive specifies whether view state is enabled and maintained across page requests. 
  <br />  
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'EnableViewStateShouldBeTrue', CheckId <b>CA5331</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">EnableViewState</span> directive value to <b>true</b> on the page</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>EnableViewState should be True.</li>            
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;%@ Page language="C#" EnableViewState="False" %&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;%@ Page language="C#" EnableViewState="<SPAN class=code-changed>True</SPAN>" %&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00016">
      <Name>Type -&gt; EnableViewStateMac should be True</Name>
      <Title>EnableViewStateMac should be True</Title>
      <ClassName>EnableViewStateMacShouldBeTrue</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>File</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security, CA5330:EnableViewStateMacShouldBeTrue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00016</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/EnableViewStateMacShouldBeTrue.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>DirectiveToCheck</Name>
          <Value>EnableViewStateMac</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>DirectiveExpectedValue</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">EnableViewStateMac</span> directive is disabled on the page.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[<span class="code-fragment">EnableViewStateMac</span> directive specifies whether ASP.NET should run a message authentication code (MAC) on the view state for the page when the page is posted back from the client. 
  The directive should be set to <b>True</b>. If so, the encrypted view state is checked to verify that it has not been tampered with on the client.
  <br />  
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'EnableViewStateMacShouldBeTrue', CheckId <b>CA5330</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">EnableViewStateMac</span> directive value to <b>true</b> on the page</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>EnableViewStateMac should be True.</li>            
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;%@ Page language="C#" EnableViewStateMac="False" %&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;%@ Page language="C#" EnableViewStateMac="<SPAN class=code-changed>True</SPAN>" %&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00015">
      <Name>Type -&gt; ViewStateEncryptionMode should be Always</Name>
      <Title>ViewStateEncryptionMode should be Always</Title>
      <ClassName>ViewStateEncryptionModeShouldBeAlways</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>File</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security, CA5329:ViewStateEncryptionModeShouldBeAlways</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00015</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ViewStateEncryptionModeShouldBeAlways.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>DirectiveToCheck</Name>
          <Value>ViewStateEncryptionMode</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>DirectiveExpectedValue</Name>
          <Value>Always</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">ViewStateEncryptionMode</span> should be <b>Always</b> on the page.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that the view state is always encrypted.
  <br />  
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'ViewStateEncryptionModeShouldBeAlways', CheckId <b>CA5329</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">ViewStateEncryptionMode</span> directive value to <b>Always</b> on the page</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>ViewStateEncryptionMode should be Always.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;%@ Page language="C#" AutoEventWireup="true" ViewStateEncryptionMode="Auto" %&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;%@ Page language="C#" AutoEventWireup="true" ViewStateEncryptionMode="<SPAN class=code-changed>Always</SPAN>" %&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00014">
      <Name>Type -&gt; ValidateRequest should be True</Name>
      <Title>ValidateRequest should be True</Title>
      <ClassName>ValidateRequestShouldBeEnabled</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>File</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security, CA5328:ValidateRequestShouldBeEnabled</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ValidateRequestShouldBeEnabled.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>DirectiveToCheck</Name>
          <Value>ValidateRequest</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>DirectiveExpectedValue</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">ValidateRequest</span> directive is disabled on the page.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that <span class="code-fragment">ValidateRequest</span> directive is enabled on the page which indicates that ASP.NET examines all input from the browser for potentially dangerous data. Request validation is performed by comparing all input data to a list of potentially dangerous values. If a match occurs, ASP.NET raises an HttpRequestValidationException exception.
  <br />  
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'ValidateRequestShouldBeEnabled', CheckId <b>CA5328</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">ValidateRequest</span> directive value to <b>true</b> on the page</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>ValidateRequest should be True.</li>            
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;%@ Page language="C#" AutoEventWireup="true" ValidateRequest="False" %&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;%@ Page language="C#" AutoEventWireup="true" ValidateRequest="<SPAN class=code-changed>True</SPAN>" %&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00013">
      <Name>Type -&gt; EnableEventValidation should be True</Name>
      <Title>EnableEventValidation should be True</Title>
      <ClassName>EnableEventValidationShouldBeTrue</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>File</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security, CA5327:EnableEventValidationShouldBeTrue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00013</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/EnableEventValidationShouldBeTrue.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>DirectiveToCheck</Name>
          <Value>EnableEventValidation</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>DirectiveExpectedValue</Name>
          <Value>true</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[<span class="code-fragment">EnableEventValidation</span> directive is disabled on the page.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Make sure that event validation is enabled. If so, the page validates postback and callback events. 
  <br />  
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'EnableEventValidationShouldBeTrue', CheckId <b>CA5327</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set <span class="code-fragment">EnableEventValidation</span> directive value to <b>true</b> on the page</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <LI>EnableEventValidation should be True.</LI>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;%@ Page language="C#" EnableEventValidation="False" %&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;%@ Page language="C#" EnableEventValidation="<SPAN class=code-changed>True</SPAN>" %&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00012">
      <Name>MVC controller action -&gt; Enable request validation</Name>
      <Title>Enable request validation in MVC controller action</Title>
      <ClassName>MVCControllerActionShouldValidateInput</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>11/10/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.MVC.Security, CA5333:ControllerActionShouldValidateInput</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00012</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/MVCControllerActionShouldValidateInput.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Make sure that the <b>ValidateInputAttribute</b> is used properly to protect against <b>XSS</b> attacks.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies if the <b>ValidateInputAttribute</b> is used properly to protect against <b>XSS</b> attacks.<br />
  <b>ValidateInputAttribute</b> attribute can be used to mark action methods whose input must be validated.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'ControllerActionShouldValidateInput', CheckId <b>CA5333</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
	<LI>Set <b>ValidateRequestAttribute</b> value to true.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Enable request validation in MVC controller action.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

&lt;ValidateInput(False)&gt; _
Public Function Create() As ActionResult

  ' Do something...

End Function


<SPAN class=code-selected>' This is the correct implementation</SPAN>

&lt;ValidateInput(<SPAN class=code-changed>True</SPAN>)&gt; _
Public Function Create() As ActionResult

  ' Do something...

End Function

	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

[ValidateInput(false)]
public ActionResult Create()
{

  // Do something...

}

<SPAN class=code-selected>// This is the correct implementation</SPAN>

[ValidateInput(<SPAN class=code-changed>true</SPAN>)]
public ActionResult Create()
{

  // Do something...

}
	
	</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00011">
      <Name>Web.Config -&gt; Form authentication should not contain credentials</Name>
      <Title>Form authentication should not contain credentials in web.config</Title>
      <ClassName>FormAuthenticationShouldNotContainCredentials</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5402:FormAuthenticationShouldNotContainFormAuthenticationCredentials</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00011</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/FormAuthenticationShouldNotContainCredentials.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SecondaryXPathCondition</Name>
          <Value>system.web/authentication/forms/credentials/user</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value>system.web/authentication[@mode="Forms"]</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Make sure that no credentials are specified under the form authentication configuration.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule verifies that no credentials are specified under the form authentication configuration.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'FormAuthenticationShouldNotContainFormAuthenticationCredentials', CheckId <b>CA5402</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Modify your code manually to remove <span class="code-fragment">users</span> nodes from form authentication credentials in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Form authentication should not contain credentials in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;authentication mode="Forms"&gt;
   &lt;forms /&gt;
  &lt;/authentication&gt;
 &lt;/system.web>&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00010">
      <Name>Web.Config -&gt; Custom error DefaultRedirect should be specified</Name>
      <Title>Custom errors DefaultRedirect should be specified in web.config</Title>
      <ClassName>CustomErrorPageShouldBeSpecified</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet;Security</RuleCategory>
      <RuleModificationDate>8/23/2011</RuleModificationDate>
      <RuleFxCopMapping>ASP.NET.Security.Configuration, CA5401:CustomErrorPageShouldBeSpecified</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00010</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/CustomErrorPageShouldBeSpecified.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>defaultRedirect</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeXPath</Name>
          <Value>system.web/customErrors</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeExpectedValues</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>AttributeDefaultValue</Name>
          <Value />
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrimaryXPathCondition</Name>
          <Value>system.web/customErrors[@mode!="Off"]</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Custom error page should be specified in <b>web.config</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Make sure that the <b>CustomErrors</b> section is configured to have a default url for redirecting uses in case of error.
  <br />
  <br />
  <i>This rule is similar to <b>FxCop</b> rule 'CustomErrorPageShouldBeSpecified', CheckId <b>CA5401</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Modify your code manually to set <span class="code-fragment">defaultRedirect</span> attribute of the <b>system.web.customErrors</b> element in <b>web.config</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Custom errors DefaultRedirect should be specified in web.config.</li>        
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;configuration&gt;
 &lt;system.web&gt;
  &lt;customErrors mode="On" defaultRedirect="<SPAN class=code-changed>/Error.aspx</SPAN>" /&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AN00001">
      <Name>Expression -&gt; Do not use deprecated properties of Response object</Name>
      <Title>Do not use deprecated properties of Response object</Title>
      <ClassName>DoNotUseDeprecatedPropertiesOfResponseObject</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Expression</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet</RuleCategory>
      <RuleModificationDate>12/28/2009</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotUseDeprecatedPropertiesOfResponseObject.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[There is used deprecated property of <b>System.Web.HttpResponse</b> class.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The following properties of the Response object are deprecated and should not be used:
  <UL>
		<LI><b>System.Web.HttpResponse.CacheControl</b> (methods of <b>System.Web.HttpCachePolicy</b> class should be used instead).</LI>
		<LI><b>System.Web.HttpResponse.Expires</b> (methods of <b>System.Web.HttpCachePolicy</b> class should be used instead).</LI>
		<LI><b>System.Web.HttpResponse.ExpiresAbsolute</b> (methods of <b>System.Web.HttpCachePolicy</b> class should be used instead).</LI>
		<LI><b>System.Web.HttpResponse.Buffer</b> (<b>System.Web.HttpResponse.BufferOutput</b> property should be used instead).</LI>
  </UL>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<LI>Use recommended property or class instead of deprecated property.</LI>
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not use deprecated properties of Response object.</li>
  </ul>
  <p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="AN00004">
      <Name>Expression -&gt; Do not use SaveAs method to store uploaded files</Name>
      <Title>Do not use SaveAs method to store uploaded files</Title>
      <ClassName>DoNotUseSaveAsMethodToStoreUploadedFiles</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Expression</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>AspNet</RuleCategory>
      <RuleModificationDate>12/28/2009</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AN00004</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotUseSaveAsMethodToStoreUploadedFiles.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[<b>System.Web.HttpPostedFile.SaveAs</b> method is invoked.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Avoid using <b>System.Web.HttpPostedFile.SaveAs</b> method to store the incoming data to temporary files 
  on the server's hard disk. Instead, read data from the incoming stream and save it directly to the 
  appropriate data store, for example, a database.<br />
  <br />
  The <b>System.Web.HttpPostedFile.SaveAs</b> method requires that you grant ASP.NET an identity 
  with the permission to write to the server's hard disk.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<LI>Manually read data from the incoming stream and save it directly to the appropriate data store.</LI>
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not use SaveAs method to store uploaded files.</li>
  </ul>
  <p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="AS00002">
      <Name>Async Method -&gt; Should have "Async" suffix</Name>
      <Title>Async method should have "Async" suffix</Title>
      <ClassName>AsyncMethodShouldHaveAsyncSuffix</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Abstract, Static, Virtual, Override</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Async;Naming</RuleCategory>
      <RuleModificationDate>2/13/2013</RuleModificationDate>
      <RuleAuthor />
      <RuleEmail />
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AS00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AsyncMethodShouldHaveAsyncSuffix.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Public method is marked as <b>async</b> modifier but does ends with an <b>Async</b> suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Initiation and completion of an asynchronous operation in the <b>TAP</b> are represented by a single method, and thus there is only one method to name. Asynchronous methods in the <b>TAP</b> are named with an <b>Async</b> suffix that follows the operation's name, e.g. <i>MethodName<b>Async</b></i>. (If adding a TAP method to a class that already contains a method <i>MethodName<b>Async</b></i>, the suffix <b>TaskAsync</b> may be used instead, resulting in <i>MethodName<b>TaskAsync</b></i>.)]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Rename code element <span class="code-fragment">MethodName</span> and its references to <span class="code-fragment">MethodNameAsync</span>.</li>
    <li>Rename code element <span class="code-fragment">MethodName</span> and its references to the specified name.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Async method should have <b>Async</b> suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Namespace AsyncMethodsShouldHaveTheSuffixAsync.Test
      Public Class SomeClass
        <SPAN class=code-selected>' Violates the rule</SPAN>
        Public Function SomeMethod() As Task
          Dim tsk = Task.Factory.StartNew(Function() 
                                          End Function)
          Await tsk
        End Function
      End Class
    End Namespace
    
<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace AsyncMethodsShouldHaveTheSuffixAsync.Test
      Public Class SomeClass
        Public Function SomeMethodAsync() As Task <SPAN class=code-selected>' FIX: Add <b>Async</b> suffix</SPAN>
          Dim tsk = Task.Factory.StartNew(Function() 
                                          End Function)
          Await tsk
        End Function
      End Class
    End Namespace
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace AsyncMethodsShouldHaveTheSuffixAsync.Test
    {
      public class SomeClass
      {
        <SPAN class=code-selected>// Violates the rule</SPAN>
        public async Task SomeMethod()
        {
          var tsk = Task.Factory.StartNew(() => {});
          await tsk;
        }
      }
    }
    
<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace AsyncMethodsShouldHaveTheSuffixAsync.Test
    {
      public class SomeClass
      {
        public async Task SomeMethodAsync() <SPAN class=code-selected>// FIX: Add <b>Async</b> suffix</SPAN>
        {
          var tsk = Task.Factory.StartNew(() => {});
          await tsk;
        }
      }
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AS00009">
      <Name>Async Method -&gt; Should have await statement</Name>
      <Title>Async method should have await statement</Title>
      <ClassName>AsyncMethodShouldHaveAwaitStatement</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Async</RuleCategory>
      <RuleModificationDate>2/24/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AS00009</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AsyncMethodShouldHaveAwaitStatement.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Public method is marked as <b>async</b> but no <b>await</b> statement is found in its body.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[If you call an API which returns a <b>Task</b>, you should almost always await it either immediately or later on or indirectly through something like <b>Task.Wait</b>. Compilers have a warning in some cases but not all.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Remove <b>async</b> modifier from the async method.</li>
    <li>Add <b>await</b> statement to the async method manually.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Async method should have <b>await</b> statement.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Namespace AsyncMethodShouldHaveAwaitStatement.Test
      Public Class SomeClass
        <SPAN class=code-selected>' Violates the rule</SPAN>
        Public Function SomeMethodAsync() As Task
        End Function
      End Class
    End Namespace
    
<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace AsyncMethodShouldHaveAwaitStatement.Test
      Public Class SomeClass
        Public Function SomeMethodAsync() As Task
          <SPAN class=code-selected>' FIX: Added async code invocation</SPAN>
          Dim tsk = Task.Factory.StartNew(Function() 
                                          End Function)
          Await tsk
        End Function
      End Class
    End Namespace
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace AsyncMethodShouldHaveAwaitStatement.Test
    {
      public class SomeClass
      {
        <SPAN class=code-selected>// Violates the rule</SPAN>
        public async Task SomeMethodAsync()
        {
        }
      }
    }
    
<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace AsyncMethodShouldHaveAwaitStatement.Test
    {
      public class SomeClass
      {
        public async Task SomeMethodAsync()
        {
          <SPAN class=code-selected>// FIX: Added async code invocation</SPAN>
          var tsk = Task.Factory.StartNew(() => {});
          await tsk;
        }
      }
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AS00003">
      <Name>Async Method -&gt; Should return Task or Task&lt;T&gt;</Name>
      <Title>Async method should return Task or Task&lt;T&gt;</Title>
      <ClassName>AsyncMethodShouldReturnTask</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Async</RuleCategory>
      <RuleModificationDate>2/13/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AS00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AsyncMethodShouldReturnTask.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Public method is marked as <b>async</b> but return type is not <b>System.Threading.Tasks.Task</b> or <b>System.Threading.Tasks.Task&lt;T&gt;</b>]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[In <b>TAP</b> the singular method returns either a <b>Task</b> or a <b>Task&lt;TResult&gt;</b>, based on whether the corresponding synchronous method would return <b>void</b> or a type <b>TResult</b>, respectively.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Specify <b>Task</b> or <b>Task&lt;T&gt;</b> return type for the method.
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Async methods should return <b>Task</b> or <b>Task&lt;T&gt;</b>.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Namespace AsyncMethodsShouldReturnTask.Tests
      Public Class SomeClass
        <SPAN class=code-selected>' Violates the rule</SPAN>
        Public Function SomeMethodAsync() As Integer
          Return 0
        End Function
      End Class
    End Namespace
    
<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace AsyncMethodsShouldReturnTask.Tests
      Public Class SomeClass
        Public Function SomeMethodAsync() As Task(Of Integer)
          Dim value As Integer = Await Task.Factory.StartNew(Function() 0)
          Return value
        End Function
      End Class
    End Namespace
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace AsyncMethodsShouldReturnTask.Tests
    {
      public class SomeClass
      {
        <SPAN class=code-selected>// Violates the rule</SPAN>
        public async int SomeMethodAsync()
        {
          return 0;
        }
      }
    }
    
<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace AsyncMethodsShouldReturnTask.Tests
    {
      public class SomeClass
      {
        public async Task&lt;int&gt; SomeMethodAsync()
        {
          int value = await Task.Factory.StartNew(() => 0);
          return value;
        }
      }
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AS00004">
      <Name>Async Method -&gt; Avoid "out" and "ref" parameters</Name>
      <Title>Avoid "out" and "ref" parameters in async method</Title>
      <ClassName>AvoidOutAndRefParametersInAsyncMethod</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Method</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Async</RuleCategory>
      <RuleModificationDate>2/13/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AS00004</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidOutAndRefParametersInAsyncMethod.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Public method is marked as <b>async</b> has one or many <b>out</b> or <b>ref</b> parameters.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The parameters to a <b>TAP</b> method should be the same parameters provided to the synchronous counterpart, in the same order.  However, <b>out</b> and <b>ref</b> parameters are exempted from this rule and should be avoided entirely. Any data that would have been returned through an out or ref parameter should instead be returned as part of the returned <b>Task&lt;TResult&gt;'s</b> Result, utilizing a <b>Tuple</b> or a custom data structure in order to accommodate multiple values.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Remove <b>ref</b> or <b>out</b> parameters from the method manually.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
     <li>Avoid &quot;out&quot; and &quot;ref&quot; parameters in async method</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Namespace AvoidOutAndRefParametersInAsyncMethods.Test
      Public Class SomeClass
        <SPAN class=code-selected>' Violates the rule</SPAN>
        Public Function SomeMethodAsync(ByRef a As Integer, ByRef b As Integer) As Task
          a = 42
          b += 42
        End Function
      End Class
    End Namespace
    
<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace AvoidOutAndRefParametersInAsyncMethods.Test
      Public Class SomeClass
        Public Function SomeMethodAsync(b As Integer) As Task(Of Tuple(Of Integer, Integer))
          Return New Tuple(Of Integer, Integer)(42, b + 42)
        End Function
      End Class
    End Namespace
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace AvoidOutAndRefParametersInAsyncMethods.Test
    {
      public class SomeClass
      {
        <SPAN class=code-selected>// Violates the rule</SPAN>
        public async Task SomeMethodAsync(out int a, ref int b)
        {
          a = 42;
          b += 42;
        }
      }
    }
    
<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace AvoidOutAndRefParametersInAsyncMethods.Test
    {
      public class SomeClass
      {
        public async Task&lt;Tuple&lt;int, int&gt;&gt; SomeMethodAsync(int b)
        {
          return new Tuple&lt;int, int&gt;(42, b + 42);
        }
      }
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AS00007">
      <Name>Async Method -&gt; Await for completion</Name>
      <Title>Await for completion of an API which returns a Task</Title>
      <ClassName>AwaitForTaskCompletion</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Method</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Async</RuleCategory>
      <RuleModificationDate>2/13/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AS00007</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AwaitForTaskCompletion.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[<b>Async</b> method is called but is not awaited with either:
  <ul>
    <li>await</li>
    <li>Task.Wait, Task.WaitAll, Task.WaitAny</li>
    <li>Task.WhenAll, Task.WhenAny</li>
  </ul>]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[If you call an API which returns a <b>Task</b>, you should almost always <b>await</b> it either immediately or later on or indirectly through something like <b>Task.Wait</b>.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Specify <b>await</b> for the method call that returns <b>Task</b> manually</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Await for completion of an API which returns a <b>Task</b>.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Namespace AwaitForCompletionOfTask.Test
      Public Class SomeClass
        Private Function IoBoundOperationAsync() As Task(Of Integer)
          Return Task(Of Integer).Factory.StartNew(Function() 42)
        End Function

        Public Function SomeMethodAsync() As Task(Of Integer)
          <SPAN class=code-selected>' Violates the rule</SPAN>
          Dim value As Integer = IoBoundOperationAsync().Result
          Return value
        End Function
      End Class
    End Namespace
    
<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace AwaitForCompletionOfTask.Tests
      Public Class SomeClass
        Private Function IoBoundOperationAsync() As Task(Of Integer)
          Return Task(Of Integer).Factory.StartNew(Function() 42)
        End Function

        Public Function SomeMethodAsync() As Task(Of Integer)
          <SPAN class=code-selected>' FIX: Await for completion of operation</SPAN>
          Dim value As Integer = Await IoBoundOperationAsync()
          Return value
        End Function
      End Class
    End Namespace

  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace AwaitForCompletionOfTask.Test
    {
      public class SomeClass
      {
        private Task<int> IoBoundOperationAsync()
        {
          return Task<int>.Factory.StartNew(() => 42);
        }

        public async Task<int> SomeMethodAsync()
        {
          <SPAN class=code-selected>// Violates the rule</SPAN>
          int value = IoBoundOperationAsync().Result;
          return value;
        }
      }
    }
    
<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace AwaitForCompletionOfTask.Tests
    {
      public class SomeClass
      {
        private Task<int> IoBoundOperationAsync()
        {
          return Task<int>.Factory.StartNew(() => 42);
        }

        public async Task<int> SomeMethodAsync()
        {
          <SPAN class=code-selected>// FIX: await for completion of operation</SPAN>
          int value = await IoBoundOperationAsync();
          return value;
        }
      }
    }

  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AS00010">
      <Name>Await Statement Method -&gt; Should be async</Name>
      <Title>Await statement method should be async</Title>
      <ClassName>AwaitStatementMethodShouldBeAsync</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Async</RuleCategory>
      <RuleModificationDate>2/24/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AS00010</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AwaitStatementMethodShouldBeAsync.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Method contains <b>await</b> statement but not marked with <b>async</b> modifier.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The asynchronous method in which <b>await</b> is used must be modified by the <b>async</b> keyword. Such a method, defined by using the <b>async</b> modifier, and usually containing one or more <b>await</b> expressions, is referred to as an async method.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Add <b>async</b> modifier to the async method.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li><b>Await</b> statement method should be <b>async</b>.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Namespace AwaitStatementMethodShouldBeAsync.Test
      Class SomeClass
        <SPAN class=code-selected>' Violates the rule</SPAN>
        Public Function SomeMethod() As Task
          Dim tsk As Task = Task.Run(Function() 
                                     End Function)
          Await tsk
        End Function
      End Class
    End Namespace

<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace AwaitStatementMethodShouldBeAsync.Test
      Class SomeClass
        <SPAN class=code-selected>' FIX: add Async modifier</SPAN>
        Public Async Function SomeMethod() As Task
          Dim tsk As Task = Task.Run(Function() 
                                     End Function)
          Await tsk
        End Function
      End Class
    End Namespace
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace AwaitStatementMethodShouldBeAsync.Test
    {
      class SomeClass
      {
        <SPAN class=code-selected>// Violates the rule</SPAN>
        public Task SomeMethod()
        {
          Task tsk = Task.Run(() => { });
          await tsk;
        }
      }
    }
    
<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace AwaitStatementMethodShouldBeAsync.Test
    {
      class SomeClass
      {
        <SPAN class=code-selected>// FIX: add async modifier</SPAN>
        public async Task SomeMethod()
        {
          Task tsk = Task.Run(() => { });
          await tsk;
        }
      }
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AS00001">
      <Name>Async Method -&gt; Call Start on the Task</Name>
      <Title>Call Start on the Task object before instantiating</Title>
      <ClassName>CallStartOnTaskBeforeInstantiating</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Method</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Async</RuleCategory>
      <RuleModificationDate>2/13/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AS00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/CallStartOnTaskBeforeInstantiating.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Method returns <b>Task</b> which is not started with either:
  <ul>
    <li>Start</li>
    <li>Task.Factory.StartNew</li>
    <li>Task.Run</li>
  </ul>]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[All tasks that are returned from <b>TAP</b> methods must be activated. If a 
  <b>TAP</b> method internally uses a task’s constructor to instantiate the task to be 
  returned, the <b>TAP</b> method must call <b>Start</b> on the <b>Task</b> object before
  returning it. Consumers of a <b>TAP</b> method may safely assume that the returned task
  is active and should not try to call <b>Start</b> on any <b>Task</b> that is returned 
  from a <b>TAP</b> method. Calling <b>Start</b> on an active task results in an <b>
  InvalidOperationException</b> exception.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Call <span class="code-fragment">Start</span> on the <b>Task</b> object before instantiating manually.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Call <b>Start</b> on the <b>Task</b> object before instantiating</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Namespace CallStartOnTaskBeforeInstantiating.Tests
      Class SomeClass
        Public Function SomeMethod() As Task
          <SPAN class=code-selected>' Violates the rule</SPAN>
          Dim task = New Task(Function() 
                              End Function)
          Return task
        End Function
      End Class
    End Namespace

<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace CallStartOnTaskBeforeInstantiating.Tests
      Class SomeClass
        Public Function SomeMethod() As Task
          Dim task = New Task(Function() 
                              End Function)
          <SPAN class=code-selected>' FIX: Call <b>Start</b></SPAN>
          task.Start()
          Return task
        End Function
      End Class
    End Namespace
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace CallStartOnTaskBeforeInstantiating.Tests
    {
      class SomeClass
      {
        public Task SomeMethod()
        {
          <SPAN class=code-selected>// Violates the rule</SPAN>
          var task = new Task(() => {});
          return task;
        }
      }
    }
    
<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace CallStartOnTaskBeforeInstantiating.Tests
    {
      class SomeClass
      {
        public Task SomeMethod()
        {
          var task = new Task(() => {});
          <SPAN class=code-selected>// FIX: Call <b>Start</b></SPAN>
          task.Start();
          return task;
        }
      }
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AS00012">
      <Name>Async Method -&gt; Do not use Task.Wait</Name>
      <Title>Do not use Task.Wait in async method</Title>
      <ClassName>DoNotCallSpecifiedMethodInAsyncMethod</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Async</RuleCategory>
      <RuleModificationDate>3/18/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AS00012</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotCallSpecifiedMethodInAsyncMethod.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>FullTypeNames</Name>
          <Value>System.Threading.Tasks.Task,System.Threading.Tasks.Task`1</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MethodName</Name>
          <Value>Wait</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Specific async method is called.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[API should not lie to the caller. If an API says it is synchronous: it shouldn't be queuing and waiting. If
  it claims <b>async</b>, it should be using async.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>
      Do not call the method of the class in the async method. Remove the call manually.
    </li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not use Task.Wait in async method.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
 Namespace DoNotUseTaskYieldInAsyncMethod.Test
  Public Class SomeClass
    Public Sub SomeMethodAsync()
      <SPAN class=code-selected>' Violates the rule</SPAN>
      Task.WaitAll(Task.Run(Function() Console.ReadLine()))
    End Sub
  End Class
End Namespace

<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace DoNotUseTaskYieldInAsyncMethod.Test
      Public Class SomeClass
        Public Sub SomeMethodAsync()
          <SPAN class=code-selected>' FIX1: add await</SPAN>
          Await Task.Run(Function() Console.ReadLine())
        End Sub

        Public Sub SomeMethod()
          <SPAN class=code-selected>' FIX2: make whole method synchronous</SPAN>
          Console.ReadLine()
        End Sub
      End Class
    End Namespace
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace DoNotUseTaskYieldInAsyncMethod.Test
    {
      public class SomeClass
      {
        public async void SomeMethodAsync()
        {
          <SPAN class=code-selected>// Violates the rule</SPAN>
          Task.WaitAll(Task.Run(() => Console.ReadLine()));
        }
      }
    }

<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace DoNotUseTaskYieldInAsyncMethod.Test
    {
      public class SomeClass
      {
        public async void SomeMethodAsync()
        {
          <SPAN class=code-selected>// FIX1: add await</SPAN>
          await Task.Run(() => Console.ReadLine());
        }

        public void SomeMethod()
        {
          <SPAN class=code-selected>// FIX2: make whole method synchronous</SPAN>
          Console.ReadLine();
        }
      }
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AS00011">
      <Name>Async Method -&gt; Do not use Task.Yield</Name>
      <Title>Do not use Task.Yield in async method</Title>
      <ClassName>DoNotCallSpecifiedAwaitMethodInAsyncMethod</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Async</RuleCategory>
      <RuleModificationDate>3/19/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AS00011</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotCallSpecifiedAwaitMethodInAsyncMethod.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>FullTypeNames</Name>
          <Value>System.Threading.Tasks.Task,System.Threading.Tasks.Task`1</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MethodName</Name>
          <Value>Yield</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Specific async method is called and awaited.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[API should not lie to the caller. If an API says it is synchronous: it shouldn't be queuing and waiting. If
  it claims <b>async</b>, it should be using async.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>
      Do not await the method call of the class in the async method. Remove the call manually.
    </li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not use Task.Yield in async method.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Namespace DoNotCallSpecifiedAwaitMethodInAsyncMethod.Test
      Public Class SomeClass
        Public Sub SomeMethodAsync()
          For i As Integer = 0 To 999
            If i Mod 10 = 0 Then
              ' .. Some code
              Await Task.Yield() <SPAN class=code-selected>' Violates the rule</SPAN>
            End If
          Next
        End Sub
      End Class
    End Namespace

<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace DoNotCallSpecifiedAwaitMethodInAsyncMethod.Test
      Public Class SomeClass
        Public Sub SomeMethod()
          For i As Integer = 0 To 999
            ' .. Some code
          Next
        End Sub
      End Class
    End Namespace
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace DoNotCallSpecifiedAwaitMethodInAsyncMethod.Test
    {
      public class SomeClass
      {
        public async void SomeMethodAsync()
        {
          for (int i = 0; i < 1000; i++)
          {
            // .. Some code
            if (i % 10 == 0)
              await Task.Yield(); <SPAN class=code-selected>// Violates the rule</SPAN>
          }
        }
      }
    }
    
<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace DoNotCallSpecifiedAwaitMethodInAsyncMethod.Test
    {
      public class SomeClass
      {
        public void SomeMethod()
        {
          for (int i = 0; i < 1000; i++)
          {
            // .. Some code
          }
        }
      }
    }
    
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AS00006">
      <Name>Async Method -&gt; Should not be Sub</Name>
      <Title>Do not create async Sub method</Title>
      <ClassName>DontCreateAsyncSubMethod</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Async</RuleCategory>
      <RuleModificationDate>2/13/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AS00006</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DontCreateAsyncSubMethod.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Method with <b>async</b> modifier returns <b>void</b>]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Don't create "Async Sub" methods (as known as void-returning asyncs) except for top-level event handlers.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>
     Specify <b>Task</b> or <b>Task&lt;T&gt;</b> return type for the method.
    </li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not create async Sub method</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Namespace DontCreateAsyncSubMethods.Test
      Public Class SomeClass
        <SPAN class=code-selected>' Violates the rule</SPAN>
        Public Sub SomeMethodAsync()
          ' .. Some code
          Await IoBoundOperation()
        End Sub
      End Class
    End Namespace
 
<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace DontCreateAsyncSubMethods.Test
      Public Class SomeClass
        <SPAN class=code-selected>' FIX: Change <b>sub</b> to <b>Task</b> returning function</SPAN>
        Public Function SomeMethodAsync() As Task
          ' .. Some code
          Await IoBoundOperation()
        End Function
      End Class
    End Namespace
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace DontCreateAsyncSubMethods.Test
    {
      public class SomeClass
      {
        <SPAN class=code-selected>// Violates the rule</SPAN>
        public async void SomeMethodAsync()
        {
          // .. Some code
          await IoBoundOperation();
        }
      }
    }

<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace DontCreateAsyncSubMethods.Test
    {
      public class SomeClass
      {
        <SPAN class=code-selected>// FIX: Change <b>void</b> to <b>Task</b></SPAN>
        public async Task SomeMethodAsync()
        {
          // .. Some code
          await IoBoundOperation();
        }
      }
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AS00005">
      <Name>Async Method -&gt; Parameters should be the same to synchronous counterpart</Name>
      <Title>TAP method parameters should be the same</Title>
      <ClassName>TapMethodParametersShouldBeTheSame</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Method</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Async</RuleCategory>
      <RuleModificationDate>2/13/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AS00005</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/TapMethodParametersShouldBeTheSame.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Counterpart asynchronous method has different parameters set than the synchronous one.
  <br/><br/>- OR -<br/><br/>
  Counterpart asynchronous method parameters order is defferent then the synchronous one.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The parameters to a basic <b>TAP</b> method should be the same parameters provided to the synchronous counterpart, in the same order. However, <b>out</b> and <b>ref</b> parameters are exempted from this rule and should be avoided entirely. Any data that would have been returned through an out or ref parameter should instead be returned as part of the returned <b>Task&lt;TResult&gt;</b>'s Result, utilizing a tuple or a custom data structure in order to accommodate multiple values.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>
      Specify the same parameters for the method as for its synchronous counterpart manually.
    </li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>TAP method parameters should be the same</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Namespace TapMethodParametersShouldBeSame.Tests
      Public Class SomeClassDifferentNames
        Public Sub SomeMethod(a As Integer, b As Double)
        End Sub

        <SPAN class=code-selected>' Violates the rule - <b>names</b> must be the same</SPAN>
        Public Function SomeMethodAsync(a As Integer, c As Double) As Task
        End Function

        <SPAN class=code-selected>' Violates the rule - <b>types</b> must be the same</SPAN>
        Public Function SomeMethodAsync(a As Double, b As Double) As Task
        End Function

        <SPAN class=code-selected>' Violates the rule - <b>order</b> must be the same</SPAN>
        Public Function SomeMethodAsync(b As Double, a As Integer) As Task
        End Function
      End Class
    End Namespace
 
<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace TapMethodParametersShouldBeSame.Tests
      Public Class SomeClassDifferentNames
        Public Sub SomeMethod(a As Integer, b As Double)
        End Sub

        <SPAN class=code-selected>' FIX: types, names and order are the same</SPAN>
        Public Function SomeMethodAsync(a As Integer, b As Double) As Task
        End Function
      End Class
    End Namespace
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace TapMethodParametersShouldBeSame.Tests
    {
      public class SomeClassDifferentNames
      {
        public void SomeMethod(int a, double b)
        {
        }

        <SPAN class=code-selected>// Violates the rule - <b>names</b> must be the same</SPAN>
        public async Task SomeMethodAsync(int a, double c)
        {
        }
        
        <SPAN class=code-selected>// Violates the rule - <b>types</b> must be the same</SPAN>
        public async Task SomeMethodAsync(double a, double b)
        {
        }

        <SPAN class=code-selected>// Violates the rule - <b>order</b> must be the same</SPAN>
        public async Task SomeMethodAsync(double b, int a)
        {
        }
      }
    }
<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace TapMethodParametersShouldBeSame.Tests
    {
      public class SomeClassDifferentNames
      {
        public void SomeMethod(int a, double b)
        {
        }

        <SPAN class=code-selected>// FIX: types, names and order are the same</SPAN>
        public async Task SomeMethodAsync(int a, double b)
        {
        }
      }
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="AS00008">
      <Name>Async Method -&gt; Transform to non-async if simple</Name>
      <Title>Transform simple async method to non-async</Title>
      <ClassName>TransformSimpleAsyncMethodToNonAsync</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Async;Performance</RuleCategory>
      <RuleModificationDate>2/13/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=AS00008</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/TransformSimpleAsyncMethodToNonAsync.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Return <b>await</b> is the only awaited <b>async</b> method call in the method.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[If an async method contains only one <b>await</b> operator, and 
  it's in the form <b>return await &lt;expr&gt;</b>, then you should just <b>return &lt;expr&gt;</b>
  and make your method non-async.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>
      Return &lt;expr&gt; and make your method non-async manually.
    </li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Transform simple async methods to non-async</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
  Namespace TransformSimpleAsyncMethodsToNonAsync.Test
    Public Class SomeClass
      Public Function SomeMethod() As Task(Of Integer)
        <SPAN class=code-selected>' Violates the rule</SPAN> 
        Return Await IoBoundOperationAsync()
      End Function

      Public Function IoBoundOperationAsync() As Task(Of Integer)
        Return Task(Of Integer).Factory.StartNew(Function() 42)
      End Function
    End Class
  End Namespace

<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace TransformSimpleAsyncMethodsToNonAsync.Test
      Public Class SomeClass
        <SPAN class=code-selected>' FIX: Convert to synchronous method</SPAN> 
        Public Function SomeMethod() As Task(Of Integer)
          Return IoBoundOperationAsync()
        End Function

        Public Function IoBoundOperationAsync() As Task(Of Integer)
          Return Task(Of Integer).Factory.StartNew(Function() 42)
        End Function
      End Class
    End Namespace

  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace TransformSimpleAsyncMethodsToNonAsync.Test
    {
      public class SomeClass
      {
        public async Task<int> SomeMethod()
        {
          <SPAN class=code-selected>// Violates the rule</SPAN> 
          return await IoBoundOperationAsync();
        }

        public Task<int> IoBoundOperationAsync()
        {
          return Task<int>.Factory.StartNew(() => 42);
        }
      }
    }

<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace TransformSimpleAsyncMethodsToNonAsync.Test
    {
      public class SomeClass
      {
        <SPAN class=code-selected>// FIX: Convert to synchronous method</SPAN> 
        public Task<int> SomeMethod()
        {
          return IoBoundOperationAsync();
        }

        public Task<int> IoBoundOperationAsync()
        {
          return Task<int>.Factory.StartNew(() => 42);
        }
      }
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="CS00002">
      <Name>Method -&gt; Avoid single line If statement</Name>
      <Title>Avoid single line If statement</Title>
      <ClassName>AvoidSingleLineIfStatement</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Information</Severity>
      <Targets>Statement</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>CodingStyle</RuleCategory>
      <RuleModificationDate>12/16/2009</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=CS00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidSingleLineIfStatement.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Method should not contain single-statement <b><i>If</i></b> block.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, it is recommended to avoid single-line <b><i>If</i></b> statements.<br />
  <br />
  <b><i>If</i></b> statement should be always closed with an <b><i>End If</i></b> keyword 
  (for C#, curly braces should be used for <b><i>if</i></b> blocks that contain single line). 
  By doing so, it is easier to add comments and other statements later in the development and debugging process.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<LI>Split <b><i>If</i></b> block into a multiline statement.</LI>
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid single line If statement.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

	' Violates the rule
	If x > 0 Then y = 0

<SPAN class="code-selected">' This is the correct implementation</SPAN>

	If x > 0 Then
	  y = 0
	End If
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

	// Violates the rule
	if (x > 0) y = 0;

<SPAN class="code-selected">// This is the correct implementation</SPAN>

	if (x > 0)
	{
	  y = 0;
	}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="CS00001">
      <Name>Method -&gt; Do not include multiple statements on a single line</Name>
      <Title>Do not include multiple statements on a single line</Title>
      <ClassName>DoNotIncludeMultipleStatementsOnSingleLine</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Information</Severity>
      <Targets>Statement</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>CodingStyle</RuleCategory>
      <RuleModificationDate>12/16/2009</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=CS00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotIncludeMultipleStatementsOnSingleLine.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Method should not contain multiple statements on a single line.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, it is not recommended to include multiple statements on a single line.<br />
  <br />
  Lines containing single statements make the code more readable and enable you to add a comment for each individual statement.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<LI>Split statements into multiple lines.</LI>
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not include multiple statements on a single line.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

	' Violates the rule
	x = 1 : y = 2

<SPAN class="code-selected">' This is the correct implementation</SPAN>

	x = 1 ' separate comment for the statement
	y = 2 ' separate comment for the statement
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

	// Violates the rule
	x = 1; y = 2;

<SPAN class="code-selected">// This is the correct implementation</SPAN>

	x = 1; // separate comment for the statement
	y = 2; // separate comment for the statement

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00001">
      <Name>Abstract Class -&gt; Should Not Have Constructors</Name>
      <Title>Abstract types should not have public constructors</Title>
      <ClassName>AbstractTypesShouldNotHaveConstructors</ClassName>
      <Scope>Abstract</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1012:AbstractTypesShouldNotHaveConstructors</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AbstractTypesShouldNotHaveConstructors.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[An abstract public class has a public constructor.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, an abstract class (<b>MustInherit</b> in Visual Basic)
	must have a constructor with protected scope.<br />
	<br />
	The constructor in an abstract class is meant to be called by derived types only.
	Therefore, it should have protected visibility.<br />
	<br />
	You must add an explicit protected constructor in an abstract class to keep the Visual Basic compiler
	from mistakenly creating a parameterless public constructor.<br />
	<br />
	<i>This rule is similar to <b>FxCop</b> rule 'Abstract types should not have constructors', CheckId <b>CA1012</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Search for constructor(s) and change one(s) modifier.</li>
    <li>Remove modifier for the type.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Abstract types should not have public constructors.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as the correct implementation.
	<br />
	<p>[Visual Basic]</p>
	<pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System

Namespace SampleClasses

  ' Violates the rule: the compiler creates a default public constructor
  Public MustInherit Class Sample1Base
  
    ...

  End Class


  ' Violates the rule
  Public MustInherit Class Sample2Base
  
    Public Sub New()
    End Sub
    
    ...

  End Class
      

End Namespace 


<SPAN class=code-selected>' This is the correct implementation</SPAN>
Imports System

Namespace SampleClasses

  ' Explicit protected constructor added
  Public MustInherit Class Sample1Base

    <SPAN class=code-changed>Protected Sub New()
    End Sub</SPAN>
  
    ...

  End Class


  ' Constructor is protected
  Public MustInherit Class Sample2Base
  
    <SPAN class=code-changed>Protected</SPAN> Sub New()
    End Sub
    
    ...

  End Class
      

End Namespace 
	</pre>
	<p>[C#]</p>
	<pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;

namespace SampleClasses
{

  // Violates the rule: the compiler creates a default public constructor
  public abstract class Sample1Base
  {
  
    ...

  }


  // Violates the rule
  public abstract class Sample2Base
  {
  
    public Sample2Base()
    {
    }
    
    ...

  }
      
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>
using System;

namespace SampleClasses
{

  // Explicit protected constructor added
  public abstract class Sample1Base
  {

    <SPAN class=code-changed>protected Sample1Base()
    {
    }</SPAN>
  
    ...

  }


  // Constructor is protected
  public abstract class Sample2Base
  {
  
    <SPAN class=code-changed>protected</SPAN> Sample2Base()
    {
    }
    
    ...

  }

}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00016">
      <Name>Assembly -&gt; Should have strong names</Name>
      <Title>Assemblies should have strong names</Title>
      <ClassName>AssembliesShouldHaveValidStrongNames</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Project</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>1/18/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA2210:AssembliesShouldHaveValidStrongNames</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00016</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AssembliesShouldHaveValidStrongNames.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[An assembly is not signed with a strong name.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, assembly should always be signed with a strong name. 
  This rule applies to both DLL and EXE executables.<br />
  <br />
  This rule offers several long-term advantages:
  <ul>
  <li>you can register the assembly in the global assembly cache (GAC);</li>
  <li>the .NET runtime can detect whether the assembly has been tampered with;</li>
  <li>assemblies called by your assembly can check the caller's identity.</li>
  </ul>
  Finally, if you use the assembly in a Smart Client application, a strong name enables the 
  administrator of the client computer to relax Code Access Security (CAS) policy for only that 
  specific assembly (or for all assemblies from your company).<br />
	<br />
	<i>This rule is similar to <b>FxCop</b> rule 'Assemblies should have valid strong names', CheckId <b>CA2210</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Create .snk key file and sign assembly with a strong name using 
    <b>System.Reflection.AssemblyKeyFileAttribute</b> attribute.
    <LI>Use existing .snk key file for signing assembly with a strong name using 
    <b>System.Reflection.AssemblyKeyFileAttribute</b> attribute.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Assemblies should have valid strong names.</li>
  </ul>
  <br />
  <p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="DE00017">
      <Name>Abstract Class -&gt; Should have at least one derived class</Name>
      <Title>Abstract class should have at least one derived class</Title>
      <ClassName>AbstractClassShouldHaveAtLeastOneDerivedClass</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00017</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AbstractClassShouldHaveAtLeastOneDerivedClass.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[An abstract class should have at least one derived class.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Provide at least one concrete type that inherits from each abstract class that you ship.<br />
	<br />
	Doing this helps to validate the design of the abstract class. For example, 
	<b>System.IO.FileStream</b> is an implementation of the <b>System.IO.Stream</b> abstract class.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Comment out an abstract class.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Abstract class should have at least one derived class.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="DE00020">
      <Name>Interface methods -&gt; Should be callable by child types</Name>
      <Title>Interface methods should be callable by child types</Title>
      <ClassName>InterfaceMethodsShouldBeCallableByChildTypes</ClassName>
      <Scope>Private</Scope>
      <Severity>Warning</Severity>
      <Targets>Method, Property</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1033:InterfaceMethodsShouldBeCallableByChildTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00020</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/InterfaceMethodsShouldBeCallableByChildTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[An unsealed public type implements explicitly a method of a public interface 
	and does not provide an alternative access to the base implementation of the method.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[If a base type, which is not sealed and externally visible, explicitly implements an interface with 
  nonpublic members, ensure that derived types can access and override these members.<br />
    <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not override operator equals on reference types', CheckId <b>CA1033</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<li>Mark a type as <b>NotInheritable</b> (<b>sealed</b> in C#)</li> 
				<li>Change method modifier to <b>Protected Overridable</b> (Visual Basic only)</li> 
				<li>Add a new method which is visible to derived types (C# only)</li> 
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Interface methods should be callable by child types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

Public Class TestClass
  Implements IComparable

  ' Violates the rule
  Private Function CompareTo(ByVal obj As Object) As Integer _
    Implements System.IComparable.CompareTo
    
    ' ...

  End Function

End Class

<SPAN class="code-selected">' This is the correct implementation</SPAN>

Public Class TestClass
  Implements IComparable

  <span class=code-changed>Protected Overridable</span> Function CompareTo(ByVal obj As Object) As Integer _
    Implements System.IComparable.CompareTo
    
    ' ...

  End Function

End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

public class TestClass: IComparable
{

  // Violates the rule
  int IComparable.CompareTo(object obj)
  {
    // Actual comparison
    return 0;
  }
}

<SPAN class="code-selected">// This is the correct implementation</SPAN>

public class TestClass: IComparable
{
  int IComparable.CompareTo(object obj)
  {

    <span class=code-changed>return CompareTo(obj);</span>
	
  }

  <span class=code-changed>protected virtual int CompareTo(object obj)
  {
    // Actual comparison
    return 0;
  }</span>

}
	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00019">
      <Name>Project -&gt; Should have AssemblyInfo file</Name>
      <Title>Project should have AssemblyInfo file</Title>
      <ClassName>ProjectShouldHaveAssemblyInfoFile</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>2/10/2010</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00019</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ProjectShouldHaveAssemblyInfoFile.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Project does not contain AssemblyInfo file.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[AssemblyInfo.vb (AssemblyInfo.cs in C#) file is created automatically when you create an application with Microsoft Visual Studio.
	AssemblyInfo file should contain all assembly-level attributes such as assembly identity attributes, informational attributes,
  assembly manifest attributes, and strong name attributes.<br />
	<br />
	The rule was specially created to ensure that project contains AssemblyInfo file.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Add AssemblyInfo file to project.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Project should have AssemblyInfo file.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="DE00021">
      <Name>Assembly-level attribute -&gt; Do not place outside of AssemblyInfo file</Name>
      <Title>Do not place assembly-level attributes outside of AssemblyInfo file</Title>
      <ClassName>DoNotPlaceAssemblyAttributesOutsideOfAssemblyInfoFile</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>6/22/2011</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00021</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotPlaceAssemblyAttributesOutsideOfAssemblyInfoFile.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Assembly-level attribute is placed outside of AssemblyInfo file.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[AssemblyInfo.vb (AssemblyInfo.cs in C#) file is created automatically when you create an application with Microsoft Visual Studio.
	AssemblyInfo file should contain all assembly-level attributes such as assembly identity attributes, informational attributes,
  assembly manifest attributes, and strong name attributes.<br />
	<br />
	The rule was specially created to ensure that all assembly-level attributes are placed in the AssemblyInfo file.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Move assembly-level attribute to the AssemblyInfo file.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not place assembly attributes outside of AssemblyInfo file.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="DE00018">
      <Name>Interface -&gt; Should have implementation</Name>
      <Title>Interface should have implementation</Title>
      <ClassName>InterfaceShouldHaveImplementation</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Interface</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>9/25/2009</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00018</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/InterfaceShouldHaveImplementation.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Interface should have an implementation.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Provide at least one type that is an implementation of an interface.<br />
	<br />
	Doing this helps to validate the design of the interface. For example, 
	<b>System.Collections.Generic.List&lt;T&gt;</b> is an implementation of the 
	<b>System.Collections.Generic.IList&lt;T&gt;</b> interface.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Comment out an interface.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Interface should have an implementation.</li>
  </ul>
	<p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="DE00014">
      <Name>Public/Protected Instance Field -&gt; Do not declare</Name>
      <Title>Do not declare externally visible instance fields</Title>
      <ClassName>DoNotDeclareExternallyVisibleInstanceFields</ClassName>
      <Scope>Public, Protected</Scope>
      <Severity>Warning</Severity>
      <Targets>Field</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1051:DoNotDeclareVisibleInstanceFields</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotDeclareExternallyVisibleInstanceFields.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[An externally visible instance field declared in the public class.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, public instance fields should 
  neve be defined. Private fields wrapped inside public properties should be used 
  instead. Such approach will allow to validate the incoming value before it's 
  assigned to the private field. Even if the validation of the value in the current class do not required,
  using a property enables inheritors to apply more restrictive validation criteria. Fields do not enable
  values validation.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not declare visible instance fields', CheckId <b>CA1051</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Change field modifier. 
    <LI>Create property from the field and set its modifier. 
    <LI>Create property from the field with name and modifier specified. 
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not declare externally visible instance fields.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System.Drawing

Public Class Sample
    
  Public BackColor As Color
  
  ...

End Class 


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System.Drawing

Public Class Sample

  Private m_BackColor As Color
    
  Public Property BackColor() As Color
    Get
        Return m_BackColor
    End Get
    Set (ByVal Value As Color)
      If Value = Color.Black Then
        Throw New ArgumentException("Invalid color value.")
      End If
      m_BackColor = Value
    End Set
  End Property

End Class 
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System.Drawing;

public class Sample
{
    
  public Color BackColor;
  
  ...

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System.Drawing;

public class Sample
{

  private Color m_BackColor;
    
  public Color BackColor
  {
    get
    {
        return m_BackColor;
    }
    
    set
    {
      if (value == Color.Black)
      {
        throw new ArgumentException("Invalid color value.");
      }
      m_BackColor = value;
    }
  }

}
	
	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00002">
      <Name>Sealed Class -&gt; Do not declare protected members</Name>
      <Title>Do not declare protected members in sealed types</Title>
      <ClassName>DoNotDeclareProtectedMembersInSealedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Error</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1047:DoNotDeclareProtectedMembersInSealedTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotDeclareProtectedMembersInSealedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A <b>sealed</b> (<b>NotInheritable</b> in Visual basic) public type declares a protected member.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, a field, a property or a method should
  not be made public if that is not necessary.<br />
  <br />
  Inheriting class can access or override protected member of the base class.
  A class marked as <b>sealed</b> (<b>NotInheritable</b> in Visual basic) cannot be used as a base class
  i.e. it cannot be inherited. So protected methods on sealed types cannot be called.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not declare protected members in sealed types', CheckId <b>CA1047</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Change type to inheritable.</LI>
    <LI>Change the member(s) access level to specified.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not declare protected members in sealed types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System

Public NotInheritable Class Sample
    
    ' Violates the rule
    Protected Sub SomeMethod()
    
      ...
      
    End Sub
   
End Class 


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System

Public NotInheritable Class Sample
    
    <SPAN class=code-changed>Public</SPAN> Sub SomeMethod()
    
      ...
      
    End Sub
   
End Class 

- Or -

Imports System

<SPAN class=code-changed>' <b>NotInheritable</b> modifier has been removed</SPAN>
Public Class Sample
    
    Protected Sub SomeMethod()
    
      ...
      
    End Sub
   
End Class 
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;

public sealed class Sample
{
    
    // Violates the rule
    protected void SomeMethod()
    {
    
      ...
      
    }
   
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;

public sealed class Sample
{
    
    <SPAN class=code-changed>public</SPAN> void SomeMethod()
    {
    
      ...
      
    }
   
}

- Or -

Imports System

<SPAN class=code-changed>// <b>sealed</b> modifier has been removed</SPAN>
public class Sample
{
    
    protected void SomeMethod()
    {
    
      ...
      
    }
   
}
	
	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00015">
      <Name>Method -&gt; Do not hide base class methods</Name>
      <Title>Do not hide base class methods</Title>
      <ClassName>DoNotHideBaseClassMethods</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>1/19/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1061:DoNotHideBaseClassMethods</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00015</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotHideBaseClassMethods.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Type declares method with the same name and with the same number of parameters 
  as one of its base methods.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[A method in a derived type hides an identically named method in a base type, 
  when derived method has the same number of parameters and type of one of parameters 
  is a base type of the corresponding parameter in the base method.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not hide base class methods', CheckId <b>CA1061</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Rename the method and its references to the specified name.
    <LI>Comment out the implementation of the method.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not hide base class methods.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' Base class that will be inherited</SPAN>

Imports System

Public Class BaseType
    
    Public Sub SomeMethod(ByVal Param1 As Integer, ByVal Param2 As String, ByVal Param3 As String)
    
      ...
      
    End Sub
   
End Class 


<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

Imports System

Public Class DerivedType
    Inherits BaseType
    
    ' The following method implementation hides base type method
    Public Sub SomeMethod(ByVal Param1 As Integer, ByVal Param2 As String, ByVal Param3 As Object)
    
      ...
      
    End Sub
   
End Class 


<SPAN class="code-selected">' This is the correct implementation</SPAN>

Imports System

Public Class DerivedType
    Inherits BaseType
    
    ' The method renamed and does not hide base type method
    Public Sub <SPAN class="code-changed">RenamedMethod</SPAN>(ByVal Param1 As Integer, ByVal Param2 As String, ByVal Param3 As Object)
    
      ...
      
    End Sub
   
End Class 

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// Base class that will be inherited</SPAN>

using System;

public class BaseType
{
    
    public void SomeMethod(int param1, string param2, string param3)
    {
    
      ...
      
    }
   
}


<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

using System;

public class DerivedType : BaseType
{
    
    // The following method implementation hides base type method
    public void SomeMethod(int param1, string param2, object param3)
    {
    
      ...
      
    }
   
}


<SPAN class="code-selected">// This is the correct implementation</SPAN>

using System;

public class DerivedType : BaseType
{
    
    // The method renamed and does not hide base type method
    public void <SPAN class="code-changed">RenamedMethod</SPAN>(int param1, string param2, object param3)
    {
    
      ...
      
    }
   
}

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00003">
      <Name>Public Class -&gt; Do not override operator equals</Name>
      <Title>Do not override operator equals on reference types</Title>
      <ClassName>DoNotOverrideOperatorEqualsOnReferenceTypes</ClassName>
      <Scope>Public</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>3/13/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1046:DoNotOverrideOperatorEqualsOnReferenceTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotOverrideOperatorEqualsOnReferenceTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A public or nested public reference type overloads the equality operator or
  <b>System.Object.Equals</b> method.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Two references are equal only if they point to the same object. The default implementation
  of the equality operator is almost always correct for reference types.<br />
  <br />
  If the reference type behaves like a built-in value type, then this rule can be excluded
  from the analysis.<br />
    <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not override operator equals on reference types', CheckId <b>CA1046</b></i><br />
  <br /]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Comment out the implementation of the <b>System.Object.Equals</b> method.
    <LI>Comment out the implementation of the equality operator.
    <LI>Comment out the implementation of the <b>System.Object.Equals</b> method and the implementation of the equality operator.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not override operator equals on reference types.</li>
  </ul>
  <p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="DE00004">
      <Name>Enumeration -&gt; Underlying Type Should Be Int32</Name>
      <Title>Enum underlying type should be Int32 or one of the CLS-compliant integral types.</Title>
      <ClassName>EnumStorageShouldBeInt32</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Enumeration</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>5/10/2007</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1028:EnumStorageShouldBeInt32</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00004</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/EnumStorageShouldBeInt32.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The underlying type of a public enumeration is not <b>System.Int32</b> or one
  of the CLS-compliant integral types.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, <b>System.Int32</b> should be used as a base type
  for the enumeration type.<br />
  <br />
  For some specific reasons it may be necessary to use a nondefault base type.
  One of the CLS-compliant integral types, <B>System.Byte</B>, <B>System.Int16</B>, 
  <B>System.Int32</B>, or <B>System.Int64</B>, should be used in that case. A non-CLS-compliant
  integral types such as <B>System.UInt32</B>, or <B>System.UInt64</B> should never be used.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Enum Storage should be Int32', CheckId <b>CA1028</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Change the enumeration member type to <b>System.Int32</b>.
    <LI>Change the enumeration member type to <b>System.Int64</b>. 
    <LI>Change the enumeration member type to <b>System.Int16</b>. 
    <LI>Change the enumeration member type to <b>System.Byte</b>. 
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Enum underlying type should be Int32 or one of the CLS-compliant integral types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

    ' Violation: non-CLS-compliant integral type is used
    Public Enum Answer As SByte
      No = 0
      Yes = 1
      Unknown = 3
    End Enum

<SPAN class=code-selected>' This is the correct implementation</SPAN>

    Public Enum Answer <SPAN class=code-changed>As Integer</SPAN>
      No = 0
      Yes = 1
      Unknown = 3
    End Enum

- Or -

    <SPAN class=code-changed>' <b>System.Int32</b> used by default</SPAN>
    Public Enum Answer
      No = 0
      Yes = 1
      Unknown = 3
    End Enum
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

    // Violation: non-CLS-compliant integral type is used
    public enum Answer : sbyte
    {
      No = 0,
      Yes = 1,
      Unknown = 3
    }

<SPAN class=code-selected>// This is the correct implementation</SPAN>

    public enum Answer : <SPAN class=code-changed>int</SPAN>
    {
      No = 0,
      Yes = 1,
      Unknown = 3
    }

- Or -

    <SPAN class=code-changed>// <b>System.Int32</b> used by default</SPAN>
    public enum Answer
    {
      No = 0,
      Yes = 1,
      Unknown = 3
    }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00005">
      <Name>Finalize -&gt; Type -&gt; Implement Finalizer Correctly</Name>
      <Title>Implement Finalizer Correctly</Title>
      <ClassName>ImplementFinalizerCorrectly</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>3/13/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1063:ImplementIDisposableCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00005</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ImplementFinalizerCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[<b>Finalize</b> method is not implemented correctly. Some reasons for this 
  problem are listed below:
  <ul>
    <li>
      Type derives from a type that implements the <b>System.IDisposable</b> interface 
      and overrides a finalizer.</li>
    <li>
      Type implements the <b>System.IDisposable</b> interface and has incorrect a 
      destructor implementation.</li>
    <li>
      Type implements the <b>System.IDisposable</b> interface and has incorrect a 
      finalizer implementation.</li>
  </ul>]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, types exposing both the <b>Finalize</b>
  method and the <b>System.IDisposable</b> interface must adopt the recommended 
  Dispose-Finalize pattern.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Implement IDisposable Correctly', CheckId <b>CA1063</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Comment out destructor (finalizer) of the type, override (if needed) <b>System.IDisposable.Dispose</b>(<b>Boolean</b>)
      method and put the finalization snippet in the code path where
      <span class="code-fragment">disposing</span> is <b>False</b>.
    <LI>Find destructor and modify it so that it calls 
      <span class="code-fragment">Dispose(False)</span> and then returns.
    <LI>Find finalizer and modify it so that it calls 
      <span class="code-fragment">Dispose(False)</span>, calls base finalizer and then returns.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>
      Implement Finalizer Correctly.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[<br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' The following code shows Dispose-Finalize design pattern for a base class:</SPAN>

Public Class DisposableType
  Implements IDisposable

  ' Keep track of when the object is disposed.
  Protected disposed As Boolean = False

  ' This method disposes the base object's resources.
  Protected Overridable Sub Dispose(ByVal disposing As Boolean)
		SyncLock Me
      If Not Me.disposed Then
        If disposing Then
          ' Release disposable objects used by this instance here.
        
          ...
        
        End If
        ' Release unmanaged resources here.
      
        ...
      
        Me.disposed = True
      End If
    End SyncLock
  End Sub

  Public Sub Dispose() Implements IDisposable.Dispose
    Dispose(True)
    
    ' Unregister object for finalization
    GC.SuppressFinalize(Me)
  End Sub
  
  Protected Overrides Sub Finalize()
    Try
      Dispose(False)
    Catch
      ' Deal with errors or just ignore them
    Finally
      ' Invoke the base object's Finalize method
      MyBase.Finalize()
    End Try
  End Sub
  
End Class

<SPAN class=code-selected>' The following code shows Dispose-Finalize design pattern for derived class:</SPAN>

Public Class DerivedDisposableType
  Inherits DisposableType

  ' This method disposes the derived object's resources.
  Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)
		SyncLock Me
      If Not Me.disposed Then
        If disposing Then
          ' Release disposable objects used by this instance here.
        
          ...
        
        End If
        ' Release unmanaged resources here.
      
        ...

        ' Call the base object's Dispose protected method.
        MyBase.Dispose(disposing)
      
      End If
    End SyncLock
  End Sub

  ' The derived class does not have a Finalize method
  ' or a Dispose method with parameters because it inherits
  ' them from the base class.
End Class

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// The following code shows Dispose-Finalize design pattern for a base class:</SPAN>

public class DisposableType: IDisposable
{

  // Keep track of when the object is disposed.
  protected bool disposed = false;

  // This method disposes the base object's resources.
  protected virtual void Dispose(bool disposing)
  {
		lock(this)
		{
      if (!this.disposed)
      {
        if (disposing)
        {
          // Release disposable objects used by this instance here.
        
          ...
        
        }
        // Release unmanaged resources here.
      
        ...
      
        this.disposed = true;
      }
    }
  }

  public void Dispose()
  {
    Dispose(true);
    
    // Unregister object for finalization
    GC.SuppressFinalize(this);
  }
  
  ~DisposableType()
  {
    Dispose(false);
  }
  
}

<SPAN class=code-selected>// The following code shows Dispose-Finalize design pattern for derived class:</SPAN>

public class DerivedDisposableType: DisposableType
{

  // This method disposes the derived object's resources.
  protected override void Dispose(bool disposing)
  {
    lock(this)
    {
      if (!this.disposed)
      {
        if (disposing)
        {
          // Release disposable objects used by this instance here.
        
          ...
        
        }
        // Release unmanaged resources here.
      
        ...

        // Call the base object's Dispose protected method.
        base.Dispose(disposing);
      
      }
    }
    
  }

  // The derived class does not have a Finalize method
  // or a Dispose method with parameters because it inherits
  // them from the base class.
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00006">
      <Name>Dispose -&gt; Type -&gt; Implement IDisposable correctly</Name>
      <Title>Implement IDisposable Correctly</Title>
      <ClassName>ImplementIDisposableCorrectly</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1063:ImplementIDisposableCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00006</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ImplementIDisposableCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The <b>System.IDisposable</b> interface is not implemented correctly. Some reasons for this 
  problem are listed below:
  <ul>
    <li>Type derives from type that implements the <b>System.IDisposable</b> interface 
	    and implements <b>System.IDisposable</b> interface repeatedly.</li>
    <li>Type implements <b>System.IDisposable</b> interface and has
	    <span class="code-fragment">Dispose()</span> method with non <b>Public</b> modifier.</li>
    <li>Type derives from type that implements the <b>System.IDisposable</b> 
	    and overrides <span class="code-fragment">Dispose()</span> method.</li>
	  <li>Type implements the <b>System.IDisposable</b> interface and
	    has incorrect <span class="code-fragment">Dispose()</span> method implementation.
	  <li>Type implements the <b>System.IDisposable</b> interface and
	    has <span class="code-fragment">Dispose(Boolean)</span> method with incorrect modifiers.</li>
  </ul>]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, types exposing both the <b>Finalize</b>
  method and the <b>System.IDisposable</b> interface must adopt the recommended 
  Dispose-Finalize pattern.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Implement IDisposable Correctly', CheckId <b>CA1063</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Remove <b>System.IDisposable</b> interface from the list of interfaces implemented by 
      the type and add (if needed) overridden base class <span class="code-fragment">Dispose</span> implementation (<b>System.IDisposable.Dispose</b>(<b>Boolean</b>)).
    <LI>Find <span class="code-fragment">Dispose()</span> method and change its modifier to <b>Public</b>
    <LI>Remove overridden <span class="code-fragment">Dispose()</span> method, 
      add (if needed) overridden <span class="code-fragment">Dispose(Boolean)</span> method and 
      put the dispose snippet in the code path where <span class="code-fragment">disposing</span> is <b>True</b>.
    <LI>Modify <span class="code-fragment">Dispose()</span> method so that it calls 
	    <span class="code-fragment">Dispose(True)</span>, then calls 
	    <span class="code-fragment">GC.SuppressFinalize()</span> 
	    on the current object instance, and then returns.
    <LI>Find <span class="code-fragment">Dispose(Boolean)</span> method and change its modifier.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Implement IDisposable Correctly.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[<br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' The following code shows Dispose-Finalize design pattern for a base class:</SPAN>

Public Class DisposableType
  Implements IDisposable

  ' Keep track of when the object is disposed.
  Protected disposed As Boolean = False

  ' This method disposes the base object's resources.
  Protected Overridable Sub Dispose(ByVal disposing As Boolean)
		SyncLock Me
      If Not Me.disposed Then
        If disposing Then
          ' Release disposable objects used by this instance here.
        
          ...
        
        End If
        ' Release unmanaged resources here.
      
        ...
      
        Me.disposed = True
      End If
    End SyncLock
  End Sub

  Public Sub Dispose() Implements IDisposable.Dispose
    Dispose(True)
    
    ' Unregister object for finalization
    GC.SuppressFinalize(Me)
  End Sub
  
  Protected Overrides Sub Finalize()
    Try
      Dispose(False)
    Catch
      ' Deal with errors or just ignore them
    Finally
      ' Invoke the base object's Finalize method
      MyBase.Finalize()
    End Try
  End Sub
  
End Class

<SPAN class=code-selected>' The following code shows Dispose-Finalize design pattern for derived class:</SPAN>

Public Class DerivedDisposableType
  Inherits DisposableType

  ' This method disposes the derived object's resources.
  Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)
		SyncLock Me
      If Not Me.disposed Then
        If disposing Then
          ' Release disposable objects used by this instance here.
        
          ...
        
        End If
        ' Release unmanaged resources here.
      
        ...

        ' Call the base object's Dispose protected method.
        MyBase.Dispose(disposing)
      
      End If
    End SyncLock
  End Sub

  ' The derived class does not have a Finalize method
  ' or a Dispose method with parameters because it inherits
  ' them from the base class.
End Class

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// The following code shows Dispose-Finalize design pattern for a base class:</SPAN>

public class DisposableType: IDisposable
{

  // Keep track of when the object is disposed.
  protected bool disposed = false;

  // This method disposes the base object's resources.
  protected virtual void Dispose(bool disposing)
  {
		lock(this)
		{
      if (!this.disposed)
      {
        if (disposing)
        {
          // Release disposable objects used by this instance here.
        
          ...
        
        }
        // Release unmanaged resources here.
      
        ...
      
        this.disposed = true;
      }
    }
  }

  public void Dispose()
  {
    Dispose(true);
    
    // Unregister object for finalization
    GC.SuppressFinalize(this);
  }
  
  ~DisposableType()
  {
    Dispose(false);
  }
  
}

<SPAN class=code-selected>// The following code shows Dispose-Finalize design pattern for derived class:</SPAN>

public class DerivedDisposableType: DisposableType
{

  // This method disposes the derived object's resources.
  protected override void Dispose(bool disposing)
  {
    lock(this)
    {
      if (!this.disposed)
      {
        if (disposing)
        {
          // Release disposable objects used by this instance here.
        
          ...
        
        }
        // Release unmanaged resources here.
      
        ...

        // Call the base object's Dispose protected method.
        base.Dispose(disposing);
      
      }
    }
    
  }

  // The derived class does not have a Finalize method
  // or a Dispose method with parameters because it inherits
  // them from the base class.
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00007">
      <Name>Assembly -&gt; Should have assembly version</Name>
      <Title>Mark assemblies with assembly version</Title>
      <ClassName>MarkAssembliesWithAttribute</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Project</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>10/30/2007</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1016:MarkAssembliesWithAssemblyVersion;CA1014:MarkAssembliesWithClsCompliant;CA1017:MarkAssembliesWithComVisible</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00007</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/MarkAssembliesWithAttribute.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>System.Reflection.AssemblyVersionAttribute</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ParameterValuesToSet</Name>
          <Value>"1.0.0.0"</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>IgnoreAspProject</Name>
          <Value>True</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>IgnoreSingleTypeAssembly</Name>
          <Value>False</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>IgnoreAssemblyWithoutPublicTypes</Name>
          <Value>False</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[An assembly does not have one of the following attributes applied to it:
	<b>System.CLSCompliantAttribute</b>, <b>System.AssemblyVersionAttribute</b>,
	or <b>System.Runtime.InteropServices.ComVisibleAttribute</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, an assembly should have the following
  attributes applied:<br />
  <ul>
    <li><b>System.CLSCompliantAttribute</b>: Mark the assembly with a
      <b>System.CLSCompliantAttribute</b> attribute in a class library project to ensure
      that all its types and members are compliant with the Common Language Specification (CLS)
      and can be called by any other .NET language.</li>
    <li><b>System.AssemblyVersionAttribute</b>: The version number concurs to create
      the strong name of an assembly. If <b>System.AssemblyVersionAttribute</b> attribute
      is omitted, the assembly has no version. If an asterisk ("<b>*</b>") is used in the
      version number, the version number will change each time the assembly is recompiled.
      The version number should be changed when a new version of the assembly is published.</li>
    <li><b>System.Runtime.InteropServices.ComVisibleAttribute</b>: Attribute
      controls accessibility of an individual managed type or member, or of all types within
      an assembly, to COM. Assemblies should explicitly indicate COM visibility.
      The contents of the assembly are visible to COM clients by default, if the attribute
      is not present.</li>
  </ul>
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
	<li>'Mark assemblies with assembly version', CheckId <b>CA1016</b></li>
	<li>'Mark assemblies with CLSCompliant', CheckId <b>CA1014</b></li>
	<li>'Mark assemblies with ComVisible', CheckId <b>CA1017</b></li>
	</ul></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Apply missing attribute to the assembly.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>AttributeToCheck</i> - Certain Attribute to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Mark assemblies with assembly version.</li>
    <li>Mark assemblies with CLSCompliant</li>
    <li>Mark assemblies with ComVisible</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

&lt;Assembly:AssemblyVersion("1.2.*")&gt;


<SPAN class=code-selected>' This is the correct implementation</SPAN>

&lt;Assembly:AssemblyVersion("1.2.<SPAN class=code-changed>3.4</SPAN>")&gt;

&lt;Assembly:CLSCompliant(True)&gt;

&lt;Assembly:System.Runtime.InteropServices.ComVisible(False)&gt;
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

[assembly:AssemblyVersion("1.2.*")]


<SPAN class=code-selected>// This is the correct implementation</SPAN>

[assembly:AssemblyVersion("1.2.<SPAN class=code-changed>3.4</SPAN>")]

[assembly:CLSCompliant(true)]

[assembly:System.Runtime.InteropServices.ComVisible(false)]
	
	</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00007">
      <Name>Assembly -&gt; Should have CLSCompliant attribute</Name>
      <Title>Mark assemblies with CLSCompliant</Title>
      <ClassName>MarkAssembliesWithAttribute</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Project</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>10/30/2007</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1016:MarkAssembliesWithAssemblyVersion;CA1014:MarkAssembliesWithClsCompliant;CA1017:MarkAssembliesWithComVisible</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00007</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/MarkAssembliesWithAttribute.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>System.CLSCompliantAttribute</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ParameterValuesToSet</Name>
          <Value>false;true</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>IgnoreAspProject</Name>
          <Value>True</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>IgnoreSingleTypeAssembly</Name>
          <Value>False</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>IgnoreAssemblyWithoutPublicTypes</Name>
          <Value>False</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[An assembly does not have one of the following attributes applied to it:
	<b>System.CLSCompliantAttribute</b>, <b>System.AssemblyVersionAttribute</b>,
	or <b>System.Runtime.InteropServices.ComVisibleAttribute</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, an assembly should have the following
  attributes applied:<br />
  <ul>
    <li><b>System.CLSCompliantAttribute</b>: Mark the assembly with a
      <b>System.CLSCompliantAttribute</b> attribute in a class library project to ensure
      that all its types and members are compliant with the Common Language Specification (CLS)
      and can be called by any other .NET language.</li>
    <li><b>System.AssemblyVersionAttribute</b>: The version number concurs to create
      the strong name of an assembly. If <b>System.AssemblyVersionAttribute</b> attribute
      is omitted, the assembly has no version. If an asterisk ("<b>*</b>") is used in the
      version number, the version number will change each time the assembly is recompiled.
      The version number should be changed when a new version of the assembly is published.</li>
    <li><b>System.Runtime.InteropServices.ComVisibleAttribute</b>: Attribute
      controls accessibility of an individual managed type or member, or of all types within
      an assembly, to COM. Assemblies should explicitly indicate COM visibility.
      The contents of the assembly are visible to COM clients by default, if the attribute
      is not present.</li>
  </ul>
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
	<li>'Mark assemblies with assembly version', CheckId <b>CA1016</b></li>
	<li>'Mark assemblies with CLSCompliant', CheckId <b>CA1014</b></li>
	<li>'Mark assemblies with ComVisible', CheckId <b>CA1017</b></li>
	</ul></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Apply missing attribute to the assembly.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>AttributeToCheck</i> - Certain Attribute to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Mark assemblies with assembly version.</li>
    <li>Mark assemblies with CLSCompliant</li>
    <li>Mark assemblies with ComVisible</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

&lt;Assembly:AssemblyVersion("1.2.*")&gt;


<SPAN class=code-selected>' This is the correct implementation</SPAN>

&lt;Assembly:AssemblyVersion("1.2.<SPAN class=code-changed>3.4</SPAN>")&gt;

&lt;Assembly:CLSCompliant(True)&gt;

&lt;Assembly:System.Runtime.InteropServices.ComVisible(False)&gt;
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

[assembly:AssemblyVersion("1.2.*")]


<SPAN class=code-selected>// This is the correct implementation</SPAN>

[assembly:AssemblyVersion("1.2.<SPAN class=code-changed>3.4</SPAN>")]

[assembly:CLSCompliant(true)]

[assembly:System.Runtime.InteropServices.ComVisible(false)]
	
	</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00007">
      <Name>Assembly -&gt; Should have ComVisible attribute</Name>
      <Title>Mark assemblies with ComVisible</Title>
      <ClassName>MarkAssembliesWithAttribute</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Project</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>10/30/2007</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1016:MarkAssembliesWithAssemblyVersion;CA1014:MarkAssembliesWithClsCompliant;CA1017:MarkAssembliesWithComVisible</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00007</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/MarkAssembliesWithAttribute.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>System.Runtime.InteropServices.ComVisibleAttribute</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ParameterValuesToSet</Name>
          <Value>false;true</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>IgnoreAspProject</Name>
          <Value>True</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>IgnoreSingleTypeAssembly</Name>
          <Value>False</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>IgnoreAssemblyWithoutPublicTypes</Name>
          <Value>True</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[An assembly does not have one of the following attributes applied to it:
	<b>System.CLSCompliantAttribute</b>, <b>System.AssemblyVersionAttribute</b>,
	or <b>System.Runtime.InteropServices.ComVisibleAttribute</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, an assembly should have the following
  attributes applied:<br />
  <ul>
    <li><b>System.CLSCompliantAttribute</b>: Mark the assembly with a
      <b>System.CLSCompliantAttribute</b> attribute in a class library project to ensure
      that all its types and members are compliant with the Common Language Specification (CLS)
      and can be called by any other .NET language.</li>
    <li><b>System.AssemblyVersionAttribute</b>: The version number concurs to create
      the strong name of an assembly. If <b>System.AssemblyVersionAttribute</b> attribute
      is omitted, the assembly has no version. If an asterisk ("<b>*</b>") is used in the
      version number, the version number will change each time the assembly is recompiled.
      The version number should be changed when a new version of the assembly is published.</li>
    <li><b>System.Runtime.InteropServices.ComVisibleAttribute</b>: Attribute
      controls accessibility of an individual managed type or member, or of all types within
      an assembly, to COM. Assemblies should explicitly indicate COM visibility.
      The contents of the assembly are visible to COM clients by default, if the attribute
      is not present.</li>
  </ul>
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
	<li>'Mark assemblies with assembly version', CheckId <b>CA1016</b></li>
	<li>'Mark assemblies with CLSCompliant', CheckId <b>CA1014</b></li>
	<li>'Mark assemblies with ComVisible', CheckId <b>CA1017</b></li>
	</ul></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Apply missing attribute to the assembly.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>AttributeToCheck</i> - Certain Attribute to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Mark assemblies with assembly version.</li>
    <li>Mark assemblies with CLSCompliant</li>
    <li>Mark assemblies with ComVisible</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

&lt;Assembly:AssemblyVersion("1.2.*")&gt;


<SPAN class=code-selected>' This is the correct implementation</SPAN>

&lt;Assembly:AssemblyVersion("1.2.<SPAN class=code-changed>3.4</SPAN>")&gt;

&lt;Assembly:CLSCompliant(True)&gt;

&lt;Assembly:System.Runtime.InteropServices.ComVisible(False)&gt;
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

[assembly:AssemblyVersion("1.2.*")]


<SPAN class=code-selected>// This is the correct implementation</SPAN>

[assembly:AssemblyVersion("1.2.<SPAN class=code-changed>3.4</SPAN>")]

[assembly:CLSCompliant(true)]

[assembly:System.Runtime.InteropServices.ComVisible(false)]
	
	</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00009">
      <Name>Public Type -&gt; Nested types should not be visible</Name>
      <Title>Nested types should not be visible</Title>
      <ClassName>NestedTypesShouldNotBeVisible</ClassName>
      <Scope>Public</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1034:NestedTypesShouldNotBeVisible</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00009</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/NestedTypesShouldNotBeVisible.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Public type contains the nested public type
	that does not implement <b>System.Collections.IEnumerator</b> interface.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, <b>private</b> or <b>internal</b>
  (<b>Friend</b> in Visual Basic) scope qulifier should be used for nested types.<br />
  <br />
	Nested types are useful for encapsulating private implementation details of the containing type 
	and should not be externally visible. A type should be nested if it is used only by the type
	that encloses it; therefore, in most cases there is no reason for making the nested type public.<br />
	<br />
	<b>Exception</b>: Nested enumerators and comparers can be given public scope.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Nested types should not be visible', CheckId <b>CA1034</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Change the nested type modifier.
    <LI>Move the nested type from its parent type. 
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Nested types should not be visible.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System

  Namespace SampleLibrary

    Public Class ParentSample

      ' Violation: nested type should not be public  
      Public Class NestedSample
      
        Public Sub New()
        
          ...
        
        End Sub
          
      End Class

      Public Sub New()
      
        ...
      
      End Sub

    End Class

  End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System

  Namespace SampleLibrary

    Public Class ParentSample

      <SPAN class=code-changed>Private</SPAN> Class NestedSample
      
        Public Sub New()
        
          ...
        
        End Sub
          
      End Class

      Public Sub New()
      
        ...
      
      End Sub

    End Class

  End Namespace

Or


  Imports System

  Namespace SampleLibrary

    Public Class ParentSample

      Public Sub New()
      
        ...
      
      End Sub

    End Class

    <SPAN class=code-changed>' nested class moved from its parent type</SPAN>
    Public Class NestedSample
    
      Public Sub New()
      
        ...
      
      End Sub
        
    End Class

  End Namespace
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;

  namespace SampleLibrary
  {

    public class ParentSample
    {

      // Violation: nested type should not be public  
      public class NestedSample
      {
      
        public NestedSample()
        {
        
          ...
        
        }
          
      }

      public ParentSample()
      {
      
        ...
      
      }

    }

  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;

  namespace SampleLibrary
  {

    public class ParentSample
    {

      <SPAN class=code-changed>private</SPAN> class NestedSample
      {
      
        public ParentSample()
        {
        
          ...
        
        }
          
      }

      public ParentSample()
      {
      
        ...
      
      }

    }

  }

Or


  using System;

  mamespace SampleLibrary
  {

    public class ParentSample
    {

      public ParentSample()
      {
      
        ...
      
      }

    }

    <SPAN class=code-changed>// nested class moved from its parent type</SPAN>
    public class NestedSample
    {
    
      public NestedSample()
      {
      
        ...
      
      }
        
    }

  }
	
	</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00010">
      <Name>Type -&gt; Contains only static members -&gt; Should be sealed (NotInheritable)</Name>
      <Title>Type that contains only static members should be sealed (NotInheritable)</Title>
      <ClassName>TypesContainStaticMembersShouldBeSealed</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1052:StaticHolderTypesShouldBeSealed</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00010</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/TypesContainStaticMembersShouldBeSealed.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A <b>sealed</b> (<b>NotInheritable</b> for Visual Basic) modifier does not set for
  a public or protected type that contains static members only.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, a type that is not meant to be inherited
  should be marked with the <B>sealed</B> (C#) or <b>NotInheritable</b> (Visual Basic)
  modifier. If a type containing static members only, then it does not provide any
  functionality that can be overridden in a derived type; therefore, it is not designed
  to be inherited.<br />
  <br />
  A sealed type performs slightly better because all its properties and methods are
  implicitly sealed and the compiler can often inline them.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Static holder types should be sealed', CheckId <b>CA1052</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
	  <LI>Change type modifier to <b>sealed</b> (<b>NotInheritable</b> for Visual Basic).
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Type that contains only static members should be sealed (NotInheritable).</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System

Namespace SampleLibrary

  Public Class StaticsOnly
  
      Private Shared _staticField As String 

      Shared Property StaticProperty As String
          Get
              Return _staticField
          End Get
          Set
              _staticField = Value
          End Set
      End Property

      Private Sub New()
      End Sub

      Shared Sub StaticMethod()
      End Sub

  End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System

Namespace SampleLibrary

  Public <SPAN class=code-changed>NotInheritable</SPAN> Class StaticsOnly
  
      Private Shared _staticField As String 

      Shared Property StaticProperty As String
          Get
              Return _staticField
          End Get
          Set
              _staticField = Value
          End Set
      End Property

      Private Sub New()
      End Sub

      Shared Sub StaticMethod()
      End Sub

  End Class

End Namespace

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;

namespace SampleLibrary
{

  public class StaticsOnly
  {
  
      private static string_staticField;

      public static string StaticProperty
      {
          get
          {
              return _staticField;
          }
          set
          {
              _staticField = value;
          }
      }

      private StaticsOnly()
      {
      }

      public static void StaticMethod()
      {
      }

  }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;

namespace SampleLibrary
{

  public <SPAN class=code-changed>sealed</SPAN> class StaticsOnly
  {
  
      private static string_staticField;

      public static string StaticProperty
      {
          get
          {
              return _staticField;
          }
          set
          {
              _staticField = value;
          }
      }

      private StaticsOnly()
      {
      }

      public static void StaticMethod()
      {
      }

  }

}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00011">
      <Name>Type -&gt; Contains only static members -&gt; Should not have public or protected constructors</Name>
      <Title>Type that contains only static members should not have public or protected constructors</Title>
      <ClassName>TypesContainStaticMembersShouldNotHaveConstructors</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Error</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1053:StaticHolderTypesShouldNotHaveConstructors</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00011</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/TypesContainStaticMembersShouldNotHaveConstructors.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A public or nested public type contains static members only, but has a public or 
  protected default constructor.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Creating an instance does not provide access to any of the type's members, if the type contains static members only.
  Calling static members does not require an instance of the type;
  therefore the constructor is unnecessary.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Static holder types should not have constructors', CheckId <b>CA1053</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Change constructor(s) modifier to <b>Private</b>. 
    <LI>Comment out constructor(s) in the type. 
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Type that contains only static members should not have public or protected constructors.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System

Namespace SampleLibrary

  Public Class StaticsOnly
  
      Private Shared _staticField As String 

      Shared Property StaticProperty As String
          Get
              Return _staticField
          End Get
          Set
              _staticField = Value
          End Set
      End Property

      ' Violation: unnecessary public constructor
      Public Sub New()
      End Sub

      Shared Sub StaticMethod()
      End Sub

  End Class

End Namespace

- Or -

Imports System

Namespace SampleLibrary

  ' Violation: the Visual Basic compiler
  ' will create a default public constructor.
  Public Class StaticsOnly
  
      Private Shared _staticField As String 

      Shared Property StaticProperty As String
          Get
              Return _staticField
          End Get
          Set
              _staticField = Value
          End Set
      End Property

      Shared Sub StaticMethod()
      End Sub

  End Class

End Namespace



<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System

Namespace SampleLibrary

  Public Class StaticsOnly
  
      Private Shared _staticField As String 

      Shared Property StaticProperty As String
          Get
              Return _staticField
          End Get
          Set
              _staticField = Value
          End Set
      End Property

      <SPAN class=code-changed>Private</SPAN> Sub New()
      End Sub

      Shared Sub StaticMethod()
      End Sub

  End Class

End Namespace

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;

namespace SampleLibrary
{

  public class StaticsOnly
  {
  
      private static string _staticField;

      public static string StaticProperty
      {
          get
          {
              return _staticField;
          }
          set
          {
              _staticField = value;
          }
      }

      // Violation: unnecessary public constructor
      public StaticsOnly()
      {
      }

      public static void StaticMethod()
      {
      }

  }

}

- Or -

using System;

namespace SampleLibrary
{

  // Violation: C# compiler will create
  // a default public constructor.
  public class StaticsOnly
  {
  
      private static string _staticField;

      public static string StaticProperty
      {
          get
          {
              return _staticField;
          }
          set
          {
              _staticField = value;
          }
      }

      public static void StaticMethod()
      {
      }

  }

}



<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;

namespace SampleLibrary
{

  public class StaticsOnly
  {
  
      private static string _staticField;

      public static string StaticProperty
      {
          get
          {
              return _staticField;
          }
          set
          {
              _staticField = value;
          }
      }

      <SPAN class=code-changed>private</SPAN> StaticsOnly()
      {
      }

      public static void StaticMethod()
      {
      }

  }

}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00012">
      <Name>Dispose -&gt; Type -&gt; That owns disposable fields should be disposable</Name>
      <Title>Types that own disposable fields should be disposable</Title>
      <ClassName>TypesThatOwnDisposableFieldsShouldBeDisposable</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>3/28/2011</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00012</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/TypesThatOwnDisposableFieldsShouldBeDisposable.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Type has an instance field that is the <b>System.IDisposable</b> type,
	but does not implement the <b>System.IDisposable</b> interface.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, the <b>System.IDisposable</b> interface
  should be implemented if a method in the type creates one or more instances of other
  disposable objects (a disposable object is an object that implements the
  <b>System.IDisposable</b> interface) and the method doesn't invoke the objects' <b>Dispose</b>
  method before returning to the caller. A class that declares a <b>System.IDisposable</b>
  field should implement the <b>System.IDisposable</b> interface, because it indirectly owns
  an unmanaged resources.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Types that own disposable fields should be disposable', CheckId <b>CA1001</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Implement Dispose-Finalize pattern for the type.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Types that own disposable fields should be disposable.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Data
Imports System.Data.OleDb

Namespace SampleLibrary

  Public Class DbManipulator
  
    Private _con As OleDbConnection
    
    Public Sub BeginDbProcess()
      ' Create and use the connection, leave it open
      _con = New OleDbConnection()
      
      ...
      
    End Sub

    Public Sub EndDbProcess()
      ' use the connection, then close it
      If Not _con Is Nothing Then

        ...

        _con.Close()
      End If
    End Sub

  End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Data
Imports System.Data.OleDb

Namespace SampleLibrary

  Public Class DbManipulator
    <SPAN class=code-changed>Implements IDisposable</SPAN>
  
    Private _con As OleDbConnection
    
    Public Sub BeginDbProcess()
      ' Create and use the connection, leave it open
      _con = New OleDbConnection()
      
      ...
      
    End Sub

    Public Sub EndDbProcess()
      ' use the connection, then close it
      If Not _con Is Nothing Then

        ...

        _con.Close()
      End If
    End Sub
    
    <SPAN class=code-changed>Public Sub Dispose() Implements IDisposable.Dispose
      If Not _con Is Nothing Then
        _con.Close()
      End If
    End Sub</SPAN>

  End Class

End Namespace

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Data;
using System.Data.OleDb;

namespace SampleLibrary
{

  public class DbManipulator
  {
  
    private OleDbConnection _con;
    
    public void BeginDbProcess()
    {
      // Create and use the connection, leave it open
      _con = new OleDbConnection();
      
      ...
      
    }

    public void EndDbProcess()
    {
      // use the connection, then close it
      if (_con != null)
      {

        ...

        _con.Close();
      }
    }

  }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;
using System.Data;
using System.Data.OleDb;

namespace SampleLibrary
{

  public class DbManipulator: <SPAN class=code-changed>IDisposable</SPAN>
  {
  
    private OleDbConnection _con;
    
    public void BeginDbProcess()
    {
      // Create and use the connection, leave it open
      _con = new OleDbConnection();
      
      ...
      
    }

    public void EndDbProcess()
    {
      // use the connection, then close it
      if (_con != null)
      {

        ...

        _con.Close();
      }
    }
    
    <SPAN class=code-changed>public void Dispose()
    {
      if (_con != null)
      {
        _con.Close();
      }
    }</SPAN>

  }

}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="DE00013">
      <Name>Dispose -&gt; Type -&gt; That owns unmanaged resources should be disposable</Name>
      <Title>Types that own unmanaged resources should be disposable</Title>
      <ClassName>TypesThatOwnUnmanagedResourcesShouldBeDisposable</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Design</RuleCategory>
      <RuleModificationDate>3/13/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1049:TypesThatOwnNativeResourcesShouldBeDisposable</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=DE00013</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/TypesThatOwnUnmanagedResourcesShouldBeDisposable.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A type has unmanaged field,	but does not implement the <b>System.IDisposable</b> interface.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[If a type has <b>System.IntPtr</b>, <b>System.UIntPtr</b>, and
  <b>System.Runtime.InteropServices.HandleRef</b> fields, than it most likely stores
  pointers to unmanaged resources. Such types should implement the <b>System.IDisposable</b>
  interface to allow callers to release allocated unmanaged resources.<br />
  <br />
  Types must adopt the recommended Dispose-Finalize design pattern to implement the
  <b>System.IDisposable</b> interface and clean up unmanaged resources.<br />
  <br />
  
  The recommended design pattern to clean up unmanaged resources is to provide both an implicit and an explicit means to free those resources using the System.Object.Finalize method and the System.IDisposable.Dispose method, respectively. 
  
  that allocate unmanaged resources should implement IDisposable 
  
  According to Microsoft .NET Framework guidelines, the <b>System.IDisposable</b> interface
  should be implemented if a method in the type creates one or more instances of other
  disposable objects (a disposable object is an object that implements the
  <b>System.IDisposable</b> interface) and the method doesn't invoke the objects' <b>Dispose</b>
  method before returning to the caller. A class that declares a <b>System.IDisposable</b>
  field should implement the <b>System.IDisposable</b> interface, because it indirectly owns
  an unmanaged resources.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Types that own native resources should be disposable', CheckId <b>CA1049</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Implement Dispose-Finalize pattern for the type.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Types that own unmanaged resources should be disposable.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class IncorrectType

  Private _someUnmanagedResource As UIntPtr
  
  Sub New()
    ' Allocate the unmanaged resource
    _someUnmanagedResource = ...
  End Sub

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Public Class CorrectType
    Implements IDisposable

    Private _someUnmanagedResource As UIntPtr
    Protected disposed As Boolean = False
    
    Sub New()
      ' Allocate the unmanaged resource ...
      _someUnmanagedResource = ...
    End Sub

    Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
        If disposing Then
        
          ...
          
        End If
        
        ' Release unmanaged resources
        ...
        
        _someUnmanagedResource = IntPtr.Zero
    
        Me.disposed = True

      End If
    End Sub

    Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
    End Sub
    
    Protected Overrides Sub Finalize()
      Try
        Dispose(False)
      Catch
        ' Deal with errors or just ignore them
      Finally
        ' Invoke the base object's Finalize method
        MyBase.Finalize()
      End Try
    End Sub
    
  End Class

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class IncorrectType
{

  private UIntPtr _someUnmanagedResource;
  
  IncorrectType()
  {
    // Allocate the unmanaged resource
    _someUnmanagedResource = ...
  }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  public class CorrectType : IDisposable
  {

    private UIntPtr _someUnmanagedResource;
    protected bool disposed = false;
    
    CorrectType()
    {
      // Allocate the unmanaged resource ...
      _someUnmanagedResource = ...
    }

    protected virtual void Dispose(bool disposing)
    {
  		lock(this)
	  	{
        if (!this.disposed)
        {
          if (disposing)
          {
            // Release disposable objects used by this instance here.
        
            ...
        
          }
          // Release unmanaged resources here.
      
          ...
          
          _someUnmanagedResource = IntPtr.Zero;
      
          this.disposed = true;
        }
      }
    }

    public void Dispose()
    {
      Dispose(true);
    
      // Unregister object for finalization
      GC.SuppressFinalize(this);
    }
  
    ~DisposableType()
    {
      Dispose(false);
    }
    
  }

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="EX00001">
      <Name>Method -&gt; Do not catch general exception types</Name>
      <Title>Do not catch general exception types</Title>
      <ClassName>DoNotCatchSpecifiedExceptionTypes</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Statement</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>ExceptionHandling;Design</RuleCategory>
      <RuleModificationDate>12/16/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1031:DoNotCatchGeneralExceptionTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=EX00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotCatchSpecifiedExceptionTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>CheckForRethrow</Name>
          <Value>True</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>Exceptions</Name>
          <Value>System.Exception, System.SystemException</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[General exception type (<b>System.Exception</b> or <b>System.SystemException</b>) 
  is caught in a <B>catch</B> statement.<br />
  <br />
  Or<br />
  <br />
  A general <B>catch</B> clause is used.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, it is not recommended to 
  catch general <b>System.Exception</b> or <b>System.SystemException</b>. More 
  specific exception should be caught. For the second case, the general exception 
  should be re-thrown in the catch block.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not catch general exception types', CheckId <b>CA1031</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>
    Change type of the exception to the specified type.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
    <li>
      <i>CheckForRethrow</i> - Check for re-throw the exception;</li>
    <li>
      <i>Exceptions</i> - A comma-separated list of the exception types.</li>
  </ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not catch general exception types.</li>
    <li>Do not catch the specific exception types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class SampleFileReader
  
    Private _path As String = "c:\temp\TestFile.txt"
    
    Public Sub ReadData()
    
      Dim inputStream As FileStream
      
      ' Violation: General <b>System.SystemException</b> has been caught.
      Try
        inputStream = OpenRead(_path)
      Catch ex As SystemException
        Console.WriteLine("Unable to open file.")
      End Try
      
      Dim buffer(1024) As Byte
      Dim utf8 As UTF8Encoding = New UTF8Encoding(True)

      ' Violation: a non-specific exception has been caught.
      Try
        Do While inputStream.Read(buffer, 0, buffer.Length) &gt; 0
            Console.WriteLine(utf8.GetString(buffer))
        Loop
      Catch
        Console.WriteLine("Unable to read file.")
      End Try
      
      inputStream.Close()
      
    End Sub
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class SampleFileReader
  
    Private _path As String = "c:\temp\TestFile.txt"
    
    Public Sub ReadData()
    
      Dim inputStream As FileStream
      
      Try
        inputStream = OpenRead(_path)
      Catch ex As <SPAN class=code-changed>FileNotFoundException</SPAN>
        Console.WriteLine("Unable to open file.")
      End Try
      
      Dim buffer(1024) As Byte
      Dim utf8 As UTF8Encoding = New UTF8Encoding(True)

      Try
        Do While inputStream.Read(buffer, 0, buffer.Length) &gt; 0
            Console.WriteLine(utf8.GetString(buffer))
        Loop
      Catch
        Console.WriteLine("Unable to read file.")
        <SPAN class=code-changed>Throw</SPAN>
      End Try
      
      inputStream.Close()
      
    End Sub
  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class SampleFileReader
  {
  
    private string _path = @"c:\temp\TestFile.txt";
    
    public void ReadData()
    {
    
      FileStream inputStream;
      
      // Violation: General <b>System.SystemException</b> has been caught.
      try
      {
        inputStream = OpenRead(_path);
      }
      catch (SystemException ex)
      {
        Console.WriteLine("Unable to open file.");
      }
      
      byte[] buffer = new byte[1024];
      UTF8Encoding utf8 = new UTF8Encoding(true);

      // Violation: a non-specific exception has been caught.
      try
      {
        while (inputStream.Read(buffer, 0, buffer.Length) &gt; 0)
        {
            Console.WriteLine(utf8.GetString(buffer));
        }
      }
      catch
      {
        Console.WriteLine("Unable to read file.");
      }
      
      inputStream.Close();
      
    }
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class SampleFileReader
  {
  
    private string _path = @"c:\temp\TestFile.txt";
    
    public void ReadData()
    {
    
      FileStream inputStream;
      
      try
      {
        inputStream = OpenRead(_path);
      }
      catch (<SPAN class=code-changed>FileNotFoundException</SPAN> ex)
      {
        Console.WriteLine("Unable to open file.");
      }
      
      byte[] buffer = new byte[1024];
      UTF8Encoding utf8 = new UTF8Encoding(true);

      try
      {
        while (inputStream.Read(buffer, 0, buffer.Length) &gt; 0)
        {
            Console.WriteLine(utf8.GetString(buffer));
        }
      }
      catch
      {
        Console.WriteLine("Unable to read file.");
        <SPAN class=code-changed>throw;</SPAN>
      }
      
      inputStream.Close();
      
    }
  
  }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="EX00001">
      <Name>Method -&gt; Do not catch the specific exception types</Name>
      <Title>Do not catch the specific exception types</Title>
      <ClassName>DoNotCatchSpecifiedExceptionTypes</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Statement</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>ExceptionHandling;Design</RuleCategory>
      <RuleModificationDate>12/16/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1031:DoNotCatchGeneralExceptionTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=EX00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotCatchSpecifiedExceptionTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>CheckForRethrow</Name>
          <Value>False</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>Exceptions</Name>
          <Value>System.StackOverflowException, System.Runtime.InteropServices.SEHException</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[General exception type (<b>System.Exception</b> or <b>System.SystemException</b>) 
  is caught in a <B>catch</B> statement.<br />
  <br />
  Or<br />
  <br />
  A general <B>catch</B> clause is used.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, it is not recommended to 
  catch general <b>System.Exception</b> or <b>System.SystemException</b>. More 
  specific exception should be caught. For the second case, the general exception 
  should be re-thrown in the catch block.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not catch general exception types', CheckId <b>CA1031</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>
    Change type of the exception to the specified type.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
    <li>
      <i>CheckForRethrow</i> - Check for re-throw the exception;</li>
    <li>
      <i>Exceptions</i> - A comma-separated list of the exception types.</li>
  </ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not catch general exception types.</li>
    <li>Do not catch the specific exception types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class SampleFileReader
  
    Private _path As String = "c:\temp\TestFile.txt"
    
    Public Sub ReadData()
    
      Dim inputStream As FileStream
      
      ' Violation: General <b>System.SystemException</b> has been caught.
      Try
        inputStream = OpenRead(_path)
      Catch ex As SystemException
        Console.WriteLine("Unable to open file.")
      End Try
      
      Dim buffer(1024) As Byte
      Dim utf8 As UTF8Encoding = New UTF8Encoding(True)

      ' Violation: a non-specific exception has been caught.
      Try
        Do While inputStream.Read(buffer, 0, buffer.Length) &gt; 0
            Console.WriteLine(utf8.GetString(buffer))
        Loop
      Catch
        Console.WriteLine("Unable to read file.")
      End Try
      
      inputStream.Close()
      
    End Sub
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class SampleFileReader
  
    Private _path As String = "c:\temp\TestFile.txt"
    
    Public Sub ReadData()
    
      Dim inputStream As FileStream
      
      Try
        inputStream = OpenRead(_path)
      Catch ex As <SPAN class=code-changed>FileNotFoundException</SPAN>
        Console.WriteLine("Unable to open file.")
      End Try
      
      Dim buffer(1024) As Byte
      Dim utf8 As UTF8Encoding = New UTF8Encoding(True)

      Try
        Do While inputStream.Read(buffer, 0, buffer.Length) &gt; 0
            Console.WriteLine(utf8.GetString(buffer))
        Loop
      Catch
        Console.WriteLine("Unable to read file.")
        <SPAN class=code-changed>Throw</SPAN>
      End Try
      
      inputStream.Close()
      
    End Sub
  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class SampleFileReader
  {
  
    private string _path = @"c:\temp\TestFile.txt";
    
    public void ReadData()
    {
    
      FileStream inputStream;
      
      // Violation: General <b>System.SystemException</b> has been caught.
      try
      {
        inputStream = OpenRead(_path);
      }
      catch (SystemException ex)
      {
        Console.WriteLine("Unable to open file.");
      }
      
      byte[] buffer = new byte[1024];
      UTF8Encoding utf8 = new UTF8Encoding(true);

      // Violation: a non-specific exception has been caught.
      try
      {
        while (inputStream.Read(buffer, 0, buffer.Length) &gt; 0)
        {
            Console.WriteLine(utf8.GetString(buffer));
        }
      }
      catch
      {
        Console.WriteLine("Unable to read file.");
      }
      
      inputStream.Close();
      
    }
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class SampleFileReader
  {
  
    private string _path = @"c:\temp\TestFile.txt";
    
    public void ReadData()
    {
    
      FileStream inputStream;
      
      try
      {
        inputStream = OpenRead(_path);
      }
      catch (<SPAN class=code-changed>FileNotFoundException</SPAN> ex)
      {
        Console.WriteLine("Unable to open file.");
      }
      
      byte[] buffer = new byte[1024];
      UTF8Encoding utf8 = new UTF8Encoding(true);

      try
      {
        while (inputStream.Read(buffer, 0, buffer.Length) &gt; 0)
        {
            Console.WriteLine(utf8.GetString(buffer));
        }
      }
      catch
      {
        Console.WriteLine("Unable to read file.");
        <SPAN class=code-changed>throw;</SPAN>
      }
      
      inputStream.Close();
      
    }
  
  }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="EX00002">
      <Name>Method -&gt; Do not handle non-CLS-compliant exceptions</Name>
      <Title>Do not handle non-CLS-compliant exceptions</Title>
      <ClassName>DoNotHandleNonCLSCompliantExceptions</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Statement</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>ExceptionHandling;Design</RuleCategory>
      <RuleModificationDate>12/16/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Design, CA1031:DoNotCatchGeneralExceptionTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=EX00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotHandleNonCLSCompliantExceptions.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Non-CLS-compliant exceptions (exceptions that don't derive from <b>System.Exception</b>) 
  caught using parameterless catch block.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Catching non-CLS-compliant exceptions can hide run-time problems from the 
  library user.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not catch general exception types', CheckId <b>CA1031</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Catch the specific exception using a parameter <b>catch</b> block.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>
      Do not handle non-CLS-compliant exceptions.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System.IO
Imports System.Text
Imports System.Diagnostics

Public Class FileUtility

  Public Function GetFileContentIncorrectly(fileName As String) As String
  
    Dim returnValue As String = ""
  
    Try
    
      Using sr As New StreamReader(fileName, Encoding.ASCII)
        returnValue = sr.ReadToEnd()
      End Using
      
    Catch ' Violated the rule because catched a non-specific exception.
        Debug.WriteLine("Unhandled exception.")
    End Try

    GetFileContentIncorrectly = returnValue
    
  End Function
    
End Class

<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System.IO
Imports System.Text
Imports System.Diagnostics

Public Class FileUtility

  Public Function GetFileContentCorrectly1(fileName As String) As String
  
    Dim returnValue As String = ""

    Try
    
      Using sr As new StreamReader(fileName, Encoding.ASCII)
        returnValue = sr.ReadToEnd()
      End Using
    ' Do not violate because catched a specific exception.		
    <SPAN class=code-changed>Catch ex As FileNotFoundException</SPAN> 
      Debug.WriteLine("File not found: " + fileName)
    End Try

    GetFileContentCorrectly1 = returnValue
  End Function

  Public Function GetFileContentCorrectly2(fileName As String) As String
  
    Dim returnValue As String = ""
    
    Try
        Using sr As new StreamReader(fileName, Encoding.ASCII)
            returnValue = sr.ReadToEnd()
        End Using
    ' Do not violate because re-throwed the generic exception
    Catch 

        Debug.WriteLine("Unhandled exception in " + fileName)
        <SPAN class=code-changed>Throw</SPAN>			

    End Try

    GetFileContentCorrectly2 = returnValue
  End Function
  
End Class
</pre>
  <br />
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System.IO;
using System.Text;
using System.Diagnostics;

class FileUtility
{
    public string GetFileContentIncorrectly(string fileName)
    {
        try
        {
            using (StreamReader sr = new StreamReader(fileName, Encoding.ASCII))
            {
                return sr.ReadToEnd();
            }
        }
        catch // Violated the rule because catched a non-specific exception.
        {
            Debug.WriteLine("Unhandled exception.");
        }

        return string.Empty;
    }
}

<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System.IO;
using System.Text;
using System.Diagnostics;

class FileUtility
{
    public string GetFileContentCorrectly1(string fileName)
    {
        try
        {
            using (StreamReader sr = new StreamReader(fileName, Encoding.ASCII))
            {
                return sr.ReadToEnd();
            }
        }
        // Do not violate because catched a specific exception.		
        <SPAN class=code-changed>catch (FileNotFoundException)</SPAN> 
        {
            Debug.WriteLine("File not found: \"" + fileName + "\"");
        }

        return string.Empty;
    }

    public string GetFileContentCorrectly2(string fileName)
    {
        try
        {
            using (StreamReader sr = new StreamReader(fileName, Encoding.ASCII))
            {
                return sr.ReadToEnd();
            }
        }
        // Did not violate because re-throwed the generic exception
        catch 
        {
            Debug.WriteLine("Unhandled exception in \"" + fileName + "\"");
            
            <SPAN class=code-changed>throw;</SPAN>			
        }

        return string.Empty;
    }
}
</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="EX00003">
      <Name>Method -&gt; Do not raise general exception types</Name>
      <Title>Do not raise general exception types</Title>
      <ClassName>DoNotRaiseSpecifiedExceptionTypes</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Statement</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>ExceptionHandling;Usage</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2201:DoNotRaiseReservedExceptionTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=EX00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotRaiseSpecifiedExceptionTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExceptionCategory</Name>
          <Value>General</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>Exceptions</Name>
          <Value>System.Exception, System.SystemException, System.ApplicationException</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[A method raises one of the special .NET exceptions or exception that is too general.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, the following too general exceptions should not be thrown:
	<ul>
	<li><b>System.ApplicationException</b></li>
	<li><b>System.Exception</b></li>
	<li><b>System.SystemException</b></li>
	</ul>
	These exceptions are too general and therefore cannot provide the user with the sufficient information.<br />
	<br />
	The following special .NET exception types should be thrown by the common language runtime only:
	<ul>
    <li><b>System.ExecutionEngineException</b></li>
    <li><b>System.IndexOutOfRangeException </b></li>
    <li><b>System.NullReferenceException</b></li>
    <li><b>System.OutOfMemoryException</b></li>
	</ul>
	<i>This rule is similar to <b>FxCop</b> rule 'Do not raise reserved exception types', CheckId <b>CA2201</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Change type of the exception to the specified type.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>ExceptionCategory</i> - The category of the exception to check. Possible values: General, Reserved;</li>
		<li><i>Exceptions</i> - A comma-separated list of the exception types.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not raise general exception types</li>
    <li>Do not raise reserved exception types</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class SampleFileReader
  
    Private _path As String
    
    Public Property Path() As Boolean
    
      Get
        Return _path
      End Get
      
      Set(ByVal value As String)
        If value Is Nothing Then
          ' Violation: reserved <b>System.NullReferenceException</b> exception raised
          Throw New System.NullReferenceException("Incorrect Path value")
        End If
        _path = value
      End Set
      
    End Property
    
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class SampleFileReader
  
    Private _path As String
    
    Public Property Path() As Boolean
    
      Get
        Return _path
      End Get
      
      Set(ByVal value As String)
        If value Is Nothing Then
          ' The type of the thrown exception changed to more specific type
          Throw New <SPAN class=code-changed>System.ArgumentNullException("Incorrect Path value")</SPAN>
        End If
        _path = value
      End Set
      
    End Property
    
  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class SampleFileReader
  {
  
    private string _path;
    
    public bool Path
    {
    
      get
      {
        return _path;
      }
      
      set
      {
        if (value == null)
        {
          // Violation: reserved <b>System.NullReferenceException</b> exception raised
          throw new System.NullReferenceException("Incorrect Path value");
        }
        _path = value;
      }
      
    }
    
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class SampleFileReader
  {
    private string _path;
    
    public bool Path
    {
    
      get
      {
        return _path;
      }
      
      set
      {
        if (value == null)
        {
          // The type of the thrown exception changed to more specific type
          throw new <SPAN class=code-changed>System.ArgumentNullException("Incorrect Path value")</SPAN>;
        }
        _path = value;
      }
      
    }
    
  }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="EX00003">
      <Name>Method -&gt; Do not raise reserved exception types</Name>
      <Title>Do not raise reserved exception types</Title>
      <ClassName>DoNotRaiseSpecifiedExceptionTypes</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Statement</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>ExceptionHandling;Usage</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2201:DoNotRaiseReservedExceptionTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=EX00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotRaiseSpecifiedExceptionTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExceptionCategory</Name>
          <Value>Reserved</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>Exceptions</Name>
          <Value>System.ExecutionEngineException, System.IndexOutOfRangeException, System.NullReferenceException, System.OutOfMemoryException, System.AccessViolationException, System.StackOverflowException, System.Runtime.InteropServices.ExternalException, System.Runtime.InteropServices.COMException, System.Runtime.InteropServices.SEHException</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[A method raises one of the special .NET exceptions or exception that is too general.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, the following too general exceptions should not be thrown:
	<ul>
	<li><b>System.ApplicationException</b></li>
	<li><b>System.Exception</b></li>
	<li><b>System.SystemException</b></li>
	</ul>
	These exceptions are too general and therefore cannot provide the user with the sufficient information.<br />
	<br />
	The following special .NET exception types should be thrown by the common language runtime only:
	<ul>
    <li><b>System.ExecutionEngineException</b></li>
    <li><b>System.IndexOutOfRangeException </b></li>
    <li><b>System.NullReferenceException</b></li>
    <li><b>System.OutOfMemoryException</b></li>
	</ul>
	<i>This rule is similar to <b>FxCop</b> rule 'Do not raise reserved exception types', CheckId <b>CA2201</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Change type of the exception to the specified type.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>ExceptionCategory</i> - The category of the exception to check. Possible values: General, Reserved;</li>
		<li><i>Exceptions</i> - A comma-separated list of the exception types.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not raise general exception types</li>
    <li>Do not raise reserved exception types</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class SampleFileReader
  
    Private _path As String
    
    Public Property Path() As Boolean
    
      Get
        Return _path
      End Get
      
      Set(ByVal value As String)
        If value Is Nothing Then
          ' Violation: reserved <b>System.NullReferenceException</b> exception raised
          Throw New System.NullReferenceException("Incorrect Path value")
        End If
        _path = value
      End Set
      
    End Property
    
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class SampleFileReader
  
    Private _path As String
    
    Public Property Path() As Boolean
    
      Get
        Return _path
      End Get
      
      Set(ByVal value As String)
        If value Is Nothing Then
          ' The type of the thrown exception changed to more specific type
          Throw New <SPAN class=code-changed>System.ArgumentNullException("Incorrect Path value")</SPAN>
        End If
        _path = value
      End Set
      
    End Property
    
  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class SampleFileReader
  {
  
    private string _path;
    
    public bool Path
    {
    
      get
      {
        return _path;
      }
      
      set
      {
        if (value == null)
        {
          // Violation: reserved <b>System.NullReferenceException</b> exception raised
          throw new System.NullReferenceException("Incorrect Path value");
        }
        _path = value;
      }
      
    }
    
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class SampleFileReader
  {
    private string _path;
    
    public bool Path
    {
    
      get
      {
        return _path;
      }
      
      set
      {
        if (value == null)
        {
          // The type of the thrown exception changed to more specific type
          throw new <SPAN class=code-changed>System.ArgumentNullException("Incorrect Path value")</SPAN>;
        }
        _path = value;
      }
      
    }
    
  }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="EX00004">
      <Name>Member -&gt; Do not re-throw exceptions explicitly</Name>
      <Title>Do not re-throw exceptions explicitly</Title>
      <ClassName>DoNotRethrowExceptionsExplicitly</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Statement</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>ExceptionHandling;Usage</RuleCategory>
      <RuleModificationDate>11/28/2011</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2200:RethrowToPreserveStackDetails</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=EX00004</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotRethrowExceptionsExplicitly.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The method throws exception that is explicitly specified in the <b>throw</b> statement.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The original exception object should not be re-throwed explicitly. Violation of this rule will
  complicate debugging and ruin the exception's stack trace.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Rethrow to preserve stack details', CheckId <b>CA2200</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Re-throw the exception without specifying the exception explicitly.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not re-throw exceptions explicitly.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as the correct implementation.
	<br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Sub SomeMethod()

  Try
  
    ' Do something
    
  Catch Ex As SpecificException
  
    ' Violation: re-throw exceptions explicitly 
    Throw Ex
  
  End Try
  
End Sub
      

<SPAN class=code-selected>' This is the correct implementation</SPAN>

Sub SomeMethod()

  Try
  
    ' Do something
    
  Catch Ex As SpecificException
  
    <SPAN class=code-changed>Throw</SPAN>
  
  End Try
  
End Sub
	
	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

void SomeMethod()
{

  try
  {
  
    // Do something
  
  }  
  catch (SpecificException ex)
  {
  
    // Violation: re-throw exceptions explicitly 
    throw ex;
  
  }
  
}
      

<SPAN class=code-selected>// This is the correct implementation</SPAN>

void SomeMethod()
{

  try
  {
  
    // Do something
  
  }  
  catch (SpecificException ex)
  {
  
    <SPAN class=code-changed>throw</SPAN>;
  
  }
  
}
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="GE00011">
      <Name>Source File -&gt; Should have a header</Name>
      <Title>Source file should have a header</Title>
      <ClassName>SourceFileShouldHaveHeader</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>File</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>General</RuleCategory>
      <RuleModificationDate>12/14/2010</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GE00011</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SourceFileShouldHaveHeader.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>MinimumHeaderLinesCount</Name>
          <Value>3</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>Template</Name>
          <Value>&lt;#@ template language="C#" #&gt;
// ***********************************************************************
// Assembly         : &lt;#= Context.AssemblyName #&gt;
// Author           : &lt;#= Context.GetGlobalProperty("UserName") #&gt;
// Created          : &lt;#= Context.DestinationFileCreationDateTime.ToString("MM-dd-yyyy") #&gt;
//
// Last Modified By : &lt;#= Context.GetGlobalProperty("UserName") #&gt;
// Last Modified On : &lt;#= Context.DestinationFileModificationDateTime.ToString("MM-dd-yyyy") #&gt;
// ***********************************************************************
// &lt;copyright file="&lt;#= System.IO.Path.GetFileName(Context.DestinationFile) #&gt;" company="&lt;#= Context.GetGlobalProperty("CompanyName") #&gt;"&gt;
//     &lt;#= Context.GetGlobalProperty("CompanyName") #&gt;. All rights reserved.
// &lt;/copyright&gt;
// &lt;summary&gt;&lt;/summary&gt;
// ***********************************************************************
</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Source file does not have a header.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This rule is created to ensure that each source file has a header.<br />
	Headers are based on the T4 (<a href="http://msdn.microsoft.com/en-us/library/bb126445.aspx">Text Template 
	Transformation Toolkit</a>) templates. You can create your own T4 template or modify existing one.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<li>Add header to the file.</li>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li>
			<i>Template</i> - T4 template for the file header.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Source file should have a header.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="GE00010">
      <Name>Project -&gt; Enforce Warning Level 4</Name>
      <Title>Enforce Warning Level 4</Title>
      <ClassName>EnforceWarningLevel4</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>General</RuleCategory>
      <RuleModificationDate>4/3/2009</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GE00010</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/EnforceWarningLevel4.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The project has <b>Warning level</b> value less than 4.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[It is recommended practice to always compile the project with Warning Level 4.<br />
	Warning Level 4 option enforces compiler never suppress specific warnings.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<li>Set <b>Warning level</b> option to <b>4</b> for the project.</li>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Enforce Warning Level 4.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="GE00009">
      <Name>Project -&gt; Enable Treat Compiler Warnings As Errors option</Name>
      <Title>Enable Treat Compiler Warnings As Errors option</Title>
      <ClassName>EnforceTreatCompilerWarningsAsErrors</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>General</RuleCategory>
      <RuleModificationDate>4/23/2009</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GE00009</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/EnforceTreatCompilerWarningsAsErrors.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The <b>Treat warnings as errors</b> option is disabled for the project.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[It is recommended practice to always have <b>Treat Compiler Warnings As Errors</b> option enabled.<br />
	Treating warnings as errors is a simple way to spot many potential problems and bugs in the source code.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<li>Enable the <b>Treat warnings as errors</b> option for the project.</li>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Enable Treat Compiler Warnings As Errors option.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="GE00008">
      <Name>Source File -&gt; Should be pascal cased</Name>
      <Title>Source file name should be pascal cased</Title>
      <ClassName>SourceFileNameShouldBePascalCased</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>File</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>General</RuleCategory>
      <RuleModificationDate>4/2/2009</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GE00008</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SourceFileNameShouldBePascalCased.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>FileNameCase</Name>
          <Value>Pascal</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of source file is not pascal cased.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This rule is created to ensure that the name of the file is cased correctly.<br />
	According to the coding guidelines names of source files should be Pascal Cased and named after the main type they contain.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<li>Rename file to the specified name.</li>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li>
			<i>FileNameCase</i> - Set desired value of the case to check. Possible 
			values: <b>Camel</b>, <b>Pascal</b> (set by default), <b>Upper</b>.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Source file name should be pascal cased.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="GE00007">
      <Name>Source File -&gt; Should match public type name</Name>
      <Title>Source file name should match public type name</Title>
      <ClassName>SourceFileNameShouldMatchPublicTypeName</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>File</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>General</RuleCategory>
      <RuleModificationDate>12/14/2010</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GE00007</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SourceFileNameShouldMatchPublicTypeName.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Source file contains public type and the name of the file does not match the name of the type.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This rule is created to ensure that the name of the file is the same as the name of the public type declared in this file.<br />
	According to the coding guidelines names of source files should be Pascal Cased and named after the main type they contain.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<li>Rename file to the specified name.</li>
    <li>Rename type and its references to the specified name.</li>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Source file name should match public type name.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="GE00006">
      <Name>Source File -&gt; Should contain only one public type</Name>
      <Title>Source file should contain only one public type</Title>
      <ClassName>SourceFileShouldContainOnlyOnePublicType</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>File</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>General</RuleCategory>
      <RuleModificationDate>12/14/2010</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GE00006</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SourceFileShouldContainOnlyOnePublicType.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Source file contains more than one public type.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the coding guidelines each source file should contain one public type definition only. This rule is created to ensure that.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<li>Move another public type to the separate souce file.</li>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Source file should contain only one public type.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="GE00001">
      <Name>VB.NET Project -&gt; Enforce Option Compare</Name>
      <Title>Enforce Option Compare</Title>
      <ClassName>EnforceOptionCompare</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>General</RuleCategory>
      <RuleModificationDate>5/10/2007</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GE00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/EnforceOptionCompare.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>OptionUsage</Name>
          <Value>Binary</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The <b>Option Compare</b> statement does not specified explicitly.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The <b>Option Compare</b> statement declares the default comparison method to use when 
	comparing string data. The <b>Option Compare</b> statement specifies the string 
	comparison method (<b>Binary</b> or <b>Text</b>) for a class, module or 
	structure. If an <b>Option Compare</b> statement is not included, the default text 
	comparison method is <b>Binary</b>.<br />
	<br />
	According to the coding guidelines and best practices for projects and 
	solutions, the <b>Option Compare</b> statement should be explicitly specified.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<li>Set compiler option and VS IDE default <b>Option Compare</b></li>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li>
			<i>OptionUsage</i> - Set desired value for this compiler option. Possible 
			values: <b>Binary</b> (set by default), <b>Text</b>.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Enforce Option Compare.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="GE00002">
      <Name>VB.NET Project -&gt; Enforce Option Explicit</Name>
      <Title>Enforce Option Explicit</Title>
      <ClassName>EnforceOptionExplicit</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>General</RuleCategory>
      <RuleModificationDate>5/10/2007</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GE00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/EnforceOptionExplicit.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>OptionUsage</Name>
          <Value>On</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The <b>Option Explicit</b> statement does not specified explicitly.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The <b>Option Explicit</b> statement forces explicit declaration of all variables in a file.
	When <b>Option Explicit</b> appears in a file, you must explicitly declare all variables using the
	<b>Dim</b> or <b>ReDim</b> statements. If you attempt to use an undeclared variable name, an
	error occurs at compile time.<br /><br />
	According to the coding guidelines and best practices for projects and solutions,
	the <b>Option Explicit On</b> statement should be explicitly specified. It will help to avoid incorrectly
	typing the name of an existing variable or to avoid confusion in code where the scope of the
	variable is not clear.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<LI>Set compiler option and VS IDE default <b>Option Explicit</b></LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Enforce Option Explicit.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="GE00003">
      <Name>VB.NET Project -&gt; Enforce Option Strict</Name>
      <Title>Enforce Option Strict</Title>
      <ClassName>EnforceOptionStrict</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Project</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>General</RuleCategory>
      <RuleModificationDate>5/10/2007</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GE00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/EnforceOptionStrict.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>OptionUsage</Name>
          <Value>On</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The <b>Option Strict</b> statement does not specified explicitly.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Visual Basic allows conversions of many data types to other data types. Data loss can occur when
	the value of one data type is converted to a data type with less precision or smaller capacity.
	A run-time error occurs if such a narrowing conversion fails. <b>Option Strict</b> ensures compile-time
	notification of these narrowing conversions so they can be avoided.<br /><br />
	In addition to disallowing implicit narrowing conversions, <b>Option Strict</b> generates an error for
	late binding. An object is late bound when it is assigned to a variable that is declared to be
	of type <b>Object</b>.<br /><br />
	According to the coding guidelines and best practices for projects and solutions,
	the <B>Option Strict On</B> statement should be explicitly specified, because <b>Option Strict On</b>
	provides strong typing, prevents unintended type conversions with data loss, disallows late
	binding, and improves performance.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
		<UL>
			<LI>Set compiler option and VS IDE default <b>Option Strict</b></li>
		</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Enforce Option Strict.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="GE00004">
      <Name>Visual Studio -&gt; Windows Forms Designer -&gt; Set options correctly</Name>
      <Title>Set all Windows Forms Designer settings correctly</Title>
      <ClassName>SetIDEDesignerSettings</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>VS</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>General</RuleCategory>
      <RuleModificationDate>9/24/2008</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GE00004</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SetIDEDesignerSettings.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>GridWidth</Name>
          <Value>2</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>GridHeight</Name>
          <Value>2</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ShowGrid</Name>
          <Value>True</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>SnapToGrid</Name>
          <Value>True</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Windows Forms Designer settings are incorrect.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[You can set preferences for all the forms and projects you work with in the Windows Forms Designer.<br /><br />
	<B>Grid Size</B> - Sets the spacing, in pixels, between horizontal and vertical gridlines on the
	designer. The default size is 8, 8.<br /><br />
	<B>Show Grid</B> - Specifies whether designers display the sizing grid. By default,
	the grid is on.<br /><br />
	<B>SnapToGrid</B> - Determines whether designers will snap objects and controls to the grid.
	In other words, the resizing and movement of elements on the designer are constrained to the
	GridSize increment when this feature is turned on. Having SnapToGrid turned on makes it easier
	to line up the various aspects of the user interface precisely, but limits the freedom with
	which one can place controls. By default, SnapToGrid is turned on.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Specify Windows Forms Designer settings for the project.]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Set all Windows Forms Designer settings correctly.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="GE00005">
      <Name>Type, Member -&gt; Should have XML comments</Name>
      <Title>Externally visible types and members should have XML comments</Title>
      <ClassName>TypesAndMembersShouldHaveXmlComments</ClassName>
      <Scope>Public, Protected</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface, Delegate, Struct, Enumeration, Module, Type, Method, Operator, Event, Property, Indexer, EnumerationItem, Constant, Field, Member</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>General</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GE00005</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/TypesAndMembersShouldHaveXmlComments.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>EnforceCheckingAllProjects</Name>
          <Value>False</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>IntelliCommentTemplate</Name>
          <Value>&lt;#@ template language="C#" #&gt;
&lt;#
	CodeElement codeElement = Context.CurrentCodeElement;
#&gt;
/// &lt;summary&gt;
/// &lt;#= codeElement.XmlComment.SummaryTagText #&gt;	
/// &lt;/summary&gt;
&lt;#
	if(codeElement.HasTypeParameters) 
	{
		foreach(TypeParameter typeParameter in codeElement.TypeParameters) {
#&gt;
/// &lt;typeparam name="&lt;#= typeParameter.Name #&gt;"&gt;&lt;#= typeParameter.XmlComment.TypeParamTagText #&gt;&lt;/typeparam&gt;
&lt;#
		}
	}
	
	if(codeElement.HasParameters) 
	{
		foreach(Parameter parameter in codeElement.Parameters) {
#&gt;
/// &lt;param name="&lt;#= parameter.Name #&gt;"&gt;&lt;#= parameter.XmlComment.ParaTagText #&gt;&lt;/param&gt;
&lt;#
		}
	}
	
	if(codeElement.HasReturnType) {
#&gt;
/// &lt;returns&gt;&lt;#= codeElement.XmlComment.ReturnsTagText #&gt;&lt;/returns&gt;
&lt;#			
	}
	
	if(codeElement.IsProperty) {
#&gt;
/// &lt;value&gt;&lt;#= codeElement.XmlComment.ValueTagText #&gt;&lt;/value&gt;
&lt;#
	}	
	
	if(codeElement.IsMember) {
#&gt;
/// &lt;remarks&gt;&lt;/remarks&gt;
&lt;#
	}	
#&gt;
</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>StubTemplate</Name>
          <Value>&lt;#@ template language="C#" #&gt;
&lt;#
	CodeElement codeElement = Context.CurrentCodeElement;
#&gt;
/// &lt;summary&gt;
/// 
/// &lt;/summary&gt;
&lt;#
	if(codeElement.HasTypeParameters) 
	{
		foreach(TypeParameter typeParameter in codeElement.TypeParameters) {
#&gt;
/// &lt;typeparam name="&lt;#= typeParameter.Name #&gt;"&gt;&lt;/typeparam&gt;
&lt;#
		}
	}
	
	if(codeElement.HasParameters) 
	{
		foreach(Parameter parameter in codeElement.Parameters) {
#&gt;
/// &lt;param name="&lt;#= parameter.Name #&gt;"&gt;&lt;/param&gt;
&lt;#
		}
	}
	
	if(codeElement.HasReturnType) {
#&gt;
/// &lt;returns&gt;&lt;/returns&gt;
&lt;#			
	}
	
	if(codeElement.IsProperty) {
#&gt;
/// &lt;value&gt;&lt;/value&gt;
&lt;#
	}	
	
	if(codeElement.IsMember) {
#&gt;
/// &lt;remarks&gt;&lt;/remarks&gt;
&lt;#
	}	
#&gt;
</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Externally visible type or member does not have XML comments.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[XML comments should be used to document all public types and their public members in class libraries, 
	Windows Forms control projects, and ASP.NET Web control projects.<br />
	<br />
	XML comments have the following advantages:<br />
	<ul>
		<li>XML documentation file can be easily generated, if enabled the <b>XML Documentation File</b> option 
		on the <b>Build</b> page of the <b>Project Properties</b> dialog box. By deploying this file in the 
		same directory as the DLL executable, developers using your types or controls can read your comments 
		in Visual Studio .NET's Object Browser.</li>
		<li>The NDoc can be used to create the technical documentation of the class library or control.</li>
	</ul>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <li>Add XML Comment with IntelliComment content to the type.</li>
		<li>Add XML Comment stub to the type or member.</li>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>EnforceCheckingAllProjects</i> - Ignore 'XML Documentation' flag. Enforce the 
			XML Comments rule on the entire project regardless of the 'XML documentation file' 
			option setting.</li>
		<li><i>IntelliCommentTemplate</i> - T4 template for XML Comment with IntelliComment content. 
		IntelliComments feature is based on the GhostDoc algorithm.</li>
		<li><i>StubTemplate</i> - XML Comment Stub Template. T4 template for XML Comment stub.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Externally visible types and members should have XML comments.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show public method with XML comment.
	<br />
	<p>[Visual Basic]</p>
	<pre class="code">

<span class=code-changed>''' &lt;summary&gt;
''' Retrieves a substring from this instance.
''' &lt;/summary&gt;
''' &lt;param name="startIndex"&gt;The index of the start of the substring.&lt;/param&gt;
''' &lt;param name="length"&gt;The number of characters in the substring.&lt;/param&gt;
''' &lt;returns&gt;A substring that starts at a specified character position and has a specified length.&lt;/returns&gt;</span>
Public Function Substring (startIndex As Integer, length As Integer) As String

    ...

End Function

	</pre>
	<p>[C#]</p>
	<pre class="code">

<span class=code-changed>/// &lt;summary&gt;
/// Retrieves a substring from this instance.
/// &lt;/summary&gt;
/// &lt;param name="startIndex"&gt;The index of the start of the substring.&lt;/param&gt;
/// &lt;param name="length"&gt;The number of characters in the substring.&lt;/param&gt;
/// &lt;returns&gt;A substring that starts at a specified character position and has a specified length.&lt;/returns&gt;</span>
public string Substring(int startIndex, int length)
{ 

    ...

}

	</pre>
    <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="GL00001">
      <Name>Expression -&gt; Specify CultureInfo</Name>
      <Title>Specify CultureInfo</Title>
      <ClassName>SpecifyCultureInfo</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Expression</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Globalization</RuleCategory>
      <RuleModificationDate>1/6/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Globalization, CA1304:SpecifyCultureInfo;CA1305:SpecifyIFormatProvider</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GL00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SpecifyCultureInfo.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>TypeName</Name>
          <Value>System.Globalization.CultureInfo</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[There is an overload of the method with <b>System.Globalization.CultureInfo</b> or <b>System.IFormatProvider</b> parameter exists, but not called.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, the culture-specific information should be explicitly specified if it is possible.<br />
  <br />
  If <b>System.Globalization.CultureInfo</b> or <b>System.IFormatProvider</b> parameter is not specified explicitly, then methods 
  of .NET Framework classes use default culture and formatting and, therefore, may produce results that will be 
  incorrect for your scenarios.<br />
  <br />
  The following methods are ignored by the rule:
  <ul>
		<li><b>System.Activator.CreateInstance</b></li>
		<li><b>System.Resources.ResourceManager.GetObject</b></li>
		<li><b>System.Resources.ResourceManager.GetString</b></li>
  </ul>
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Specify CultureInfo', CheckId <b>CA1304</b></li>
		<li>'Specify IFormatProvider', CheckId <b>CA1305</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<LI>Call appropriate overload of a method and pass <b>System.Globalization.CultureInfo.CurrentCulture</b> as an argument.</LI>
				<LI>Call appropriate overload of a method and pass <b>System.Globalization.CultureInfo.InvariantCulture</b> as an argument.</LI>
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>TypeName</i> - <b>System.Globalization.CultureInfo</b> or <b>System.IFormatProvider</b>.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Specify CultureInfo.</li>
    <li>Specify IFormatProvider.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

  Imports System
  
  Public Class GlobalizationTest
  
    Public Sub ProcessInformation(number As Double, stringDate As String)
    
      Dim processDate As Date = Date.Parse(stringDate).AddDays(36)
      number += 123.45

      Console.WriteLine("Number: {0}", number.ToString())
      Console.WriteLine("Date: {0}", processDate.ToString())
    
    End Sub
  
  End Class


<SPAN class="code-selected">' This is the correct implementation</SPAN>

  Imports System
  <SPAN class="code-changed">Imports System.Globalization</SPAN>
  
  Public Class GlobalizationTest
  
    Public Sub ProcessInformation(number As Double, stringDate As String)
    
      Dim processDate As Date = Date.Parse(stringDate<SPAN class="code-changed">, CultureInfo.CurrentCulture</SPAN>).AddDays(36)
      number += 123.45

      Console.WriteLine("Number: {0}", number.ToString(<SPAN class="code-changed">CultureInfo.CurrentCulture</SPAN>))
      Console.WriteLine("Date: {0}", processDate.ToString(<SPAN class="code-changed">CultureInfo.CurrentCulture</SPAN>))
    
    End Sub
  
  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

  using System;
  
  public class GlobalizationTest
  {
    public void ProcessInformation(double number, string date)
    {
      DateTime processDate = DateTime.Parse(date).AddDays(36);
      number += 123.45;

      Console.WriteLine("Number: {0}", number.ToString());
      Console.WriteLine("Date: {0}", processDate.ToString());
    }
  }


<SPAN class="code-selected">// This is the correct implementation</SPAN>

  using System;
  <SPAN class="code-changed">using System.Globalization;</SPAN>
  
  public class GlobalizationTest
  {
    public void ProcessInformation(double number, string date)
    {
      DateTime processDate = DateTime.Parse(date<SPAN class="code-changed">, CultureInfo.CurrentCulture</SPAN>).AddDays(36);
      number += 123.45;

      Console.WriteLine("Number: {0}", number.ToString(<SPAN class="code-changed">CultureInfo.CurrentCulture</SPAN>));
      Console.WriteLine("Date: {0}", processDate.ToString(<SPAN class="code-changed">CultureInfo.CurrentCulture</SPAN>));
    }
  }

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="GL00001">
      <Name>Expression -&gt; Specify IFormatProvider</Name>
      <Title>Specify IFormatProvider</Title>
      <ClassName>SpecifyCultureInfo</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Expression</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Globalization</RuleCategory>
      <RuleModificationDate>1/6/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Globalization, CA1304:SpecifyCultureInfo;CA1305:SpecifyIFormatProvider</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GL00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SpecifyCultureInfo.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>TypeName</Name>
          <Value>System.IFormatProvider</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[There is an overload of the method with <b>System.Globalization.CultureInfo</b> or <b>System.IFormatProvider</b> parameter exists, but not called.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, the culture-specific information should be explicitly specified if it is possible.<br />
  <br />
  If <b>System.Globalization.CultureInfo</b> or <b>System.IFormatProvider</b> parameter is not specified explicitly, then methods 
  of .NET Framework classes use default culture and formatting and, therefore, may produce results that will be 
  incorrect for your scenarios.<br />
  <br />
  The following methods are ignored by the rule:
  <ul>
		<li><b>System.Activator.CreateInstance</b></li>
		<li><b>System.Resources.ResourceManager.GetObject</b></li>
		<li><b>System.Resources.ResourceManager.GetString</b></li>
  </ul>
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Specify CultureInfo', CheckId <b>CA1304</b></li>
		<li>'Specify IFormatProvider', CheckId <b>CA1305</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<LI>Call appropriate overload of a method and pass <b>System.Globalization.CultureInfo.CurrentCulture</b> as an argument.</LI>
				<LI>Call appropriate overload of a method and pass <b>System.Globalization.CultureInfo.InvariantCulture</b> as an argument.</LI>
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>TypeName</i> - <b>System.Globalization.CultureInfo</b> or <b>System.IFormatProvider</b>.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Specify CultureInfo.</li>
    <li>Specify IFormatProvider.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

  Imports System
  
  Public Class GlobalizationTest
  
    Public Sub ProcessInformation(number As Double, stringDate As String)
    
      Dim processDate As Date = Date.Parse(stringDate).AddDays(36)
      number += 123.45

      Console.WriteLine("Number: {0}", number.ToString())
      Console.WriteLine("Date: {0}", processDate.ToString())
    
    End Sub
  
  End Class


<SPAN class="code-selected">' This is the correct implementation</SPAN>

  Imports System
  <SPAN class="code-changed">Imports System.Globalization</SPAN>
  
  Public Class GlobalizationTest
  
    Public Sub ProcessInformation(number As Double, stringDate As String)
    
      Dim processDate As Date = Date.Parse(stringDate<SPAN class="code-changed">, CultureInfo.CurrentCulture</SPAN>).AddDays(36)
      number += 123.45

      Console.WriteLine("Number: {0}", number.ToString(<SPAN class="code-changed">CultureInfo.CurrentCulture</SPAN>))
      Console.WriteLine("Date: {0}", processDate.ToString(<SPAN class="code-changed">CultureInfo.CurrentCulture</SPAN>))
    
    End Sub
  
  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

  using System;
  
  public class GlobalizationTest
  {
    public void ProcessInformation(double number, string date)
    {
      DateTime processDate = DateTime.Parse(date).AddDays(36);
      number += 123.45;

      Console.WriteLine("Number: {0}", number.ToString());
      Console.WriteLine("Date: {0}", processDate.ToString());
    }
  }


<SPAN class="code-selected">// This is the correct implementation</SPAN>

  using System;
  <SPAN class="code-changed">using System.Globalization;</SPAN>
  
  public class GlobalizationTest
  {
    public void ProcessInformation(double number, string date)
    {
      DateTime processDate = DateTime.Parse(date<SPAN class="code-changed">, CultureInfo.CurrentCulture</SPAN>).AddDays(36);
      number += 123.45;

      Console.WriteLine("Number: {0}", number.ToString(<SPAN class="code-changed">CultureInfo.CurrentCulture</SPAN>));
      Console.WriteLine("Date: {0}", processDate.ToString(<SPAN class="code-changed">CultureInfo.CurrentCulture</SPAN>));
    }
  }

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="GL00002">
      <Name>Expression -&gt; Specify StringComparison</Name>
      <Title>Specify StringComparison</Title>
      <ClassName>SpecifyStringComparison</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Expression</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Globalization</RuleCategory>
      <RuleModificationDate>12/8/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Globalization, CA1307:SpecifyStringComparison</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=GL00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SpecifyStringComparison.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[There is an overload of a method with <b>System.StringComparison</b> parameter exists, but it does not used.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, <b>System.StringComparison</b> parameter should be explicitly specified if it is possible.<br />
  <br />
  The following <b>System.String</b> methods provide an overload with a <b>System.StringComparison</b> parameter:
  <ul>
		<li><b>System.String.Compare</b></li>
		<li><b>System.String.EndsWith</b></li>
		<li><b>System.String.Equals</b></li>
		<li><b>System.String.IndexOf</b></li>
		<li><b>System.String.LastIndexOf</b></li>
		<li><b>System.String.StartsWith</b></li>
  </ul>
  You should always use an overload that accepts a <b>System.StringComparison</b> enumeration value as a parameter, if you use one of thee methods.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Specify StringComparison', CheckId <b>CA1307</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<LI>Call appropriate overload of a method and pass <b>System.StringComparison.CurrentCulture</b> as an argument.</LI>
				<LI>Call appropriate overload of a method and pass <b>System.StringComparison.InvariantCulture</b> as an argument.</LI>
				<LI>Call appropriate overload of a method and pass <b>System.StringComparison.Ordinal</b> as an argument.</LI>
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Specify StringComparison.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

  Imports System
  
  Public Class GlobalizationTest
  
    Public Sub ProcessInformation(stringToCheck As String, correctEnding As String)
    
      If !stringToCheck.EndsWith(correctEnding) Then
        Console.WriteLine("Provided data is incorrect.")
      End If
    
    End Sub
  
  End Class


<SPAN class="code-selected">' This is the correct implementation</SPAN>

  Imports System
  
  Public Class GlobalizationTest
  
    Public Sub ProcessInformation(stringToCheck As String, correctEnding As String)
    
      If !stringToCheck.EndsWith(correctEnding<SPAN class="code-changed">, System.StringComparison.CurrentCulture</SPAN>) Then
        Console.WriteLine("Provided data is incorrect.")
      End If
    
    End Sub
  
  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

  using System;
  
  public class GlobalizationTest
  {
    public void ProcessInformation(string stringToCheck, string correctEnding)
    {
      if (!stringToCheck.EndsWith(correctEnding))
      {
        Console.WriteLine("Provided data is incorrect.");
      }
    }
  }


<SPAN class="code-selected">// This is the correct implementation</SPAN>

  using System;
  
  public class GlobalizationTest
  {
    public void ProcessInformation(string stringToCheck, string correctEnding)
    {
      if (!stringToCheck.EndsWith(correctEnding<SPAN class="code-changed">, System.StringComparison.CurrentCulture</SPAN>))
      {
        Console.WriteLine("Provided data is incorrect.");
      }
    }
  }

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="IN00001">
      <Name>Method -&gt; Avoid Long type arguments</Name>
      <Title>Avoid Long type arguments for VB6 clients</Title>
      <ClassName>AvoidLongTypeArgumentsForVB6Clients</ClassName>
      <Scope>Public</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Struct</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Interoperability</RuleCategory>
      <RuleModificationDate>9/21/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Interoperability, CA1406:AvoidInt64ArgumentsForVB6Clients</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=IN00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidLongTypeArgumentsForVB6Clients.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Type marked as COM visible and declares method that takes a <b>System.Int64</b> argument.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, .NET components that are meant 
  to be exposed to COM clients shouldn't use features that COM-based clients can't see. 
  Or they should provide alternative ways for COM clients to accesss these features.<br />
  <br />
  The class shouldn't expose methods or properties that take or return <b>System.Int64</b> 
  values because they can't be handled by Visual Basic 6 clients.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Avoid int64 arguments for VB6 clients', CheckId <b>CA1406</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Change parameter return type on <b>System.Int32</b>    
    <LI>Change parameter return type on <b>System.Decimal</b>    
    <LI>Add <b>System.Runtime.InteropServices.ComVisibleAttribute</b> attribute to 
    the method and set it to <b>False</b>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid Long type arguments for VB6 clients.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Runtime.InteropServices

&lt;Assembly: ComVisibleAttribute(False)&gt;

Namespace MyInteropLibrary

   &lt;ComVisibleAttribute(True)&gt; _ 
   Public Class MyComClass

      Public Sub SomeMethod(Param1 As Long)
      End Sub

   End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Runtime.InteropServices

&lt;Assembly: ComVisibleAttribute(False)&gt;

Namespace MyInteropLibrary

   &lt;ComVisibleAttribute(True)&gt; _ 
   Public Class MyComClass

      <SPAN class=code-changed>&lt;ComVisibleAttribute(False)&gt; _</SPAN> 
      Public Sub SomeMethod(Param1 As Long)
      End Sub

   End Class

End Namespace


- Or -


Imports System
Imports System.Runtime.InteropServices

&lt;Assembly: ComVisibleAttribute(False)&gt;

Namespace MyInteropLibrary

   &lt;ComVisibleAttribute(True)&gt; _ 
   Public Class MyComClass

      Public Sub SomeMethod(Param1 As <SPAN class=code-changed>System.Int32</SPAN>)
      End Sub

   End Class

End Namespace
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Runtime.InteropServices;

[assembly:ComVisibleAttribute(false)]

namespace MyInteropLibrary
{

   [ComVisibleAttribute(true)]
   public class MyComClass
   {

      public void SomeMethod(long param1)
      {
      }

   }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;
using System.Runtime.InteropServices;

[assembly:ComVisibleAttribute(false)]

namespace MyInteropLibrary
{

   [ComVisibleAttribute(true)]
   public class MyComClass
   {

      <SPAN class=code-changed>[ComVisibleAttribute(false)]</SPAN> 
      public void SomeMethod(long param1)
      {
      }

   }

}


- Or -


using System;
using System.Runtime.InteropServices;

[assembly:ComVisibleAttribute(false)]

namespace MyInteropLibrary
{

   [ComVisibleAttribute(true)]
   public class MyComClass
   {

      public void SomeMethod(<SPAN class=code-changed>System.Int32</SPAN> param1)
      {
      }

   }

}
	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="IN00003">
      <Name>Non-public Field -&gt; Avoid in ComVisible value types</Name>
      <Title>Avoid non-public fields in ComVisible value types</Title>
      <ClassName>AvoidNonpublicFieldsInComVisibleValueTypes</ClassName>
      <Scope>Protected, Internal, ProtectedInternal, Private</Scope>
      <Severity>Warning</Severity>
      <Targets>Field</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Interoperability</RuleCategory>
      <RuleModificationDate>9/21/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Interoperability, CA1413:AvoidNonpublicFieldsInComVisibleValueTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=IN00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidNonpublicFieldsInComVisibleValueTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A <b>Structure</b> (<b>struct</b> in C#) that is specifically marked as visible to COM declares a non-public instance field.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[A non-public instance field, which is declared in the COM visible <b>Structure</b> (<b>struct</b> in C#), is visible to COM clients. 
  Such field may expose sensitive data and cause security risks.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Avoid non-public fields in ComVisible value types', CheckId <b>CA1413</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Change the <b>System.Runtime.InteropServices.ComVisibleAttribute</b> value of
    the struct to <b>False</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid non-public fields in ComVisible value types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Runtime.InteropServices

&lt;Assembly: ComVisibleAttribute(False)&gt;

Namespace EmployeesComLibrary

   &lt;ComVisibleAttribute(True)&gt; _ 
   Public Structure Employee

      Public FirstName As String
      Public LastName As String
      Friend Salary As Decimal ' Violates the rule

   End Structure

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Runtime.InteropServices

&lt;Assembly: ComVisibleAttribute(False)&gt;

Namespace EmployeesComLibrary

   &lt;ComVisibleAttribute(<SPAN class=code-changed>False</SPAN>)&gt; _ 
   Public Structure Employee

      Public FirstName As String
      Public LastName As String
      Friend Salary As Decimal

   End Structure

End Namespace

	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Runtime.InteropServices;

[assembly: ComVisibleAttribute(false)]
namespace EmployeesComLibrary
{

   [ComVisibleAttribute(true)]
   public struct Employee
   {

      public string FirstName;
      public string LastName;
      internal decimal Salary; // Violates the rule

   }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;
using System.Runtime.InteropServices;

[assembly: ComVisibleAttribute(false)]
namespace EmployeesComLibrary
{

   [ComVisibleAttribute(<SPAN class=code-changed>false</SPAN>)]
   public struct Employee
   {

      public string FirstName;
      public string LastName;
      internal decimal Salary;

   }

}
	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="IN00004">
      <Name>Static Method -&gt; Avoid in ComVisible types</Name>
      <Title>Avoid static members in ComVisible types</Title>
      <ClassName>AvoidStaticMembersInComVisibleTypes</ClassName>
      <Scope>Public</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Interoperability</RuleCategory>
      <RuleModificationDate>9/21/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Interoperability, CA1407:AvoidStaticMembersInComVisibleTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=IN00004</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidStaticMembersInComVisibleTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Type that is specifically marked as visible to COM contains a public static method.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[.NET components that are meant to be exposed to COM clients should not use features that COM-based clients cannot see.<br />
  <br />
  COM does not support static methods. Therefore, such methods should not be exposed to COM clients.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Avoid static members in ComVisible types', CheckId <b>CA1407</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Change the <b>System.Runtime.InteropServices.ComVisibleAttribute</b> value 
    of the method to <b>False</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid static members in ComVisible types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Runtime.InteropServices

&lt;Assembly: ComVisibleAttribute(False)&gt;

Namespace EmployeesComLibrary

   &lt;ComVisibleAttribute(True)&gt; _ 
   Public Class Employee

      Public FirstName As String
      Public LastName As String
      
      Public Shared Sub Print() ' Violates the rule
      
        ...
        
      End Sub

   End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Runtime.InteropServices

&lt;Assembly: ComVisibleAttribute(False)&gt;

Namespace EmployeesComLibrary

   &lt;ComVisibleAttribute(True)&gt; _ 
   Public Class Employee

     Public FirstName As String
     Public LastName As String
      
     <SPAN class=code-changed>&lt;ComVisibleAttribute(False)&gt; _</SPAN>
     Public Shared Sub Print()
      
       ...
        
     End Sub

   End Class

End Namespace

	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Runtime.InteropServices;

[assembly: ComVisibleAttribute(false)]
namespace EmployeesComLibrary
{

   [ComVisibleAttribute(true)]
   public struct Employee
   {

     public string FirstName;
     public string LastName;
      
     public static void Print() // Violates the rule
     {
      
       ...
        
     }
      
   }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;
using System.Runtime.InteropServices;

[assembly: ComVisibleAttribute(false)]
namespace EmployeesComLibrary
{

   [ComVisibleAttribute(true)]
   public struct Employee
   {

     public string FirstName;
     public string LastName;
      
     <SPAN class=code-changed>[ComVisibleAttribute(false)]</SPAN>
     public static void Print() // Violates the rule
     {
      
       ...
        
     }
      
   }

}
	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="IN00002">
      <Name>Class -&gt; Com visible types should be creatable</Name>
      <Title>Com visible types should be creatable</Title>
      <ClassName>ComVisibleTypesShouldBeCreatable</ClassName>
      <Scope>Public</Scope>
      <Severity>Error</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Interoperability</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Interoperability, CA1409:ComVisibleTypesShouldBeCreatable</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=IN00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ComVisibleTypesShouldBeCreatable.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Type marked as COM visible contains a public parameterized constructor but does not contain a public 
  default (parameterless) constructor.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, the class must expose an implicit and 
  explicit parameter-less constructor because COM clients can't access constructors with parameters. 
  (The class might expose a public <b>Initialize</b> method that COM clients can call immediately 
  after instantiation to ensure that the objectis in a valid state before using it.)<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Com visible types should be creatable', CheckId <b>CA1409</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Add a public default constructor</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Com visible types should be creatable.</li>
  </ul>
  <p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="IN00005">
      <Name>PInvoke Method -&gt; Should not be visible</Name>
      <Title>PInvokes should not be visible</Title>
      <ClassName>PInvokesShouldNotBeVisible</ClassName>
      <Scope>Extern</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Interoperability</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Interoperability, CA1401:PInvokesShouldNotBeVisible</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=IN00005</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/PInvokesShouldNotBeVisible.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Externally visible method in a public type has the <b>System.Runtime.InteropServices.DllImportAttribute</b> attribute.<br />
    <br />
    - OR -<br />
    <br />
    Externally visible method in a public type defined using the <b>Declare</b> keyword.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Methods defined using the <b>Declare</b> statement (or marked with the <b>System.Runtime.InteropServices.DllImportAttribute</b> attribute) use
  PInvoke (Platform Invocation Services) to call unmanaged functions that are implemented in a DLL. 
  Therefore, if such method is externally visible, it maight be exploited and cause security vulnerability 
  by allowing access to unmanaged API that could not be used otherwise.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'PInvokes should not be visible', CheckId <b>CA1401</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Change method modifier to <b>Private</b>.</LI>
    <LI>Change method modifier to <b>Internal</b></LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>PInvokes should not be visible.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Runtime.InteropServices

Namespace DiskManagementLibrary

  Public Class NativeDiskAccess

    ...

    ' Violates the rule
    Public Declare Function DeleteFile Lib "kernel32" _
      (ByVal lpFileName As String) As Boolean

  End Class

End Namespace 

<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Runtime.InteropServices

Namespace DiskManagementLibrary

  Public Class NativeDiskAccess

    ...

    <SPAN class=code-changed>Private</SPAN> Declare Function DeleteFile Lib "kernel32" _
      (ByVal lpFileName As String) As Boolean

  End Class

End Namespace 

	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Runtime.InteropServices;

namespace DiskManagementLibrary
{

  public class NativeDiskAccess
  {

    ...

    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool DeleteFile(string lpFileName); // Violates the rule

  }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;
using System.Runtime.InteropServices;

namespace DiskManagementLibrary
{

  public class NativeDiskAccess
  {

    ...

    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    <SPAN class=code-changed>private</SPAN> static extern bool DeleteFile(string lpFileName);

  }

}
	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00001">
      <Name>Long Acronym -&gt; Pascal Cased</Name>
      <Title>Long Acronyms should be Pascal cased</Title>
      <ClassName>AcronymsShouldBeCasedCorrectly</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Namespace, Class, Interface, Delegate, Struct, Enumeration, Module, Type, Method, Operator, Event, Property, Indexer, EnumerationItem, Parameter, Constant, Field, Member</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1705:LongAcronymsShouldBePascalCased;CA1706:ShortAcronymsShouldBeUppercase</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AcronymsShouldBeCasedCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>Acronym</Name>
          <Value>Long</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExceptionList</Name>
          <Value>Ok,Id,CJK,Pi,NESW,NWSE</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of an identifier contains an acronym of three or more uppercase 
	letters (long acronym) or a two-letter acronym and the second letter is 
	lowercase (short acronym).]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to naming guidelines short acronyms (two-letter acronyms) should 
	contain all uppercase letters, and long acronyms (three and more letters 
	acronyms) should be Pascal cased.<br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Long acronyms should be pascal-cased', CheckId <b>CA1705</b></li>
		<li>'Short acronyms should be uppercase', CheckId <b>CA1706</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>Acronym</i> - Type of acronym used. Possible values: Short, Long;</li>
		<li><i>ExceptionList</i> - A comma-separated list of the acronyms excluded from analysis.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Long Acronyms should be Pascal cased.</li>
    <li>Short Acronyms should be Upper cased</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as the correct implementation.
	<br />
	<p>[Visual Basic]</p>
	<pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
Imports System.IO
Imports System.Xml

Public Sub StartIo(ByVal IoStream As Stream)
End Sub

Public Sub ProcessHTMLTag(ByVal HTMLTag As String)
End Sub
<br />
<br />
<SPAN class=code-selected>' This is the correct implementation</SPAN>
Imports System.IO
Imports System.Xml

Public Sub <SPAN class=code-changed>StartIO</SPAN>(ByVal <SPAN class=code-changed>ioStream</SPAN> As Stream)
End Sub

Public Sub <SPAN class=code-changed>ProcessHtmlTag</SPAN>(ByVal <SPAN class=code-changed>htmlTag</SPAN> As String)
End Sub
	</pre>
	<p>[C#]</p>
	<pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
using System.IO;
using System.Xml;

public void StartIo(Stream IoStream)
{
}

public void ProcessHTMLTag(string HTMLTag)
{
}
<br />
<br />
<SPAN class=code-selected>// This is the correct implementation</SPAN>
using System.IO;
using System.Xml;

public void <SPAN class=code-changed>StartIO</SPAN>(Stream <SPAN class=code-changed>ioStream</SPAN>)
{
}

public void <SPAN class=code-changed>ProcessHtmlTag</SPAN>(string <SPAN class=code-changed>htmlTag</SPAN> )
{
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00001">
      <Name>Short Acronym -&gt; Upper Cased</Name>
      <Title>Short Acronyms should be Upper cased</Title>
      <ClassName>AcronymsShouldBeCasedCorrectly</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Namespace, Class, Interface, Delegate, Struct, Enumeration, Module, Type, Method, Operator, Event, Property, Indexer, EnumerationItem, Parameter, Constant, Field, Member</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1705:LongAcronymsShouldBePascalCased;CA1706:ShortAcronymsShouldBeUppercase</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AcronymsShouldBeCasedCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>Acronym</Name>
          <Value>Short</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExceptionList</Name>
          <Value>CJK,Pi,NESW,NWSE</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of an identifier contains an acronym of three or more uppercase 
	letters (long acronym) or a two-letter acronym and the second letter is 
	lowercase (short acronym).]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to naming guidelines short acronyms (two-letter acronyms) should 
	contain all uppercase letters, and long acronyms (three and more letters 
	acronyms) should be Pascal cased.<br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Long acronyms should be pascal-cased', CheckId <b>CA1705</b></li>
		<li>'Short acronyms should be uppercase', CheckId <b>CA1706</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>Acronym</i> - Type of acronym used. Possible values: Short, Long;</li>
		<li><i>ExceptionList</i> - A comma-separated list of the acronyms excluded from analysis.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Long Acronyms should be Pascal cased.</li>
    <li>Short Acronyms should be Upper cased</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as the correct implementation.
	<br />
	<p>[Visual Basic]</p>
	<pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
Imports System.IO
Imports System.Xml

Public Sub StartIo(ByVal IoStream As Stream)
End Sub

Public Sub ProcessHTMLTag(ByVal HTMLTag As String)
End Sub
<br />
<br />
<SPAN class=code-selected>' This is the correct implementation</SPAN>
Imports System.IO
Imports System.Xml

Public Sub <SPAN class=code-changed>StartIO</SPAN>(ByVal <SPAN class=code-changed>ioStream</SPAN> As Stream)
End Sub

Public Sub <SPAN class=code-changed>ProcessHtmlTag</SPAN>(ByVal <SPAN class=code-changed>htmlTag</SPAN> As String)
End Sub
	</pre>
	<p>[C#]</p>
	<pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
using System.IO;
using System.Xml;

public void StartIo(Stream IoStream)
{
}

public void ProcessHTMLTag(string HTMLTag)
{
}
<br />
<br />
<SPAN class=code-selected>// This is the correct implementation</SPAN>
using System.IO;
using System.Xml;

public void <SPAN class=code-changed>StartIO</SPAN>(Stream <SPAN class=code-changed>ioStream</SPAN>)
{
}

public void <SPAN class=code-changed>ProcessHtmlTag</SPAN>(string <SPAN class=code-changed>htmlTag</SPAN> )
{
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00002">
      <Name>Only Collection Class -&gt; "Collection" Suffix</Name>
      <Title>Only Collection class name must have "Collection" suffix</Title>
      <ClassName>AvoidCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface, Delegate, Struct, Enumeration, Module, Type</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Collection</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Collections.ICollection, System.Collections.Generic.ICollection`1</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type has incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type or derived type should not end with one of specific reserved suffixes.
	These suffixes can be used only in the name of the type that extends certain base type,
	implement certain interface or derived from such types.
	<br /><br />
	The table below represents base types and interfaces with corresponding reserved suffixes:<br />
	<table border="0" cellpadding="7" cellspacing="0">
	<tr>
		<td><b>Suffix</b></td><td><b>Name of base type or interface</b></td>
	</tr>
	<tr>
		<td>Attribute</td><td>System.Attribute</td>
	</tr>
	<tr>
		<td>Collection</td><td>System.Collections.Generic.ICollection<br />
			System.Collections.ICollection<br />
			System.Collections.IEnumerable<br />
			System.Collections.Queue<br />
			System.Collections.Stack<br />
			System.Data.DataSet<br />
			System.Data.DataTable
		</td>
	</tr>
	<tr>
		<td>Dictionary</td><td>System.Collections.Generic.IDictionary<br />
			System.Collections.IDictionary 
		</td>
	</tr>
	<tr>
		<td>EventArgs</td><td>System.EventArgs</td>
	</tr>
	<tr>
		<td>EventHandler</td><td>An event-handler delegate.</td>
	</tr>
	<tr>
		<td>Exception</td><td>System.Exception</td>
	</tr>
	<tr>
		<td>Permission</td><td>System.Security.IPermission</td>
	</tr>
	<tr>
		<td>Queue</td><td>System.Collections.Queue</td>
	</tr>
	<tr>
		<td>Stack</td><td>System.Collections.Stack</td>
	</tr>
	<tr>
		<td>Stream</td><td>System.IO.Stream</td>
	</tr>
	</table><br />
	The following suffixes are reserved as well: Delegate, Enum, Flags (for an enumeration) and Impl.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename type and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
		<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Only Collection class name must have "Collection" suffix.</li>
    <li>Only Dictionary class name must have "Dictionary" suffix.</li>
    <li>Only Exception class name must have "Exception" suffix</li>
    <li>Only Attribute class name must have "Attribute" suffix</li>
    <li>Only Condition class name must have "Condition" suffix</li>
    <li>Only Queue class name must have "Queue" suffix</li>
    <li>Only Stack class name must have "Stack" suffix</li>
    <li>Only Stream class name must have "Stream" suffix</li>
    <li>Only Permission class name must have "Permission" suffix</li>
    <li>Only EventArgs class name must have "EventArgs" suffix</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class MySampleDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	
	...
	
End Class

- Or -

Public Class MySampleDictionary
	Implements IDictionary
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class MySampleDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample
{
	
	...
	
}

- Or -

public class MySampleDictionary: IDictionary
{
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00002">
      <Name>Only Dictionary Class -&gt; "Dictionary" Suffix</Name>
      <Title>Only Dictionary class name must have "Dictionary" suffix</Title>
      <ClassName>AvoidCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Dictionary</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Collections.IDictionary, System.Collections.Generic.IDictionary`2</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type has incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type or derived type should not end with one of specific reserved suffixes.
	These suffixes can be used only in the name of the type that extends certain base type,
	implement certain interface or derived from such types.
	<br /><br />
	The table below represents base types and interfaces with corresponding reserved suffixes:<br />
	<table border="0" cellpadding="7" cellspacing="0">
	<tr>
		<td><b>Suffix</b></td><td><b>Name of base type or interface</b></td>
	</tr>
	<tr>
		<td>Attribute</td><td>System.Attribute</td>
	</tr>
	<tr>
		<td>Collection</td><td>System.Collections.Generic.ICollection<br />
			System.Collections.ICollection<br />
			System.Collections.IEnumerable<br />
			System.Collections.Queue<br />
			System.Collections.Stack<br />
			System.Data.DataSet<br />
			System.Data.DataTable
		</td>
	</tr>
	<tr>
		<td>Dictionary</td><td>System.Collections.Generic.IDictionary<br />
			System.Collections.IDictionary 
		</td>
	</tr>
	<tr>
		<td>EventArgs</td><td>System.EventArgs</td>
	</tr>
	<tr>
		<td>EventHandler</td><td>An event-handler delegate.</td>
	</tr>
	<tr>
		<td>Exception</td><td>System.Exception</td>
	</tr>
	<tr>
		<td>Permission</td><td>System.Security.IPermission</td>
	</tr>
	<tr>
		<td>Queue</td><td>System.Collections.Queue</td>
	</tr>
	<tr>
		<td>Stack</td><td>System.Collections.Stack</td>
	</tr>
	<tr>
		<td>Stream</td><td>System.IO.Stream</td>
	</tr>
	</table><br />
	The following suffixes are reserved as well: Delegate, Enum, Flags (for an enumeration) and Impl.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename type and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
		<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Only Collection class name must have "Collection" suffix.</li>
    <li>Only Dictionary class name must have "Dictionary" suffix.</li>
    <li>Only Exception class name must have "Exception" suffix</li>
    <li>Only Attribute class name must have "Attribute" suffix</li>
    <li>Only Condition class name must have "Condition" suffix</li>
    <li>Only Queue class name must have "Queue" suffix</li>
    <li>Only Stack class name must have "Stack" suffix</li>
    <li>Only Stream class name must have "Stream" suffix</li>
    <li>Only Permission class name must have "Permission" suffix</li>
    <li>Only EventArgs class name must have "EventArgs" suffix</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class MySampleDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	
	...
	
End Class

- Or -

Public Class MySampleDictionary
	Implements IDictionary
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class MySampleDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample
{
	
	...
	
}

- Or -

public class MySampleDictionary: IDictionary
{
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00002">
      <Name>Only Exception Class -&gt; "Exception" Suffix</Name>
      <Title>Only Exception class name must have "Exception" suffix</Title>
      <ClassName>AvoidCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Exception</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Exception</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type has incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type or derived type should not end with one of specific reserved suffixes.
	These suffixes can be used only in the name of the type that extends certain base type,
	implement certain interface or derived from such types.
	<br /><br />
	The table below represents base types and interfaces with corresponding reserved suffixes:<br />
	<table border="0" cellpadding="7" cellspacing="0">
	<tr>
		<td><b>Suffix</b></td><td><b>Name of base type or interface</b></td>
	</tr>
	<tr>
		<td>Attribute</td><td>System.Attribute</td>
	</tr>
	<tr>
		<td>Collection</td><td>System.Collections.Generic.ICollection<br />
			System.Collections.ICollection<br />
			System.Collections.IEnumerable<br />
			System.Collections.Queue<br />
			System.Collections.Stack<br />
			System.Data.DataSet<br />
			System.Data.DataTable
		</td>
	</tr>
	<tr>
		<td>Dictionary</td><td>System.Collections.Generic.IDictionary<br />
			System.Collections.IDictionary 
		</td>
	</tr>
	<tr>
		<td>EventArgs</td><td>System.EventArgs</td>
	</tr>
	<tr>
		<td>EventHandler</td><td>An event-handler delegate.</td>
	</tr>
	<tr>
		<td>Exception</td><td>System.Exception</td>
	</tr>
	<tr>
		<td>Permission</td><td>System.Security.IPermission</td>
	</tr>
	<tr>
		<td>Queue</td><td>System.Collections.Queue</td>
	</tr>
	<tr>
		<td>Stack</td><td>System.Collections.Stack</td>
	</tr>
	<tr>
		<td>Stream</td><td>System.IO.Stream</td>
	</tr>
	</table><br />
	The following suffixes are reserved as well: Delegate, Enum, Flags (for an enumeration) and Impl.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename type and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
		<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Only Collection class name must have "Collection" suffix.</li>
    <li>Only Dictionary class name must have "Dictionary" suffix.</li>
    <li>Only Exception class name must have "Exception" suffix</li>
    <li>Only Attribute class name must have "Attribute" suffix</li>
    <li>Only Condition class name must have "Condition" suffix</li>
    <li>Only Queue class name must have "Queue" suffix</li>
    <li>Only Stack class name must have "Stack" suffix</li>
    <li>Only Stream class name must have "Stream" suffix</li>
    <li>Only Permission class name must have "Permission" suffix</li>
    <li>Only EventArgs class name must have "EventArgs" suffix</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class MySampleDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	
	...
	
End Class

- Or -

Public Class MySampleDictionary
	Implements IDictionary
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class MySampleDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample
{
	
	...
	
}

- Or -

public class MySampleDictionary: IDictionary
{
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00002">
      <Name>Only Attribute Class -&gt; "Attribute" Suffix</Name>
      <Title>Only Attribute class name must have "Attribute" suffix</Title>
      <ClassName>AvoidCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Attribute</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Attribute</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type has incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type or derived type should not end with one of specific reserved suffixes.
	These suffixes can be used only in the name of the type that extends certain base type,
	implement certain interface or derived from such types.
	<br /><br />
	The table below represents base types and interfaces with corresponding reserved suffixes:<br />
	<table border="0" cellpadding="7" cellspacing="0">
	<tr>
		<td><b>Suffix</b></td><td><b>Name of base type or interface</b></td>
	</tr>
	<tr>
		<td>Attribute</td><td>System.Attribute</td>
	</tr>
	<tr>
		<td>Collection</td><td>System.Collections.Generic.ICollection<br />
			System.Collections.ICollection<br />
			System.Collections.IEnumerable<br />
			System.Collections.Queue<br />
			System.Collections.Stack<br />
			System.Data.DataSet<br />
			System.Data.DataTable
		</td>
	</tr>
	<tr>
		<td>Dictionary</td><td>System.Collections.Generic.IDictionary<br />
			System.Collections.IDictionary 
		</td>
	</tr>
	<tr>
		<td>EventArgs</td><td>System.EventArgs</td>
	</tr>
	<tr>
		<td>EventHandler</td><td>An event-handler delegate.</td>
	</tr>
	<tr>
		<td>Exception</td><td>System.Exception</td>
	</tr>
	<tr>
		<td>Permission</td><td>System.Security.IPermission</td>
	</tr>
	<tr>
		<td>Queue</td><td>System.Collections.Queue</td>
	</tr>
	<tr>
		<td>Stack</td><td>System.Collections.Stack</td>
	</tr>
	<tr>
		<td>Stream</td><td>System.IO.Stream</td>
	</tr>
	</table><br />
	The following suffixes are reserved as well: Delegate, Enum, Flags (for an enumeration) and Impl.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename type and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
		<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Only Collection class name must have "Collection" suffix.</li>
    <li>Only Dictionary class name must have "Dictionary" suffix.</li>
    <li>Only Exception class name must have "Exception" suffix</li>
    <li>Only Attribute class name must have "Attribute" suffix</li>
    <li>Only Condition class name must have "Condition" suffix</li>
    <li>Only Queue class name must have "Queue" suffix</li>
    <li>Only Stack class name must have "Stack" suffix</li>
    <li>Only Stream class name must have "Stream" suffix</li>
    <li>Only Permission class name must have "Permission" suffix</li>
    <li>Only EventArgs class name must have "EventArgs" suffix</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class MySampleDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	
	...
	
End Class

- Or -

Public Class MySampleDictionary
	Implements IDictionary
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class MySampleDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample
{
	
	...
	
}

- Or -

public class MySampleDictionary: IDictionary
{
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00002">
      <Name>Only Condition Class -&gt; "Condition" Suffix</Name>
      <Title>Only Condition class name must have "Condition" suffix</Title>
      <ClassName>AvoidCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Condition</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Security.Policy.IMembershipCondition</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type has incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type or derived type should not end with one of specific reserved suffixes.
	These suffixes can be used only in the name of the type that extends certain base type,
	implement certain interface or derived from such types.
	<br /><br />
	The table below represents base types and interfaces with corresponding reserved suffixes:<br />
	<table border="0" cellpadding="7" cellspacing="0">
	<tr>
		<td><b>Suffix</b></td><td><b>Name of base type or interface</b></td>
	</tr>
	<tr>
		<td>Attribute</td><td>System.Attribute</td>
	</tr>
	<tr>
		<td>Collection</td><td>System.Collections.Generic.ICollection<br />
			System.Collections.ICollection<br />
			System.Collections.IEnumerable<br />
			System.Collections.Queue<br />
			System.Collections.Stack<br />
			System.Data.DataSet<br />
			System.Data.DataTable
		</td>
	</tr>
	<tr>
		<td>Dictionary</td><td>System.Collections.Generic.IDictionary<br />
			System.Collections.IDictionary 
		</td>
	</tr>
	<tr>
		<td>EventArgs</td><td>System.EventArgs</td>
	</tr>
	<tr>
		<td>EventHandler</td><td>An event-handler delegate.</td>
	</tr>
	<tr>
		<td>Exception</td><td>System.Exception</td>
	</tr>
	<tr>
		<td>Permission</td><td>System.Security.IPermission</td>
	</tr>
	<tr>
		<td>Queue</td><td>System.Collections.Queue</td>
	</tr>
	<tr>
		<td>Stack</td><td>System.Collections.Stack</td>
	</tr>
	<tr>
		<td>Stream</td><td>System.IO.Stream</td>
	</tr>
	</table><br />
	The following suffixes are reserved as well: Delegate, Enum, Flags (for an enumeration) and Impl.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename type and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
		<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Only Collection class name must have "Collection" suffix.</li>
    <li>Only Dictionary class name must have "Dictionary" suffix.</li>
    <li>Only Exception class name must have "Exception" suffix</li>
    <li>Only Attribute class name must have "Attribute" suffix</li>
    <li>Only Condition class name must have "Condition" suffix</li>
    <li>Only Queue class name must have "Queue" suffix</li>
    <li>Only Stack class name must have "Stack" suffix</li>
    <li>Only Stream class name must have "Stream" suffix</li>
    <li>Only Permission class name must have "Permission" suffix</li>
    <li>Only EventArgs class name must have "EventArgs" suffix</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class MySampleDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	
	...
	
End Class

- Or -

Public Class MySampleDictionary
	Implements IDictionary
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class MySampleDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample
{
	
	...
	
}

- Or -

public class MySampleDictionary: IDictionary
{
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00002">
      <Name>Only Queue Class -&gt; "Queue" Suffix</Name>
      <Title>Only Queue class name must have "Queue" suffix</Title>
      <ClassName>AvoidCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Queue</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Collections.Queue, System.Collections.Generic.Queue`1</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type has incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type or derived type should not end with one of specific reserved suffixes.
	These suffixes can be used only in the name of the type that extends certain base type,
	implement certain interface or derived from such types.
	<br /><br />
	The table below represents base types and interfaces with corresponding reserved suffixes:<br />
	<table border="0" cellpadding="7" cellspacing="0">
	<tr>
		<td><b>Suffix</b></td><td><b>Name of base type or interface</b></td>
	</tr>
	<tr>
		<td>Attribute</td><td>System.Attribute</td>
	</tr>
	<tr>
		<td>Collection</td><td>System.Collections.Generic.ICollection<br />
			System.Collections.ICollection<br />
			System.Collections.IEnumerable<br />
			System.Collections.Queue<br />
			System.Collections.Stack<br />
			System.Data.DataSet<br />
			System.Data.DataTable
		</td>
	</tr>
	<tr>
		<td>Dictionary</td><td>System.Collections.Generic.IDictionary<br />
			System.Collections.IDictionary 
		</td>
	</tr>
	<tr>
		<td>EventArgs</td><td>System.EventArgs</td>
	</tr>
	<tr>
		<td>EventHandler</td><td>An event-handler delegate.</td>
	</tr>
	<tr>
		<td>Exception</td><td>System.Exception</td>
	</tr>
	<tr>
		<td>Permission</td><td>System.Security.IPermission</td>
	</tr>
	<tr>
		<td>Queue</td><td>System.Collections.Queue</td>
	</tr>
	<tr>
		<td>Stack</td><td>System.Collections.Stack</td>
	</tr>
	<tr>
		<td>Stream</td><td>System.IO.Stream</td>
	</tr>
	</table><br />
	The following suffixes are reserved as well: Delegate, Enum, Flags (for an enumeration) and Impl.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename type and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
		<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Only Collection class name must have "Collection" suffix.</li>
    <li>Only Dictionary class name must have "Dictionary" suffix.</li>
    <li>Only Exception class name must have "Exception" suffix</li>
    <li>Only Attribute class name must have "Attribute" suffix</li>
    <li>Only Condition class name must have "Condition" suffix</li>
    <li>Only Queue class name must have "Queue" suffix</li>
    <li>Only Stack class name must have "Stack" suffix</li>
    <li>Only Stream class name must have "Stream" suffix</li>
    <li>Only Permission class name must have "Permission" suffix</li>
    <li>Only EventArgs class name must have "EventArgs" suffix</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class MySampleDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	
	...
	
End Class

- Or -

Public Class MySampleDictionary
	Implements IDictionary
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class MySampleDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample
{
	
	...
	
}

- Or -

public class MySampleDictionary: IDictionary
{
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00002">
      <Name>Only Stack Class -&gt; "Stack" Suffix</Name>
      <Title>Only Stack class name must have "Stack" suffix</Title>
      <ClassName>AvoidCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Stack</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Collections.Stack, System.Collections.Generic.Stack`1</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type has incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type or derived type should not end with one of specific reserved suffixes.
	These suffixes can be used only in the name of the type that extends certain base type,
	implement certain interface or derived from such types.
	<br /><br />
	The table below represents base types and interfaces with corresponding reserved suffixes:<br />
	<table border="0" cellpadding="7" cellspacing="0">
	<tr>
		<td><b>Suffix</b></td><td><b>Name of base type or interface</b></td>
	</tr>
	<tr>
		<td>Attribute</td><td>System.Attribute</td>
	</tr>
	<tr>
		<td>Collection</td><td>System.Collections.Generic.ICollection<br />
			System.Collections.ICollection<br />
			System.Collections.IEnumerable<br />
			System.Collections.Queue<br />
			System.Collections.Stack<br />
			System.Data.DataSet<br />
			System.Data.DataTable
		</td>
	</tr>
	<tr>
		<td>Dictionary</td><td>System.Collections.Generic.IDictionary<br />
			System.Collections.IDictionary 
		</td>
	</tr>
	<tr>
		<td>EventArgs</td><td>System.EventArgs</td>
	</tr>
	<tr>
		<td>EventHandler</td><td>An event-handler delegate.</td>
	</tr>
	<tr>
		<td>Exception</td><td>System.Exception</td>
	</tr>
	<tr>
		<td>Permission</td><td>System.Security.IPermission</td>
	</tr>
	<tr>
		<td>Queue</td><td>System.Collections.Queue</td>
	</tr>
	<tr>
		<td>Stack</td><td>System.Collections.Stack</td>
	</tr>
	<tr>
		<td>Stream</td><td>System.IO.Stream</td>
	</tr>
	</table><br />
	The following suffixes are reserved as well: Delegate, Enum, Flags (for an enumeration) and Impl.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename type and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
		<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Only Collection class name must have "Collection" suffix.</li>
    <li>Only Dictionary class name must have "Dictionary" suffix.</li>
    <li>Only Exception class name must have "Exception" suffix</li>
    <li>Only Attribute class name must have "Attribute" suffix</li>
    <li>Only Condition class name must have "Condition" suffix</li>
    <li>Only Queue class name must have "Queue" suffix</li>
    <li>Only Stack class name must have "Stack" suffix</li>
    <li>Only Stream class name must have "Stream" suffix</li>
    <li>Only Permission class name must have "Permission" suffix</li>
    <li>Only EventArgs class name must have "EventArgs" suffix</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class MySampleDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	
	...
	
End Class

- Or -

Public Class MySampleDictionary
	Implements IDictionary
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class MySampleDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample
{
	
	...
	
}

- Or -

public class MySampleDictionary: IDictionary
{
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00002">
      <Name>Only Stream Class -&gt; "Stream" Suffix</Name>
      <Title>Only Stream class name must have "Stream" suffix</Title>
      <ClassName>AvoidCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Stream</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.IO.Stream</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type has incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type or derived type should not end with one of specific reserved suffixes.
	These suffixes can be used only in the name of the type that extends certain base type,
	implement certain interface or derived from such types.
	<br /><br />
	The table below represents base types and interfaces with corresponding reserved suffixes:<br />
	<table border="0" cellpadding="7" cellspacing="0">
	<tr>
		<td><b>Suffix</b></td><td><b>Name of base type or interface</b></td>
	</tr>
	<tr>
		<td>Attribute</td><td>System.Attribute</td>
	</tr>
	<tr>
		<td>Collection</td><td>System.Collections.Generic.ICollection<br />
			System.Collections.ICollection<br />
			System.Collections.IEnumerable<br />
			System.Collections.Queue<br />
			System.Collections.Stack<br />
			System.Data.DataSet<br />
			System.Data.DataTable
		</td>
	</tr>
	<tr>
		<td>Dictionary</td><td>System.Collections.Generic.IDictionary<br />
			System.Collections.IDictionary 
		</td>
	</tr>
	<tr>
		<td>EventArgs</td><td>System.EventArgs</td>
	</tr>
	<tr>
		<td>EventHandler</td><td>An event-handler delegate.</td>
	</tr>
	<tr>
		<td>Exception</td><td>System.Exception</td>
	</tr>
	<tr>
		<td>Permission</td><td>System.Security.IPermission</td>
	</tr>
	<tr>
		<td>Queue</td><td>System.Collections.Queue</td>
	</tr>
	<tr>
		<td>Stack</td><td>System.Collections.Stack</td>
	</tr>
	<tr>
		<td>Stream</td><td>System.IO.Stream</td>
	</tr>
	</table><br />
	The following suffixes are reserved as well: Delegate, Enum, Flags (for an enumeration) and Impl.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename type and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
		<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Only Collection class name must have "Collection" suffix.</li>
    <li>Only Dictionary class name must have "Dictionary" suffix.</li>
    <li>Only Exception class name must have "Exception" suffix</li>
    <li>Only Attribute class name must have "Attribute" suffix</li>
    <li>Only Condition class name must have "Condition" suffix</li>
    <li>Only Queue class name must have "Queue" suffix</li>
    <li>Only Stack class name must have "Stack" suffix</li>
    <li>Only Stream class name must have "Stream" suffix</li>
    <li>Only Permission class name must have "Permission" suffix</li>
    <li>Only EventArgs class name must have "EventArgs" suffix</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class MySampleDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	
	...
	
End Class

- Or -

Public Class MySampleDictionary
	Implements IDictionary
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class MySampleDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample
{
	
	...
	
}

- Or -

public class MySampleDictionary: IDictionary
{
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00002">
      <Name>Only Permission Class -&gt; "Permission" Suffix</Name>
      <Title>Only Permission class name must have "Permission" suffix</Title>
      <ClassName>AvoidCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Permission</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Security.IPermission</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type has incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type or derived type should not end with one of specific reserved suffixes.
	These suffixes can be used only in the name of the type that extends certain base type,
	implement certain interface or derived from such types.
	<br /><br />
	The table below represents base types and interfaces with corresponding reserved suffixes:<br />
	<table border="0" cellpadding="7" cellspacing="0">
	<tr>
		<td><b>Suffix</b></td><td><b>Name of base type or interface</b></td>
	</tr>
	<tr>
		<td>Attribute</td><td>System.Attribute</td>
	</tr>
	<tr>
		<td>Collection</td><td>System.Collections.Generic.ICollection<br />
			System.Collections.ICollection<br />
			System.Collections.IEnumerable<br />
			System.Collections.Queue<br />
			System.Collections.Stack<br />
			System.Data.DataSet<br />
			System.Data.DataTable
		</td>
	</tr>
	<tr>
		<td>Dictionary</td><td>System.Collections.Generic.IDictionary<br />
			System.Collections.IDictionary 
		</td>
	</tr>
	<tr>
		<td>EventArgs</td><td>System.EventArgs</td>
	</tr>
	<tr>
		<td>EventHandler</td><td>An event-handler delegate.</td>
	</tr>
	<tr>
		<td>Exception</td><td>System.Exception</td>
	</tr>
	<tr>
		<td>Permission</td><td>System.Security.IPermission</td>
	</tr>
	<tr>
		<td>Queue</td><td>System.Collections.Queue</td>
	</tr>
	<tr>
		<td>Stack</td><td>System.Collections.Stack</td>
	</tr>
	<tr>
		<td>Stream</td><td>System.IO.Stream</td>
	</tr>
	</table><br />
	The following suffixes are reserved as well: Delegate, Enum, Flags (for an enumeration) and Impl.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename type and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
		<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Only Collection class name must have "Collection" suffix.</li>
    <li>Only Dictionary class name must have "Dictionary" suffix.</li>
    <li>Only Exception class name must have "Exception" suffix</li>
    <li>Only Attribute class name must have "Attribute" suffix</li>
    <li>Only Condition class name must have "Condition" suffix</li>
    <li>Only Queue class name must have "Queue" suffix</li>
    <li>Only Stack class name must have "Stack" suffix</li>
    <li>Only Stream class name must have "Stream" suffix</li>
    <li>Only Permission class name must have "Permission" suffix</li>
    <li>Only EventArgs class name must have "EventArgs" suffix</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class MySampleDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	
	...
	
End Class

- Or -

Public Class MySampleDictionary
	Implements IDictionary
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class MySampleDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample
{
	
	...
	
}

- Or -

public class MySampleDictionary: IDictionary
{
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00002">
      <Name>Only EventArgs Class -&gt; "EventArgs" Suffix</Name>
      <Title>Only EventArgs class name must have "EventArgs" suffix</Title>
      <ClassName>AvoidCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>EventArgs</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.EventArgs</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type has incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type or derived type should not end with one of specific reserved suffixes.
	These suffixes can be used only in the name of the type that extends certain base type,
	implement certain interface or derived from such types.
	<br /><br />
	The table below represents base types and interfaces with corresponding reserved suffixes:<br />
	<table border="0" cellpadding="7" cellspacing="0">
	<tr>
		<td><b>Suffix</b></td><td><b>Name of base type or interface</b></td>
	</tr>
	<tr>
		<td>Attribute</td><td>System.Attribute</td>
	</tr>
	<tr>
		<td>Collection</td><td>System.Collections.Generic.ICollection<br />
			System.Collections.ICollection<br />
			System.Collections.IEnumerable<br />
			System.Collections.Queue<br />
			System.Collections.Stack<br />
			System.Data.DataSet<br />
			System.Data.DataTable
		</td>
	</tr>
	<tr>
		<td>Dictionary</td><td>System.Collections.Generic.IDictionary<br />
			System.Collections.IDictionary 
		</td>
	</tr>
	<tr>
		<td>EventArgs</td><td>System.EventArgs</td>
	</tr>
	<tr>
		<td>EventHandler</td><td>An event-handler delegate.</td>
	</tr>
	<tr>
		<td>Exception</td><td>System.Exception</td>
	</tr>
	<tr>
		<td>Permission</td><td>System.Security.IPermission</td>
	</tr>
	<tr>
		<td>Queue</td><td>System.Collections.Queue</td>
	</tr>
	<tr>
		<td>Stack</td><td>System.Collections.Stack</td>
	</tr>
	<tr>
		<td>Stream</td><td>System.IO.Stream</td>
	</tr>
	</table><br />
	The following suffixes are reserved as well: Delegate, Enum, Flags (for an enumeration) and Impl.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename type and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
		<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Only Collection class name must have "Collection" suffix.</li>
    <li>Only Dictionary class name must have "Dictionary" suffix.</li>
    <li>Only Exception class name must have "Exception" suffix</li>
    <li>Only Attribute class name must have "Attribute" suffix</li>
    <li>Only Condition class name must have "Condition" suffix</li>
    <li>Only Queue class name must have "Queue" suffix</li>
    <li>Only Stack class name must have "Stack" suffix</li>
    <li>Only Stream class name must have "Stream" suffix</li>
    <li>Only Permission class name must have "Permission" suffix</li>
    <li>Only EventArgs class name must have "EventArgs" suffix</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class MySampleDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	
	...
	
End Class

- Or -

Public Class MySampleDictionary
	Implements IDictionary
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class MySampleDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample
{
	
	...
	
}

- Or -

public class MySampleDictionary: IDictionary
{
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00003">
      <Name>Parameter -&gt; Avoid Language Specific Type Names</Name>
      <Title>Avoid language specific type names in parameters</Title>
      <ClassName>AvoidLanguageSpecificTypeNamesInParameters</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Parameter</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1718:AvoidLanguageSpecificTypeNamesInParameters</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidLanguageSpecificTypeNamesInParameters.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the parameter should not contain a language-specific type name.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Use names that reflect the meaning of the parameter and avoid prefixes and 
	suffixes that indicate the type of a parameter.
	<br />	
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Avoid language specific type names in parameters', CheckId <b>CA1718</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename parameter and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid language specific type names in parameters.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
	<br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class PersonInfo

Private _firstName As String
Private _lastName As String

Public ReadOnly Property FirstName() As String
	Get
		Return _firstName
	End Get
End Property

Public ReadOnly Property LastName() As String
	Get
		Return _lastName
	End Get
End Property

' Violation
Public Sub New(ByVal firstNameString As String, ByVal lastNameString As String)

  Me._firstName = firstNameString
  Me._lastName = lastNameString

End Sub

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class PersonInfo

Private _firstName As String
Private _lastName As String

Public ReadOnly Property FirstName() As String
	Get
		Return _firstName
	End Get
End Property

Public ReadOnly Property LastName() As String
	Get
		Return _lastName
	End Get
End Property

' Fixed names
Public Sub New(ByVal <SPAN class=code-changed>firstName</SPAN> As String, ByVal <SPAN class=code-changed>lastName</SPAN> As String)

    Me._firstName = <SPAN class=code-changed>firstName</SPAN>
    Me._lastName = <SPAN class=code-changed>lastName</SPAN>

End Sub

End Class

</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class PersonInfo
{

  private string _firstName;
  private string _lastName;

  public string FirstName
  {
	  get
	  {
		  return _firstName;
	  }
  }

  public string LastName
  {
	  get
	  {
		  return _lastName;
	  }
  }

  // Violation
  public PersonInfo(string firstNameString, string lastNameString)
  {

    this._firstName = firstNameString;
    this._lastName = lastNameString;

  }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class PersonInfo
{

  private string _firstName;
  private string _lastName;

  public string FirstName
  {
	  get
	  {
		  return _firstName;
	  }
  }

  public string LastName
  {
	  get
	  {
		  return _lastName;
	  }
  }

  // Violation
  public PersonInfo(string <SPAN class=code-changed>firstName</SPAN>, string <SPAN class=code-changed>lastName</SPAN>)
  {

    this._firstName = <SPAN class=code-changed>firstName</SPAN>;
    this._lastName = <SPAN class=code-changed>lastName</SPAN>;

  }

}

</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00004">
      <Name>Enumeration value -&gt; Avoid Prefix With Type Name</Name>
      <Title>Avoid prefix enumeration values with type name</Title>
      <ClassName>AvoidPrefixEnumMembersWithTypeName</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>EnumerationItem</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1712:DoNotPrefixEnumValuesWithTypeName</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00004</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidPrefixEnumMembersWithTypeName.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[An enumeration contains a member whose name begins with the type name of the enumeration.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Enumeration members names are not prefixed with the type name because type information is redundant.
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not prefix enum values with type name', CheckId <b>CA1712</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename enumeration member and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid prefix enumeration values with type name.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
	
Public Enum ImageMode

    ImageModeBitmap = 0
    ImageModeGrayscale = 1
    ImageModeIndexed = 2
    ImageModeRgb = 3
    
End Enum


<SPAN class=code-selected>' This is the correct implementation</SPAN>
	
Public Enum ImageMode

    <SPAN class=code-changed>Bitmap</SPAN> = 0
    <SPAN class=code-changed>Grayscale</SPAN> = 1
    <SPAN class=code-changed>Indexed</SPAN> = 2
    <SPAN class=code-changed>Rgb</SPAN> = 3
    
End Enum

</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
	
public enum ImageMode
{

    ImageModeBitmap = 0,
    ImageModeGrayscale = 1,
    ImageModeIndexed = 2,
    ImageModeRgb = 3
    
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>
	
public enum ImageMode
{

    <SPAN class=code-changed>Bitmap</SPAN> = 0,
    <SPAN class=code-changed>Grayscale</SPAN> = 1,
    <SPAN class=code-changed>Indexed</SPAN> = 2,
    <SPAN class=code-changed>Rgb</SPAN> = 3
    
}

</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00005">
      <Name>Enumeration value -&gt; Avoid 'Reserved' Name</Name>
      <Title>Avoid name enumeration values 'Reserved'</Title>
      <ClassName>AvoidSpecifiedNameForEnumMembers</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>EnumerationItem</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1700:DoNotNameEnumValuesReserved</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00005</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidSpecifiedNameForEnumMembers.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>NameToAvoid</Name>
          <Value>Reserved</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the member of enumeration includes the "Reserved" word.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Don't use the word "Reserved" in the name of an enumeration member. Defining such reserved
	values is a holdover from COM programming. A later version of a Microsoft .NET Framework class
	library can simply add new values as and when required, without breaking existing clients,
	provided that you don't change the numeric value of existing values.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not name enum values Reserved', CheckId <b>CA1700</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The word "Reserved" should be removed from the name of the member of enumeration. Do not include "reserved for future use" values in an enum value.<br /><br />
  The rule provides the following auto-correct options:
  <UL>
    <LI>Rename enumeration member and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>NameToAvoid</i> - Name to be avoid in enum members.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid name enumeration values "Reserved".</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Enum SampleType

  Unknown = 0
  Known = 1
  SomeOtherReserved = 2

End Enum


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Enum SampleType

  Unknown = 0
  Known = 1

End Enum

- Or -

Enum SampleType

  Unknown = 0
  Known = 1
  SomeOther = 2

End Enum
	</pre>
	<p>[C#]</p> 
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

enum SampleType
{

  Unknown = 0,
  Known = 1,
  SomeOtherReserved = 2

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

enum SampleType
{

  Unknown = 0,
  Known = 1

}

- Or -

enum SampleType
{

  Unknown = 0,
  Known = 1,
  SomeOther = 2

}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00006">
      <Name>Namespace/Type -&gt; Pascal Cased</Name>
      <Title>Namespace/Type identifiers should be cased correctly</Title>
      <ClassName>IdentifiersShouldBeCasedCorrectly</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Namespace, Class, Interface, Delegate, Struct, Enumeration, Module, Type</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1709:IdentifiersShouldBeCasedCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00006</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldBeCasedCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>IdentifierCase</Name>
          <Value>Pascal</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of an identifier is not cased correctly.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the following capitalization rules should be used for the different types of identifiers:<br /><br />
	<b>Pascal case should be used for:</b><br />
	- Class<br />
	- Enum type<br />
	- Enum values<br />
	- Event<br />
	- Exception class<br />
	- Read-only Static field<br />
	- Interface<br />
	- Method<br />
	- Namespace<br />
	- Property<br />
	- Public instance field<br />
	<br />
	<b>Camel case should be used for:</b><br />
	- Parameter<br />
	- Protected instance field<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should be cased correctly', CheckId <b>CA1709</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>IdentifierCase</i> - Name case notation to check. Possible values: Camel, Pascal, Upper</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Namespace/Type identifiers should be cased correctly.</li>
    <li>Member identifiers should be cased correctly.</li>
    <li>Field identifiers should be cased correctly.</li>
    <li>Parameter identifiers should be cased correctly.</li>
    <li>Local variable identifiers should be cased correctly.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class sampleClass
	Protected InstanceField As String = String.Empty
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>SampleClass</SPAN>
	Protected <SPAN class=code-changed>instanceField</SPAN> As String = String.Empty
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class sampleClass
{
	protected string InstanceField = String.Empty;
	
	...
	
}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

public class <SPAN class=code-changed>SampleClass</SPAN>
{
	protected string <SPAN class=code-changed>instanceField</SPAN> = String.Empty;
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00006">
      <Name>Member -&gt; Pascal Cased</Name>
      <Title>Member identifiers should be cased correctly</Title>
      <ClassName>IdentifiersShouldBeCasedCorrectly</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Method, Operator, Event, Property, Indexer, EnumerationItem, Constant</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1709:IdentifiersShouldBeCasedCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00006</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldBeCasedCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>IdentifierCase</Name>
          <Value>Pascal</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of an identifier is not cased correctly.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the following capitalization rules should be used for the different types of identifiers:<br /><br />
	<b>Pascal case should be used for:</b><br />
	- Class<br />
	- Enum type<br />
	- Enum values<br />
	- Event<br />
	- Exception class<br />
	- Read-only Static field<br />
	- Interface<br />
	- Method<br />
	- Namespace<br />
	- Property<br />
	- Public instance field<br />
	<br />
	<b>Camel case should be used for:</b><br />
	- Parameter<br />
	- Protected instance field<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should be cased correctly', CheckId <b>CA1709</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>IdentifierCase</i> - Name case notation to check. Possible values: Camel, Pascal, Upper</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Namespace/Type identifiers should be cased correctly.</li>
    <li>Member identifiers should be cased correctly.</li>
    <li>Field identifiers should be cased correctly.</li>
    <li>Parameter identifiers should be cased correctly.</li>
    <li>Local variable identifiers should be cased correctly.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class sampleClass
	Protected InstanceField As String = String.Empty
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>SampleClass</SPAN>
	Protected <SPAN class=code-changed>instanceField</SPAN> As String = String.Empty
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class sampleClass
{
	protected string InstanceField = String.Empty;
	
	...
	
}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

public class <SPAN class=code-changed>SampleClass</SPAN>
{
	protected string <SPAN class=code-changed>instanceField</SPAN> = String.Empty;
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00006">
      <Name>Public Field -&gt; Pascal Cased</Name>
      <Title>Field identifiers should be cased correctly</Title>
      <ClassName>IdentifiersShouldBeCasedCorrectly</ClassName>
      <Scope>Public</Scope>
      <Severity>Warning</Severity>
      <Targets>Field</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1709:IdentifiersShouldBeCasedCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00006</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldBeCasedCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>IdentifierCase</Name>
          <Value>Pascal</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of an identifier is not cased correctly.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the following capitalization rules should be used for the different types of identifiers:<br /><br />
	<b>Pascal case should be used for:</b><br />
	- Class<br />
	- Enum type<br />
	- Enum values<br />
	- Event<br />
	- Exception class<br />
	- Read-only Static field<br />
	- Interface<br />
	- Method<br />
	- Namespace<br />
	- Property<br />
	- Public instance field<br />
	<br />
	<b>Camel case should be used for:</b><br />
	- Parameter<br />
	- Protected instance field<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should be cased correctly', CheckId <b>CA1709</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>IdentifierCase</i> - Name case notation to check. Possible values: Camel, Pascal, Upper</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Namespace/Type identifiers should be cased correctly.</li>
    <li>Member identifiers should be cased correctly.</li>
    <li>Field identifiers should be cased correctly.</li>
    <li>Parameter identifiers should be cased correctly.</li>
    <li>Local variable identifiers should be cased correctly.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class sampleClass
	Protected InstanceField As String = String.Empty
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>SampleClass</SPAN>
	Protected <SPAN class=code-changed>instanceField</SPAN> As String = String.Empty
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class sampleClass
{
	protected string InstanceField = String.Empty;
	
	...
	
}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

public class <SPAN class=code-changed>SampleClass</SPAN>
{
	protected string <SPAN class=code-changed>instanceField</SPAN> = String.Empty;
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00006">
      <Name>Parameter -&gt; Camel Cased</Name>
      <Title>Parameter identifiers should be cased correctly</Title>
      <ClassName>IdentifiersShouldBeCasedCorrectly</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Parameter</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1709:IdentifiersShouldBeCasedCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00006</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldBeCasedCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>IdentifierCase</Name>
          <Value>Camel</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of an identifier is not cased correctly.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the following capitalization rules should be used for the different types of identifiers:<br /><br />
	<b>Pascal case should be used for:</b><br />
	- Class<br />
	- Enum type<br />
	- Enum values<br />
	- Event<br />
	- Exception class<br />
	- Read-only Static field<br />
	- Interface<br />
	- Method<br />
	- Namespace<br />
	- Property<br />
	- Public instance field<br />
	<br />
	<b>Camel case should be used for:</b><br />
	- Parameter<br />
	- Protected instance field<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should be cased correctly', CheckId <b>CA1709</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>IdentifierCase</i> - Name case notation to check. Possible values: Camel, Pascal, Upper</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Namespace/Type identifiers should be cased correctly.</li>
    <li>Member identifiers should be cased correctly.</li>
    <li>Field identifiers should be cased correctly.</li>
    <li>Parameter identifiers should be cased correctly.</li>
    <li>Local variable identifiers should be cased correctly.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class sampleClass
	Protected InstanceField As String = String.Empty
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>SampleClass</SPAN>
	Protected <SPAN class=code-changed>instanceField</SPAN> As String = String.Empty
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class sampleClass
{
	protected string InstanceField = String.Empty;
	
	...
	
}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

public class <SPAN class=code-changed>SampleClass</SPAN>
{
	protected string <SPAN class=code-changed>instanceField</SPAN> = String.Empty;
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00006">
      <Name>Local Variable -&gt; Camel Cased</Name>
      <Title>Local variable identifiers should be cased correctly.</Title>
      <ClassName>IdentifiersShouldBeCasedCorrectly</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Variable, LocalConstant</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1709:IdentifiersShouldBeCasedCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00006</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldBeCasedCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>IdentifierCase</Name>
          <Value>Camel</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of an identifier is not cased correctly.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the following capitalization rules should be used for the different types of identifiers:<br /><br />
	<b>Pascal case should be used for:</b><br />
	- Class<br />
	- Enum type<br />
	- Enum values<br />
	- Event<br />
	- Exception class<br />
	- Read-only Static field<br />
	- Interface<br />
	- Method<br />
	- Namespace<br />
	- Property<br />
	- Public instance field<br />
	<br />
	<b>Camel case should be used for:</b><br />
	- Parameter<br />
	- Protected instance field<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should be cased correctly', CheckId <b>CA1709</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>IdentifierCase</i> - Name case notation to check. Possible values: Camel, Pascal, Upper</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Namespace/Type identifiers should be cased correctly.</li>
    <li>Member identifiers should be cased correctly.</li>
    <li>Field identifiers should be cased correctly.</li>
    <li>Parameter identifiers should be cased correctly.</li>
    <li>Local variable identifiers should be cased correctly.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class sampleClass
	Protected InstanceField As String = String.Empty
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>SampleClass</SPAN>
	Protected <SPAN class=code-changed>instanceField</SPAN> As String = String.Empty
	
	...
	
End Class
	</pre>
	<p>[C#]</p> 
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class sampleClass
{
	protected string InstanceField = String.Empty;
	
	...
	
}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

public class <SPAN class=code-changed>SampleClass</SPAN>
{
	protected string <SPAN class=code-changed>instanceField</SPAN> = String.Empty;
	
	...
	
}
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00007">
      <Name>Member Parameters -&gt; Differ By More Then Case</Name>
      <Title>Member parameter names should differ by more than case</Title>
      <ClassName>IdentifiersShouldDifferByMoreThanCase</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Method, Operator, Indexer</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1708:IdentifiersShouldDifferByMoreThanCase</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00007</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldDifferByMoreThanCase.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The names of two types, members, parameters, or fully qualified namespaces are 
  identical when converted to lower-case.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Identifiers for namespaces, types, members, and parameters cannot differ only by case 
	because languages that target the common language runtime are not required to be 
	case-sensitive. For example, Visual Basic is a widely used case-insensitive language.
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should differ by more than case', CheckId <b>CA1708</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename identifier and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Member parameter names should differ by more than case.</li>
    <li>Type member names should differ by more than case.</li>
    <li>Identifiers should differ by more than case.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
<SPAN class=code-selected>' Such class will not be usable in the case-insensitive language</SPAN>

class FileUtility
{

    public string GetFileContent(string fileName)
    {
    
    ...
    
    }

    public string GetFilecontent(string fileName)
    {
    
    ...
    
    }
    
}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

class FileUtility
{

    public string GetFileContent(string fileName)
    {
    
    ...
    
    }

    public string <SPAN class=code-changed>GetFileContent1</SPAN>(string fileName)
    {
    
    ...
    
    }
    
}
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00007">
      <Name>Type Members -&gt; Differ By More Than Case</Name>
      <Title>Type member names should differ by more than case</Title>
      <ClassName>IdentifiersShouldDifferByMoreThanCase</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface, Struct, Enumeration, Module</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1708:IdentifiersShouldDifferByMoreThanCase</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00007</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldDifferByMoreThanCase.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The names of two types, members, parameters, or fully qualified namespaces are 
  identical when converted to lower-case.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Identifiers for namespaces, types, members, and parameters cannot differ only by case 
	because languages that target the common language runtime are not required to be 
	case-sensitive. For example, Visual Basic is a widely used case-insensitive language.
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should differ by more than case', CheckId <b>CA1708</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename identifier and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Member parameter names should differ by more than case.</li>
    <li>Type member names should differ by more than case.</li>
    <li>Identifiers should differ by more than case.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
<SPAN class=code-selected>' Such class will not be usable in the case-insensitive language</SPAN>

class FileUtility
{

    public string GetFileContent(string fileName)
    {
    
    ...
    
    }

    public string GetFilecontent(string fileName)
    {
    
    ...
    
    }
    
}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

class FileUtility
{

    public string GetFileContent(string fileName)
    {
    
    ...
    
    }

    public string <SPAN class=code-changed>GetFileContent1</SPAN>(string fileName)
    {
    
    ...
    
    }
    
}
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00007">
      <Name>Namespace Types -&gt; Differ By More Than Case</Name>
      <Title>Identifiers should differ by more than case</Title>
      <ClassName>IdentifiersShouldDifferByMoreThanCase</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Namespace</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1708:IdentifiersShouldDifferByMoreThanCase</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00007</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldDifferByMoreThanCase.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The names of two types, members, parameters, or fully qualified namespaces are 
  identical when converted to lower-case.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Identifiers for namespaces, types, members, and parameters cannot differ only by case 
	because languages that target the common language runtime are not required to be 
	case-sensitive. For example, Visual Basic is a widely used case-insensitive language.
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should differ by more than case', CheckId <b>CA1708</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename identifier and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Member parameter names should differ by more than case.</li>
    <li>Type member names should differ by more than case.</li>
    <li>Identifiers should differ by more than case.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
<SPAN class=code-selected>' Such class will not be usable in the case-insensitive language</SPAN>

class FileUtility
{

    public string GetFileContent(string fileName)
    {
    
    ...
    
    }

    public string GetFilecontent(string fileName)
    {
    
    ...
    
    }
    
}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

class FileUtility
{

    public string GetFileContent(string fileName)
    {
    
    ...
    
    }

    public string <SPAN class=code-changed>GetFileContent1</SPAN>(string fileName)
    {
    
    ...
    
    }
    
}
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00008">
      <Name>Namespace/Type -&gt; Avoid Underscores</Name>
      <Title>Namespace and type names should not contain underscores</Title>
      <ClassName>IdentifiersShouldNotContainSpecifiedChars</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Namespace, Class, Interface, Delegate, Struct, Enumeration, Module, Type</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1707:IdentifiersShouldNotContainUnderscores</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00008</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldNotContainSpecifiedChars.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ForbiddenChar</Name>
          <Value>_</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of an identifier contains the specified character.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>
    Remove the specified character from identifier's name and rename an identifier 
    and its references.
    <LI>
    Rename an identifier and its references to the specified name.
  </UL>
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not contain underscores', CheckId <b>CA1707</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
    <li>
      <i>ForbiddenChar</i> - Should not contain a character.</li>
  </ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>
      Namespace and type names should not contain underscores.</li>
    <li>
      Public member names should not contain underscores.</li>
    <li>
      Parameter names should not contain underscores.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class _SampleFileReader
  
    ...
  
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class <SPAN class=code-changed>SampleFileReader</SPAN>
  
    ...

  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class _SampleFileReader
  {
  
    ...
  
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class <SPAN class=code-changed>SampleFileReader</SPAN>
  {
  
    ...

  }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00008">
      <Name>Member -&gt; Avoid Underscores</Name>
      <Title>Public member names should not contain underscores</Title>
      <ClassName>IdentifiersShouldNotContainSpecifiedChars</ClassName>
      <Scope>Public</Scope>
      <Severity>Warning</Severity>
      <Targets>Method, Operator, Event, Property, Indexer, EnumerationItem, Constant, Field, Member</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1707:IdentifiersShouldNotContainUnderscores</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00008</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldNotContainSpecifiedChars.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ForbiddenChar</Name>
          <Value>_</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of an identifier contains the specified character.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>
    Remove the specified character from identifier's name and rename an identifier 
    and its references.
    <LI>
    Rename an identifier and its references to the specified name.
  </UL>
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not contain underscores', CheckId <b>CA1707</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
    <li>
      <i>ForbiddenChar</i> - Should not contain a character.</li>
  </ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>
      Namespace and type names should not contain underscores.</li>
    <li>
      Public member names should not contain underscores.</li>
    <li>
      Parameter names should not contain underscores.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class _SampleFileReader
  
    ...
  
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class <SPAN class=code-changed>SampleFileReader</SPAN>
  
    ...

  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class _SampleFileReader
  {
  
    ...
  
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class <SPAN class=code-changed>SampleFileReader</SPAN>
  {
  
    ...

  }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00008">
      <Name>Parameter -&gt; Avoid Underscores</Name>
      <Title>Parameter names should not contain underscores</Title>
      <ClassName>IdentifiersShouldNotContainSpecifiedChars</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Parameter</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1707:IdentifiersShouldNotContainUnderscores</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00008</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldNotContainSpecifiedChars.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ForbiddenChar</Name>
          <Value>_</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of an identifier contains the specified character.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>
    Remove the specified character from identifier's name and rename an identifier 
    and its references.
    <LI>
    Rename an identifier and its references to the specified name.
  </UL>
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not contain underscores', CheckId <b>CA1707</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
    <li>
      <i>ForbiddenChar</i> - Should not contain a character.</li>
  </ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>
      Namespace and type names should not contain underscores.</li>
    <li>
      Public member names should not contain underscores.</li>
    <li>
      Parameter names should not contain underscores.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class _SampleFileReader
  
    ...
  
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class <SPAN class=code-changed>SampleFileReader</SPAN>
  
    ...

  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class _SampleFileReader
  {
  
    ...
  
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class <SPAN class=code-changed>SampleFileReader</SPAN>
  {
  
    ...

  }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00009">
      <Name>Namespace/Type -&gt; Avoid Match Keywords</Name>
      <Title>Namespace or Type names should not match keywords</Title>
      <ClassName>IdentifiersShouldNotMatchKeywords</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Namespace, Class, Interface, Delegate, Struct, Enumeration, Module, Type</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1716:IdentifiersShouldNotMatchKeywords</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00009</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldNotMatchKeywords.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[A namespace name or a type name matches a reserved keyword in a case-insensitive comparison.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Identifiers for namespaces and types should not match keywords defined by 
  languages that target the common language runtime. Depending on the language in 
  use and the keyword, compiler errors and ambiguities can make the library 
  difficult to use. This rule does not check all keywords in all .NET languages
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not match keywords', CheckId <b>CA1716</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename an identifier and its references to the specified name. 
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Namespace or Type names should not match keywords.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Public Class Operator
  
    ...
  
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Public Class <SPAN class=code-changed>MyOperator</SPAN>
  
    ...

  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  public class Delegate
  {
  
    ...
  
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  public class <SPAN class=code-changed>MyDelegate</SPAN>
  {
  
    ...

  }
	
	</]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00010">
      <Name>Parameter -&gt; Match Base Declaration</Name>
      <Title>Parameter names should match base declaration</Title>
      <ClassName>ParameterNamesShouldMatchBaseDeclaration</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Parameter</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1725:ParameterNamesShouldMatchBaseDeclaration</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00010</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ParameterNamesShouldMatchBaseDeclaration.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the parameter in the derived method does not match the name of the parameter in the base declaration of that method.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The name of the parameter in the derived (overrided) method should match the name of the parameter in the base declaration of that method. Observance of that rule alows to avoid possible confusion and increases usability of derived methods.
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Parameter names should match base declaration', CheckId <b>CA1725</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename parameter and its references to the base declaration parameter name. 
    <LI>Rename parameter and its references to the specified name. 
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Parameter names should match base declaration.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.<br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The base declaration of the System.ComponentModel.IBindingList.AddIndex method is:</SPAN>

Sub AddIndex (property As PropertyDescriptor)

<SPAN class=code-selected>
' This code will trigger the rule violation

' The following Persons type implements System.ComponentModel.IBindingList interface.
</SPAN>

Imports System.ComponentModel

Public Class Persons
    Implements IBindingList

	...

    Public Sub AddIndex(propertyValue As PropertyDescriptor) Implements IBindingList.AddIndex
    
        ' method code
        
    End Sub

	...

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System.ComponentModel

Public Class Persons
    Implements IBindingList

	...

    Public Sub AddIndex(<SPAN class=code-changed>[property]</SPAN> As PropertyDescriptor) Implements IBindingList.AddIndex
    
        ' method code
        
    End Sub

	...

End Class
</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The base declaration of the System.ComponentModel.IBindingList.AddIndex method is:</SPAN>

void AddIndex(PropertyDescriptor property)

<SPAN class=code-selected>
// This code will trigger the rule violation

// The following Persons type implements System.ComponentModel.IBindingList interface.
</SPAN>

using System.ComponentModel;

public class Persons: IBindingList
{

	...

    public void IBindingList.AddIndex(PropertyDescriptor propertyValue)
    {
    
        // method code
        
    }

	...

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System.ComponentModel;

public class Persons: IBindingList
{

	...


    public void IBindingList.AddIndex(PropertyDescriptor <SPAN class=code-changed>property</SPAN>)
    {
    
        // method code
        
    }

	...

}
</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00011">
      <Name>Parameter -&gt; Avoid Match Member Name</Name>
      <Title>Parameter names should not match member names</Title>
      <ClassName>ParameterNamesShouldNotMatchMemberNames</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Parameter</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>8/18/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1719:ParameterNamesShouldNotMatchMemberNames</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00011</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ParameterNamesShouldNotMatchMemberNames.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of one of parameters matches the name of the method in the case-insensetive comparison.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, names of the parameters should be descriptive and reflect the meaning of the parameter. The same naming for the parameter and for the method is unintuitive.<br />
	<br />
	<i>This rule is similar to <b>FxCop</b> rule 'Parameter names should not match member names', CheckId <b>CA1719</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename parameter and its references to the specified name. 
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Parameter names should not match member names.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

    Public Sub AddRange(ByVal addRange As PersonsCollection)
        If Not addRange Is Nothing Then
            InnerList.AddRange(addRange)
        End If
    End Sub


<SPAN class=code-selected>' This is the correct implementation</SPAN>

    Public Sub AddRange(ByVal <SPAN class=code-changed>items</SPAN> As PersonsCollection)
        If Not <SPAN class=code-changed>items</SPAN> Is Nothing Then
            InnerList.AddRange(<SPAN class=code-changed>items</SPAN>)
        End If
    End Sub

</pre>
	<p>[C#]</p> 
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

    public void AddRange(PersonsCollection addRange)
    {
        if (addRange != null)
        {
            InnerList.AddRange(addRange);
        }
    }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

    public void AddRange(PersonsCollection <SPAN class=code-changed>items</SPAN>)
    {
        if (<SPAN class=code-changed>items</SPAN> != null)
        {
            InnerList.AddRange(<SPAN class=code-changed>items</SPAN>);
        }
    }

</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00012">
      <Name>Property -&gt; Avoid Match Get Methods</Name>
      <Title>Property names should not match get methods</Title>
      <ClassName>PropertyNamesShouldNotMatchGetMethods</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Property</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1721:PropertyNamesShouldNotMatchGetMethods</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00012</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/PropertyNamesShouldNotMatchGetMethods.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of a public or protected member starts with "Get" and otherwise matches 
  the name of a public or protected property.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Get methods and properties should have names that clearly distinguish their function.
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Property names should not match get methods', CheckId <b>CA1721</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename property and its references to the specified name. 
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Property names should not match get methods.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System.Drawing

Public Class Sample
    
    Public ReadOnly Property Color() As Color
        Get
            Return Color.Red
        End Get
    End Property

     ' This method violates rule: "Property names should not match get methods"
    Public Function GetColor() As Color
        Return Color.FromName("Red")
    End Function 

End Class 


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System.Drawing

Public Class Sample
    
    Public ReadOnly Property Color() As Color
        Get
            Return Color.Red
        End Get
    End Property

    Public Function <SPAN class=code-changed>GetDefaultColor</SPAN>() As Color
        Return Color.FromName("Red")
    End Function 

End Class 

	</pre>
	<p>[C#]</p> 
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System.Drawing;

public class Sample
{
    
    public Color Color()
    {
        get
        {
            return Color.Red;
        }
    }

    // This method violates the rule
    public Color GetColor()
    {
        return Color.FromName("Red");
    }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System.Drawing;

public class Sample
{
    
    public Color Color()
    {
        get
        {
            return Color.Red;
        }
    }

    public Color <SPAN class=code-changed>GetDefaultColor</SPAN>()
    {
        return Color.FromName("Red");
    }

}

	</pre]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00013">
      <Name>Type -&gt; Avoid Match Namespaces</Name>
      <Title>Type names should not match namespaces</Title>
      <ClassName>TypeNamesShouldNotMatchNamespaces</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface, Delegate, Struct, Enumeration, Module, Type</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1724:TypeNamesShouldNotMatchNamespaces</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00013</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/TypeNamesShouldNotMatchNamespaces.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The class name duplicates commonly used .NET Framework namespace.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Avoid using class names that duplicate commonly used .NET Framework namespaces in case-insensitive
	comparison. For example, the following names should not be used as a class name:
	<UL>
		<LI><b>System</b>;
		<LI><b>Collections</b>;
		<LI><b>Forms</b>;
		<LI><b>UI</b>;
		<LI>etc.
	</UL>
	<i>This rule is similar to <b>FxCop</b> rule 'Type names should not match namespaces', CheckId <b>CA1724</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Rename class and choose new name that does not duplicate commonly used .NET Framework namespaces.<br />
	<br />
	The rule provides the following auto-correct options:
  <UL>
    <LI>Rename type and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Type names should not match namespaces.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Namespace MyNamespace

	Public Class Forms
		
		...
		
	End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Namespace MyNamespace

	Public Class <SPAN class=code-changed>MyForms</SPAN>
		
		...
		
	End Class

End Namespace
	</pre>
	<p>[C#]</p> 
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

namespace MyNamespace
{

	public class Forms
	{
		
		...
		
	}

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

namespace MyNamespace
{

	public class <SPAN class=code-changed>MyForms</SPAN>
	{
		
		...
		
	}

}
	</]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00014">
      <Name>Dictionary Class -&gt; "Dictionary" Suffix</Name>
      <Title>Dictionary class name must have "Dictionary" suffix</Title>
      <ClassName>UseCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Dictionary</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Collections.IDictionary</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type does not have correct suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type that extends certain base type, implement certain interface or 
	derived from such types should end with one of specific reserved suffixes. 
	These suffixes cannot be used in the name of other types.
	<br />
	<br />
	The table below represents base types and interfaces with corresponding 
	reserved suffixes that should be used in the names of derived types:<br />
	<table border="0" cellpadding="7" cellspacing="0">
		<tr>
			<td><b>Name of base type or interface</b></td>
			<td><b>Suffix</b></td>
		</tr>
		<tr>
			<td>System.Attribute</td>
			<td>Attribute</td>
		</tr>
		<tr>
			<td>System.EventArgs</td>
			<td>EventArgs</td>
		</tr>
		<tr>
			<td>System.Exception</td>
			<td>Exception</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.IEnumerable</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Queue</td>
			<td>Collection or Queue</td>
		</tr>
		<tr>
			<td>System.Collections.Stack</td>
			<td>Collection or Stack</td>
		</tr>
		<tr>
			<td>System.Data.DataSet</td>
			<td>Collection or DataSet</td>
		</tr>
		<tr>
			<td>System.Data.DataTable</td>
			<td>Collection or DataTable</td>
		</tr>
		<tr>
			<td>System.IO.Stream</td>
			<td>Stream</td>
		</tr>
		<tr>
			<td>System.Security.IPermission</td>
			<td>Permission</td>
		</tr>
		<tr>
			<td>System.Security.Policy.IMembershipCondition</td>
			<td>Condition</td>
		</tr>
		<tr>
			<td>An event-handler delegate.</td>
			<td>EventHandler</td>
		</tr>
	</table>
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Modify the name of the type so that it include correct suffix.<br />
	<br />
	The rule provides the following auto-correct options:
	<UL>
		<LI>
			Rename type and its references to the specified name.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dictionary class name must have "Dictionary" suffix.</li>
    <li>Generic Dictionary class name must have "Dictionary" suffix.</li>
    <li>Exception class name must have "Exception" suffix.</li>
    <li>Attribute class name must have "Attribute" suffix.</li>
    <li>Condition class name must have "Condition" suffix.</li>
    <li>Queue class name must have "Queue" suffix.</li>
    <li>Stack class name must have "Stack" suffix.</li>
    <li>Stream class name must have "Stream" suffix.</li>
    <li>Permission class name must have "Permission" suffix.</li>
    <li>EventArgs class name must have "EventArgs" suffix.</li>
    <li>DataSet class name must have "DataSet" suffix.</li>
    <li>Derived types should have correct suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>MySampleDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class <SPAN class=code-changed>MySampleDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00014">
      <Name>Generic Dictionary Class -&gt; "Dictionary" Suffix</Name>
      <Title>Generic Dictionary class name must have "Dictionary" suffix</Title>
      <ClassName>UseCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Dictionary</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Collections.Generic.Dictionary`2</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type does not have correct suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type that extends certain base type, implement certain interface or 
	derived from such types should end with one of specific reserved suffixes. 
	These suffixes cannot be used in the name of other types.
	<br />
	<br />
	The table below represents base types and interfaces with corresponding 
	reserved suffixes that should be used in the names of derived types:<br />
	<table border="0" cellpadding="7" cellspacing="0">
		<tr>
			<td><b>Name of base type or interface</b></td>
			<td><b>Suffix</b></td>
		</tr>
		<tr>
			<td>System.Attribute</td>
			<td>Attribute</td>
		</tr>
		<tr>
			<td>System.EventArgs</td>
			<td>EventArgs</td>
		</tr>
		<tr>
			<td>System.Exception</td>
			<td>Exception</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.IEnumerable</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Queue</td>
			<td>Collection or Queue</td>
		</tr>
		<tr>
			<td>System.Collections.Stack</td>
			<td>Collection or Stack</td>
		</tr>
		<tr>
			<td>System.Data.DataSet</td>
			<td>Collection or DataSet</td>
		</tr>
		<tr>
			<td>System.Data.DataTable</td>
			<td>Collection or DataTable</td>
		</tr>
		<tr>
			<td>System.IO.Stream</td>
			<td>Stream</td>
		</tr>
		<tr>
			<td>System.Security.IPermission</td>
			<td>Permission</td>
		</tr>
		<tr>
			<td>System.Security.Policy.IMembershipCondition</td>
			<td>Condition</td>
		</tr>
		<tr>
			<td>An event-handler delegate.</td>
			<td>EventHandler</td>
		</tr>
	</table>
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Modify the name of the type so that it include correct suffix.<br />
	<br />
	The rule provides the following auto-correct options:
	<UL>
		<LI>
			Rename type and its references to the specified name.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dictionary class name must have "Dictionary" suffix.</li>
    <li>Generic Dictionary class name must have "Dictionary" suffix.</li>
    <li>Exception class name must have "Exception" suffix.</li>
    <li>Attribute class name must have "Attribute" suffix.</li>
    <li>Condition class name must have "Condition" suffix.</li>
    <li>Queue class name must have "Queue" suffix.</li>
    <li>Stack class name must have "Stack" suffix.</li>
    <li>Stream class name must have "Stream" suffix.</li>
    <li>Permission class name must have "Permission" suffix.</li>
    <li>EventArgs class name must have "EventArgs" suffix.</li>
    <li>DataSet class name must have "DataSet" suffix.</li>
    <li>Derived types should have correct suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>MySampleDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class <SPAN class=code-changed>MySampleDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00014">
      <Name>Exception Class -&gt; "Exception" Suffix</Name>
      <Title>Exception class name must have "Exception" suffix</Title>
      <ClassName>UseCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Exception</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Exception</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type does not have correct suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type that extends certain base type, implement certain interface or 
	derived from such types should end with one of specific reserved suffixes. 
	These suffixes cannot be used in the name of other types.
	<br />
	<br />
	The table below represents base types and interfaces with corresponding 
	reserved suffixes that should be used in the names of derived types:<br />
	<table border="0" cellpadding="7" cellspacing="0">
		<tr>
			<td><b>Name of base type or interface</b></td>
			<td><b>Suffix</b></td>
		</tr>
		<tr>
			<td>System.Attribute</td>
			<td>Attribute</td>
		</tr>
		<tr>
			<td>System.EventArgs</td>
			<td>EventArgs</td>
		</tr>
		<tr>
			<td>System.Exception</td>
			<td>Exception</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.IEnumerable</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Queue</td>
			<td>Collection or Queue</td>
		</tr>
		<tr>
			<td>System.Collections.Stack</td>
			<td>Collection or Stack</td>
		</tr>
		<tr>
			<td>System.Data.DataSet</td>
			<td>Collection or DataSet</td>
		</tr>
		<tr>
			<td>System.Data.DataTable</td>
			<td>Collection or DataTable</td>
		</tr>
		<tr>
			<td>System.IO.Stream</td>
			<td>Stream</td>
		</tr>
		<tr>
			<td>System.Security.IPermission</td>
			<td>Permission</td>
		</tr>
		<tr>
			<td>System.Security.Policy.IMembershipCondition</td>
			<td>Condition</td>
		</tr>
		<tr>
			<td>An event-handler delegate.</td>
			<td>EventHandler</td>
		</tr>
	</table>
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Modify the name of the type so that it include correct suffix.<br />
	<br />
	The rule provides the following auto-correct options:
	<UL>
		<LI>
			Rename type and its references to the specified name.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dictionary class name must have "Dictionary" suffix.</li>
    <li>Generic Dictionary class name must have "Dictionary" suffix.</li>
    <li>Exception class name must have "Exception" suffix.</li>
    <li>Attribute class name must have "Attribute" suffix.</li>
    <li>Condition class name must have "Condition" suffix.</li>
    <li>Queue class name must have "Queue" suffix.</li>
    <li>Stack class name must have "Stack" suffix.</li>
    <li>Stream class name must have "Stream" suffix.</li>
    <li>Permission class name must have "Permission" suffix.</li>
    <li>EventArgs class name must have "EventArgs" suffix.</li>
    <li>DataSet class name must have "DataSet" suffix.</li>
    <li>Derived types should have correct suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>MySampleDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class <SPAN class=code-changed>MySampleDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00014">
      <Name>Attribute Class -&gt; "Attribute" Suffix</Name>
      <Title>Attribute class name must have "Attribute" suffix</Title>
      <ClassName>UseCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Attribute</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Attribute</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type does not have correct suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type that extends certain base type, implement certain interface or 
	derived from such types should end with one of specific reserved suffixes. 
	These suffixes cannot be used in the name of other types.
	<br />
	<br />
	The table below represents base types and interfaces with corresponding 
	reserved suffixes that should be used in the names of derived types:<br />
	<table border="0" cellpadding="7" cellspacing="0">
		<tr>
			<td><b>Name of base type or interface</b></td>
			<td><b>Suffix</b></td>
		</tr>
		<tr>
			<td>System.Attribute</td>
			<td>Attribute</td>
		</tr>
		<tr>
			<td>System.EventArgs</td>
			<td>EventArgs</td>
		</tr>
		<tr>
			<td>System.Exception</td>
			<td>Exception</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.IEnumerable</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Queue</td>
			<td>Collection or Queue</td>
		</tr>
		<tr>
			<td>System.Collections.Stack</td>
			<td>Collection or Stack</td>
		</tr>
		<tr>
			<td>System.Data.DataSet</td>
			<td>Collection or DataSet</td>
		</tr>
		<tr>
			<td>System.Data.DataTable</td>
			<td>Collection or DataTable</td>
		</tr>
		<tr>
			<td>System.IO.Stream</td>
			<td>Stream</td>
		</tr>
		<tr>
			<td>System.Security.IPermission</td>
			<td>Permission</td>
		</tr>
		<tr>
			<td>System.Security.Policy.IMembershipCondition</td>
			<td>Condition</td>
		</tr>
		<tr>
			<td>An event-handler delegate.</td>
			<td>EventHandler</td>
		</tr>
	</table>
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Modify the name of the type so that it include correct suffix.<br />
	<br />
	The rule provides the following auto-correct options:
	<UL>
		<LI>
			Rename type and its references to the specified name.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dictionary class name must have "Dictionary" suffix.</li>
    <li>Generic Dictionary class name must have "Dictionary" suffix.</li>
    <li>Exception class name must have "Exception" suffix.</li>
    <li>Attribute class name must have "Attribute" suffix.</li>
    <li>Condition class name must have "Condition" suffix.</li>
    <li>Queue class name must have "Queue" suffix.</li>
    <li>Stack class name must have "Stack" suffix.</li>
    <li>Stream class name must have "Stream" suffix.</li>
    <li>Permission class name must have "Permission" suffix.</li>
    <li>EventArgs class name must have "EventArgs" suffix.</li>
    <li>DataSet class name must have "DataSet" suffix.</li>
    <li>Derived types should have correct suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>MySampleDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class <SPAN class=code-changed>MySampleDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00014">
      <Name>Condition Class -&gt; "Condition" Suffix</Name>
      <Title>Condition class name must have "Condition" suffix</Title>
      <ClassName>UseCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Condition</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Security.Policy.IMembershipCondition</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type does not have correct suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type that extends certain base type, implement certain interface or 
	derived from such types should end with one of specific reserved suffixes. 
	These suffixes cannot be used in the name of other types.
	<br />
	<br />
	The table below represents base types and interfaces with corresponding 
	reserved suffixes that should be used in the names of derived types:<br />
	<table border="0" cellpadding="7" cellspacing="0">
		<tr>
			<td><b>Name of base type or interface</b></td>
			<td><b>Suffix</b></td>
		</tr>
		<tr>
			<td>System.Attribute</td>
			<td>Attribute</td>
		</tr>
		<tr>
			<td>System.EventArgs</td>
			<td>EventArgs</td>
		</tr>
		<tr>
			<td>System.Exception</td>
			<td>Exception</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.IEnumerable</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Queue</td>
			<td>Collection or Queue</td>
		</tr>
		<tr>
			<td>System.Collections.Stack</td>
			<td>Collection or Stack</td>
		</tr>
		<tr>
			<td>System.Data.DataSet</td>
			<td>Collection or DataSet</td>
		</tr>
		<tr>
			<td>System.Data.DataTable</td>
			<td>Collection or DataTable</td>
		</tr>
		<tr>
			<td>System.IO.Stream</td>
			<td>Stream</td>
		</tr>
		<tr>
			<td>System.Security.IPermission</td>
			<td>Permission</td>
		</tr>
		<tr>
			<td>System.Security.Policy.IMembershipCondition</td>
			<td>Condition</td>
		</tr>
		<tr>
			<td>An event-handler delegate.</td>
			<td>EventHandler</td>
		</tr>
	</table>
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Modify the name of the type so that it include correct suffix.<br />
	<br />
	The rule provides the following auto-correct options:
	<UL>
		<LI>
			Rename type and its references to the specified name.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dictionary class name must have "Dictionary" suffix.</li>
    <li>Generic Dictionary class name must have "Dictionary" suffix.</li>
    <li>Exception class name must have "Exception" suffix.</li>
    <li>Attribute class name must have "Attribute" suffix.</li>
    <li>Condition class name must have "Condition" suffix.</li>
    <li>Queue class name must have "Queue" suffix.</li>
    <li>Stack class name must have "Stack" suffix.</li>
    <li>Stream class name must have "Stream" suffix.</li>
    <li>Permission class name must have "Permission" suffix.</li>
    <li>EventArgs class name must have "EventArgs" suffix.</li>
    <li>DataSet class name must have "DataSet" suffix.</li>
    <li>Derived types should have correct suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>MySampleDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class <SPAN class=code-changed>MySampleDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00014">
      <Name>Queue Class -&gt; "Queue" Suffix</Name>
      <Title>Queue class name must have "Queue" suffix</Title>
      <ClassName>UseCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Queue</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Collections.Queue, System.Collections.Generic.Queue`1</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type does not have correct suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type that extends certain base type, implement certain interface or 
	derived from such types should end with one of specific reserved suffixes. 
	These suffixes cannot be used in the name of other types.
	<br />
	<br />
	The table below represents base types and interfaces with corresponding 
	reserved suffixes that should be used in the names of derived types:<br />
	<table border="0" cellpadding="7" cellspacing="0">
		<tr>
			<td><b>Name of base type or interface</b></td>
			<td><b>Suffix</b></td>
		</tr>
		<tr>
			<td>System.Attribute</td>
			<td>Attribute</td>
		</tr>
		<tr>
			<td>System.EventArgs</td>
			<td>EventArgs</td>
		</tr>
		<tr>
			<td>System.Exception</td>
			<td>Exception</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.IEnumerable</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Queue</td>
			<td>Collection or Queue</td>
		</tr>
		<tr>
			<td>System.Collections.Stack</td>
			<td>Collection or Stack</td>
		</tr>
		<tr>
			<td>System.Data.DataSet</td>
			<td>Collection or DataSet</td>
		</tr>
		<tr>
			<td>System.Data.DataTable</td>
			<td>Collection or DataTable</td>
		</tr>
		<tr>
			<td>System.IO.Stream</td>
			<td>Stream</td>
		</tr>
		<tr>
			<td>System.Security.IPermission</td>
			<td>Permission</td>
		</tr>
		<tr>
			<td>System.Security.Policy.IMembershipCondition</td>
			<td>Condition</td>
		</tr>
		<tr>
			<td>An event-handler delegate.</td>
			<td>EventHandler</td>
		</tr>
	</table>
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Modify the name of the type so that it include correct suffix.<br />
	<br />
	The rule provides the following auto-correct options:
	<UL>
		<LI>
			Rename type and its references to the specified name.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dictionary class name must have "Dictionary" suffix.</li>
    <li>Generic Dictionary class name must have "Dictionary" suffix.</li>
    <li>Exception class name must have "Exception" suffix.</li>
    <li>Attribute class name must have "Attribute" suffix.</li>
    <li>Condition class name must have "Condition" suffix.</li>
    <li>Queue class name must have "Queue" suffix.</li>
    <li>Stack class name must have "Stack" suffix.</li>
    <li>Stream class name must have "Stream" suffix.</li>
    <li>Permission class name must have "Permission" suffix.</li>
    <li>EventArgs class name must have "EventArgs" suffix.</li>
    <li>DataSet class name must have "DataSet" suffix.</li>
    <li>Derived types should have correct suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>MySampleDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class <SPAN class=code-changed>MySampleDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00014">
      <Name>Stack Class -&gt; "Stack" Suffix</Name>
      <Title>Stack class name must have "Stack" suffix</Title>
      <ClassName>UseCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Stack</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Collections.Stack, System.Collections.Generic.Stack`1</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type does not have correct suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type that extends certain base type, implement certain interface or 
	derived from such types should end with one of specific reserved suffixes. 
	These suffixes cannot be used in the name of other types.
	<br />
	<br />
	The table below represents base types and interfaces with corresponding 
	reserved suffixes that should be used in the names of derived types:<br />
	<table border="0" cellpadding="7" cellspacing="0">
		<tr>
			<td><b>Name of base type or interface</b></td>
			<td><b>Suffix</b></td>
		</tr>
		<tr>
			<td>System.Attribute</td>
			<td>Attribute</td>
		</tr>
		<tr>
			<td>System.EventArgs</td>
			<td>EventArgs</td>
		</tr>
		<tr>
			<td>System.Exception</td>
			<td>Exception</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.IEnumerable</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Queue</td>
			<td>Collection or Queue</td>
		</tr>
		<tr>
			<td>System.Collections.Stack</td>
			<td>Collection or Stack</td>
		</tr>
		<tr>
			<td>System.Data.DataSet</td>
			<td>Collection or DataSet</td>
		</tr>
		<tr>
			<td>System.Data.DataTable</td>
			<td>Collection or DataTable</td>
		</tr>
		<tr>
			<td>System.IO.Stream</td>
			<td>Stream</td>
		</tr>
		<tr>
			<td>System.Security.IPermission</td>
			<td>Permission</td>
		</tr>
		<tr>
			<td>System.Security.Policy.IMembershipCondition</td>
			<td>Condition</td>
		</tr>
		<tr>
			<td>An event-handler delegate.</td>
			<td>EventHandler</td>
		</tr>
	</table>
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Modify the name of the type so that it include correct suffix.<br />
	<br />
	The rule provides the following auto-correct options:
	<UL>
		<LI>
			Rename type and its references to the specified name.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dictionary class name must have "Dictionary" suffix.</li>
    <li>Generic Dictionary class name must have "Dictionary" suffix.</li>
    <li>Exception class name must have "Exception" suffix.</li>
    <li>Attribute class name must have "Attribute" suffix.</li>
    <li>Condition class name must have "Condition" suffix.</li>
    <li>Queue class name must have "Queue" suffix.</li>
    <li>Stack class name must have "Stack" suffix.</li>
    <li>Stream class name must have "Stream" suffix.</li>
    <li>Permission class name must have "Permission" suffix.</li>
    <li>EventArgs class name must have "EventArgs" suffix.</li>
    <li>DataSet class name must have "DataSet" suffix.</li>
    <li>Derived types should have correct suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>MySampleDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class <SPAN class=code-changed>MySampleDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00014">
      <Name>Stream Class -&gt; "Stream" Suffix</Name>
      <Title>Stream class name must have "Stream" suffix</Title>
      <ClassName>UseCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Stream</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.IO.Stream</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type does not have correct suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type that extends certain base type, implement certain interface or 
	derived from such types should end with one of specific reserved suffixes. 
	These suffixes cannot be used in the name of other types.
	<br />
	<br />
	The table below represents base types and interfaces with corresponding 
	reserved suffixes that should be used in the names of derived types:<br />
	<table border="0" cellpadding="7" cellspacing="0">
		<tr>
			<td><b>Name of base type or interface</b></td>
			<td><b>Suffix</b></td>
		</tr>
		<tr>
			<td>System.Attribute</td>
			<td>Attribute</td>
		</tr>
		<tr>
			<td>System.EventArgs</td>
			<td>EventArgs</td>
		</tr>
		<tr>
			<td>System.Exception</td>
			<td>Exception</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.IEnumerable</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Queue</td>
			<td>Collection or Queue</td>
		</tr>
		<tr>
			<td>System.Collections.Stack</td>
			<td>Collection or Stack</td>
		</tr>
		<tr>
			<td>System.Data.DataSet</td>
			<td>Collection or DataSet</td>
		</tr>
		<tr>
			<td>System.Data.DataTable</td>
			<td>Collection or DataTable</td>
		</tr>
		<tr>
			<td>System.IO.Stream</td>
			<td>Stream</td>
		</tr>
		<tr>
			<td>System.Security.IPermission</td>
			<td>Permission</td>
		</tr>
		<tr>
			<td>System.Security.Policy.IMembershipCondition</td>
			<td>Condition</td>
		</tr>
		<tr>
			<td>An event-handler delegate.</td>
			<td>EventHandler</td>
		</tr>
	</table>
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Modify the name of the type so that it include correct suffix.<br />
	<br />
	The rule provides the following auto-correct options:
	<UL>
		<LI>
			Rename type and its references to the specified name.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dictionary class name must have "Dictionary" suffix.</li>
    <li>Generic Dictionary class name must have "Dictionary" suffix.</li>
    <li>Exception class name must have "Exception" suffix.</li>
    <li>Attribute class name must have "Attribute" suffix.</li>
    <li>Condition class name must have "Condition" suffix.</li>
    <li>Queue class name must have "Queue" suffix.</li>
    <li>Stack class name must have "Stack" suffix.</li>
    <li>Stream class name must have "Stream" suffix.</li>
    <li>Permission class name must have "Permission" suffix.</li>
    <li>EventArgs class name must have "EventArgs" suffix.</li>
    <li>DataSet class name must have "DataSet" suffix.</li>
    <li>Derived types should have correct suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>MySampleDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class <SPAN class=code-changed>MySampleDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00014">
      <Name>Permission Class -&gt; "Permission" Suffix</Name>
      <Title>Permission class name must have "Permission" suffix</Title>
      <ClassName>UseCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Permission</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Security.IPermission</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type does not have correct suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type that extends certain base type, implement certain interface or 
	derived from such types should end with one of specific reserved suffixes. 
	These suffixes cannot be used in the name of other types.
	<br />
	<br />
	The table below represents base types and interfaces with corresponding 
	reserved suffixes that should be used in the names of derived types:<br />
	<table border="0" cellpadding="7" cellspacing="0">
		<tr>
			<td><b>Name of base type or interface</b></td>
			<td><b>Suffix</b></td>
		</tr>
		<tr>
			<td>System.Attribute</td>
			<td>Attribute</td>
		</tr>
		<tr>
			<td>System.EventArgs</td>
			<td>EventArgs</td>
		</tr>
		<tr>
			<td>System.Exception</td>
			<td>Exception</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.IEnumerable</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Queue</td>
			<td>Collection or Queue</td>
		</tr>
		<tr>
			<td>System.Collections.Stack</td>
			<td>Collection or Stack</td>
		</tr>
		<tr>
			<td>System.Data.DataSet</td>
			<td>Collection or DataSet</td>
		</tr>
		<tr>
			<td>System.Data.DataTable</td>
			<td>Collection or DataTable</td>
		</tr>
		<tr>
			<td>System.IO.Stream</td>
			<td>Stream</td>
		</tr>
		<tr>
			<td>System.Security.IPermission</td>
			<td>Permission</td>
		</tr>
		<tr>
			<td>System.Security.Policy.IMembershipCondition</td>
			<td>Condition</td>
		</tr>
		<tr>
			<td>An event-handler delegate.</td>
			<td>EventHandler</td>
		</tr>
	</table>
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Modify the name of the type so that it include correct suffix.<br />
	<br />
	The rule provides the following auto-correct options:
	<UL>
		<LI>
			Rename type and its references to the specified name.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dictionary class name must have "Dictionary" suffix.</li>
    <li>Generic Dictionary class name must have "Dictionary" suffix.</li>
    <li>Exception class name must have "Exception" suffix.</li>
    <li>Attribute class name must have "Attribute" suffix.</li>
    <li>Condition class name must have "Condition" suffix.</li>
    <li>Queue class name must have "Queue" suffix.</li>
    <li>Stack class name must have "Stack" suffix.</li>
    <li>Stream class name must have "Stream" suffix.</li>
    <li>Permission class name must have "Permission" suffix.</li>
    <li>EventArgs class name must have "EventArgs" suffix.</li>
    <li>DataSet class name must have "DataSet" suffix.</li>
    <li>Derived types should have correct suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>MySampleDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class <SPAN class=code-changed>MySampleDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00014">
      <Name>EventArgs Class -&gt; "EventArgs" Suffix</Name>
      <Title>EventArgs class name must have "EventArgs" suffix</Title>
      <ClassName>UseCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>EventArgs</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.EventArgs</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type does not have correct suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type that extends certain base type, implement certain interface or 
	derived from such types should end with one of specific reserved suffixes. 
	These suffixes cannot be used in the name of other types.
	<br />
	<br />
	The table below represents base types and interfaces with corresponding 
	reserved suffixes that should be used in the names of derived types:<br />
	<table border="0" cellpadding="7" cellspacing="0">
		<tr>
			<td><b>Name of base type or interface</b></td>
			<td><b>Suffix</b></td>
		</tr>
		<tr>
			<td>System.Attribute</td>
			<td>Attribute</td>
		</tr>
		<tr>
			<td>System.EventArgs</td>
			<td>EventArgs</td>
		</tr>
		<tr>
			<td>System.Exception</td>
			<td>Exception</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.IEnumerable</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Queue</td>
			<td>Collection or Queue</td>
		</tr>
		<tr>
			<td>System.Collections.Stack</td>
			<td>Collection or Stack</td>
		</tr>
		<tr>
			<td>System.Data.DataSet</td>
			<td>Collection or DataSet</td>
		</tr>
		<tr>
			<td>System.Data.DataTable</td>
			<td>Collection or DataTable</td>
		</tr>
		<tr>
			<td>System.IO.Stream</td>
			<td>Stream</td>
		</tr>
		<tr>
			<td>System.Security.IPermission</td>
			<td>Permission</td>
		</tr>
		<tr>
			<td>System.Security.Policy.IMembershipCondition</td>
			<td>Condition</td>
		</tr>
		<tr>
			<td>An event-handler delegate.</td>
			<td>EventHandler</td>
		</tr>
	</table>
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Modify the name of the type so that it include correct suffix.<br />
	<br />
	The rule provides the following auto-correct options:
	<UL>
		<LI>
			Rename type and its references to the specified name.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dictionary class name must have "Dictionary" suffix.</li>
    <li>Generic Dictionary class name must have "Dictionary" suffix.</li>
    <li>Exception class name must have "Exception" suffix.</li>
    <li>Attribute class name must have "Attribute" suffix.</li>
    <li>Condition class name must have "Condition" suffix.</li>
    <li>Queue class name must have "Queue" suffix.</li>
    <li>Stack class name must have "Stack" suffix.</li>
    <li>Stream class name must have "Stream" suffix.</li>
    <li>Permission class name must have "Permission" suffix.</li>
    <li>EventArgs class name must have "EventArgs" suffix.</li>
    <li>DataSet class name must have "DataSet" suffix.</li>
    <li>Derived types should have correct suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>MySampleDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class <SPAN class=code-changed>MySampleDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00014">
      <Name>DataSet Class -&gt; "DataSet" Suffix</Name>
      <Title>DataSet class name must have "DataSet" suffix</Title>
      <ClassName>UseCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>DataSet</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Data.DataSet</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type does not have correct suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type that extends certain base type, implement certain interface or 
	derived from such types should end with one of specific reserved suffixes. 
	These suffixes cannot be used in the name of other types.
	<br />
	<br />
	The table below represents base types and interfaces with corresponding 
	reserved suffixes that should be used in the names of derived types:<br />
	<table border="0" cellpadding="7" cellspacing="0">
		<tr>
			<td><b>Name of base type or interface</b></td>
			<td><b>Suffix</b></td>
		</tr>
		<tr>
			<td>System.Attribute</td>
			<td>Attribute</td>
		</tr>
		<tr>
			<td>System.EventArgs</td>
			<td>EventArgs</td>
		</tr>
		<tr>
			<td>System.Exception</td>
			<td>Exception</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.IEnumerable</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Queue</td>
			<td>Collection or Queue</td>
		</tr>
		<tr>
			<td>System.Collections.Stack</td>
			<td>Collection or Stack</td>
		</tr>
		<tr>
			<td>System.Data.DataSet</td>
			<td>Collection or DataSet</td>
		</tr>
		<tr>
			<td>System.Data.DataTable</td>
			<td>Collection or DataTable</td>
		</tr>
		<tr>
			<td>System.IO.Stream</td>
			<td>Stream</td>
		</tr>
		<tr>
			<td>System.Security.IPermission</td>
			<td>Permission</td>
		</tr>
		<tr>
			<td>System.Security.Policy.IMembershipCondition</td>
			<td>Condition</td>
		</tr>
		<tr>
			<td>An event-handler delegate.</td>
			<td>EventHandler</td>
		</tr>
	</table>
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Modify the name of the type so that it include correct suffix.<br />
	<br />
	The rule provides the following auto-correct options:
	<UL>
		<LI>
			Rename type and its references to the specified name.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dictionary class name must have "Dictionary" suffix.</li>
    <li>Generic Dictionary class name must have "Dictionary" suffix.</li>
    <li>Exception class name must have "Exception" suffix.</li>
    <li>Attribute class name must have "Attribute" suffix.</li>
    <li>Condition class name must have "Condition" suffix.</li>
    <li>Queue class name must have "Queue" suffix.</li>
    <li>Stack class name must have "Stack" suffix.</li>
    <li>Stream class name must have "Stream" suffix.</li>
    <li>Permission class name must have "Permission" suffix.</li>
    <li>EventArgs class name must have "EventArgs" suffix.</li>
    <li>DataSet class name must have "DataSet" suffix.</li>
    <li>Derived types should have correct suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>MySampleDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class <SPAN class=code-changed>MySampleDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00014">
      <Name>DataTable Class -&gt; "DataTable" Suffix</Name>
      <Title>Derived types should have correct suffix</Title>
      <ClassName>UseCertainSuffixesForDerivedTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCertainSuffixesForDerivedTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>DataTable</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Data.DataTable</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of the type or derived type does not have correct suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, the 
	name of the type that extends certain base type, implement certain interface or 
	derived from such types should end with one of specific reserved suffixes. 
	These suffixes cannot be used in the name of other types.
	<br />
	<br />
	The table below represents base types and interfaces with corresponding 
	reserved suffixes that should be used in the names of derived types:<br />
	<table border="0" cellpadding="7" cellspacing="0">
		<tr>
			<td><b>Name of base type or interface</b></td>
			<td><b>Suffix</b></td>
		</tr>
		<tr>
			<td>System.Attribute</td>
			<td>Attribute</td>
		</tr>
		<tr>
			<td>System.EventArgs</td>
			<td>EventArgs</td>
		</tr>
		<tr>
			<td>System.Exception</td>
			<td>Exception</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Generic.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.ICollection</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.IDictionary</td>
			<td>Dictionary</td>
		</tr>
		<tr>
			<td>System.Collections.IEnumerable</td>
			<td>Collection</td>
		</tr>
		<tr>
			<td>System.Collections.Queue</td>
			<td>Collection or Queue</td>
		</tr>
		<tr>
			<td>System.Collections.Stack</td>
			<td>Collection or Stack</td>
		</tr>
		<tr>
			<td>System.Data.DataSet</td>
			<td>Collection or DataSet</td>
		</tr>
		<tr>
			<td>System.Data.DataTable</td>
			<td>Collection or DataTable</td>
		</tr>
		<tr>
			<td>System.IO.Stream</td>
			<td>Stream</td>
		</tr>
		<tr>
			<td>System.Security.IPermission</td>
			<td>Permission</td>
		</tr>
		<tr>
			<td>System.Security.Policy.IMembershipCondition</td>
			<td>Condition</td>
		</tr>
		<tr>
			<td>An event-handler delegate.</td>
			<td>EventHandler</td>
		</tr>
	</table>
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Modify the name of the type so that it include correct suffix.<br />
	<br />
	The rule provides the following auto-correct options:
	<UL>
		<LI>
			Rename type and its references to the specified name.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>MustImplement</i> - Type should implement the specified type or interface;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dictionary class name must have "Dictionary" suffix.</li>
    <li>Generic Dictionary class name must have "Dictionary" suffix.</li>
    <li>Exception class name must have "Exception" suffix.</li>
    <li>Attribute class name must have "Attribute" suffix.</li>
    <li>Condition class name must have "Condition" suffix.</li>
    <li>Queue class name must have "Queue" suffix.</li>
    <li>Stack class name must have "Stack" suffix.</li>
    <li>Stream class name must have "Stream" suffix.</li>
    <li>Permission class name must have "Permission" suffix.</li>
    <li>EventArgs class name must have "EventArgs" suffix.</li>
    <li>DataSet class name must have "DataSet" suffix.</li>
    <li>Derived types should have correct suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class MySample
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class <SPAN class=code-changed>MySampleDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class MySample: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class <SPAN class=code-changed>MySampleDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00015">
      <Name>Collection Class -&gt; "Collection" Suffix</Name>
      <Title>Collection class name must have "Collection" suffix</Title>
      <ClassName>UseCollectionSuffixForCollectionType</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1710:IdentifiersShouldHaveCorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00015</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseCollectionSuffixForCollectionType.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The type implements <b>System.Collections.ICollection</b> or <b>System.Collections.IEnumerable</b>
	and its name does not have a <b>Collection</b> suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Use the <b>Collection</b> suffix for the collection types that inherit from the <b>System.Collections.CollectionBase</b>
	or <b>System.Collections.ReadOnlyCollectionBase</b>, for types that implement <b>System.Collections.IList</b>
	interface, and, more generally, for types that behave like <b>System.Collections.ArrayList</b>
	and whose members can be indexed by their position.
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should have correct suffix', CheckId <b>CA1710</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename type and its references to the specified name. 
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Collection class name must have "Collection" suffix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation

' The following Persons type implements System.Collections.ICollection interface
</SPAN>

Imports System
Imports System.Collections

Public Class Persons
    Inherits CollectionBase 

    Public Sub Add(ByVal value As PersonInfo)
        InnerList.Add(value)
    End Sub

    Public Sub AddRange(ByVal items As Persons)
        If Not items Is Nothing Then
            InnerList.AddRange(items)
        End If
    End Sub

    Public Sub AddRange(ByVal items() As PersonInfo)
        If Not items Is Nothing Then

            Dim item As CPersonInfo
            For Each item In items
                InnerList.Add(item)
            Next
        End If
    End Sub

End Class
    

<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Collections

Public Class <SPAN class=code-changed>PersonsCollection</SPAN>
    Inherits CollectionBase 

    Public Sub Add(ByVal value As PersonInfo)
        InnerList.Add(value)
    End Sub

    Public Sub AddRange(ByVal items As <SPAN class=code-changed>PersonsCollection</SPAN>)
        If Not items Is Nothing Then
            InnerList.AddRange(items)
        End If
    End Sub

    Public Sub AddRange(ByVal items() As PersonInfo)
        If Not items Is Nothing Then

            Dim item As CPersonInfo
            For Each item In items
                InnerList.Add(item)
            Next
        End If
    End Sub

End Class
    
</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation

// The following Persons type implements System.Collections.ICollection interface
</SPAN>

using System;
using System.Collections;

public class Persons: CollectionBase
{

    public void Add(PersonInfo value)
    {
        InnerList.Add(value);
    }

    public void AddRange(Persons items)
    {
        if (items != null)
        {
            InnerList.AddRange(items);
        }
    }

    public void AddRange(PersonInfo[] items)
    {
        if (items != null)
        {

            foreach (CPersonInfo item in items)
            {
                InnerList.Add(item);
            }
            
        }
    }

}
    

<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;
using System.Collections;

public class <SPAN class=code-changed>PersonsCollection</SPAN>: CollectionBase
{

    public void Add(PersonInfo value)
    {
        InnerList.Add(value);
    }

    public void AddRange(<SPAN class=code-changed>PersonsCollection</SPAN> items)
    {
        if (items != null)
        {
            InnerList.AddRange(items);
        }
    }

    public void AddRange(PersonInfo[] items)
    {
        if (items != null)
        {

            foreach (CPersonInfo item in items)
            {
                InnerList.Add(item);
            }
            
        }
    }

}
    
</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00016">
      <Name>Interface -&gt; "I" Prefix</Name>
      <Title>Use "I" prefix for Interface types</Title>
      <ClassName>UseOrAvoidCertainPrefixes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Interface</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>9/30/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1715:IdentifiersShouldHaveCorrectPrefix;CA1722:IdentifiersShouldNotHaveIncorrectPrefix;CA1713:EventsShouldNotHaveBeforeOrAfterPrefix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00016</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseOrAvoidCertainPrefixes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>PrefixUsage</Name>
          <Value>Use</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrefixToCheck</Name>
          <Value>I</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>NextCharCapitalizationStyle</Name>
          <Value>Upper</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Some programming elements have name that begins with incorrect prefix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, only 
	certain programming elements should have names that begin with a specific 
	prefix.<br /><br />
	<b>Class Naming:</b> Do not use a type prefix, such as C for class, on 
	a class name.<br />
	<br />
	For example: CPersonInfo and TEmployee are incorrect type names;
	<SPAN class="code-changed">PersonInfo</SPAN>
	and
	<SPAN class="code-changed">Employee</SPAN>
	are correct type names.
	<br />
	<br />
	<b>Interface Naming:</b> Prefix interface names with the letter I, to indicate 
	that the type is an interface.<br />
	<br />
	For example: Comparable or Disposable are incorrect interface names;
	<SPAN class="code-changed">IComparable</SPAN>
	or
	<SPAN class="code-changed">IDisposable</SPAN>
	are correct interface names.
	<br />
	<br />
	<b>Static Field Naming:</b> Do not use a Hungarian notation prefix on static 
	field names.
	<br />
	<br />
	<b>Parameter Naming:</b> Do not prefix parameter names with Hungarian type 
	notation.
	<br />
	<br />
	<b>Event Naming:</b> Do not use a prefix on the event declaration on the type.
  <br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Identifiers should have correct prefix', CheckId <b>CA1715</b></li>
		<li>'Identifiers should not have incorrect prefix', CheckId <b>CA1722</b></li>
		<li>'Events should not have before or after prefix', CheckId <b>CA1713</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Rename code element and its references to the specified name.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>PrefixUsage</i> - Should prefix be used or avoided. Possible values: None, Avoid, Use;</li>
	<li><i>PrefixToCheck</i> - Certain prefix to be checked;</li>
	<li><i>NextCharCapitalizationStyle</i> - Capitalization style of the next after 
	prefix char. Possible values: None, Lower, Upper.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Use "I" prefix for Interface types.</li>
    <li>Avoid to use "C" prefix for type names.</li>
    <li>Only Interface types should have "I" prefix.</li>
    <li>Event name must not have "Before" prefix.</li>
    <li>Event name must not have "After" prefix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class CSampleFileReader
  
    ...
  
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class <SPAN class=code-changed>SampleFileReader</SPAN>
  
    ...
  
  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class CSampleFileReader
  {
  
    ...
  
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class <SPAN class=code-changed>SampleFileReader</SPAN>
  {
  
    ...
  
  }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00016">
      <Name>Type -&gt; "C" Prefix</Name>
      <Title>Avoid to use "C" prefix for type names</Title>
      <ClassName>UseOrAvoidCertainPrefixes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface, Delegate, Struct, Enumeration</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>9/30/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1715:IdentifiersShouldHaveCorrectPrefix;CA1722:IdentifiersShouldNotHaveIncorrectPrefix;CA1713:EventsShouldNotHaveBeforeOrAfterPrefix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00016</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseOrAvoidCertainPrefixes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>PrefixUsage</Name>
          <Value>Avoid</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrefixToCheck</Name>
          <Value>C</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>NextCharCapitalizationStyle</Name>
          <Value>Upper</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Some programming elements have name that begins with incorrect prefix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, only 
	certain programming elements should have names that begin with a specific 
	prefix.<br /><br />
	<b>Class Naming:</b> Do not use a type prefix, such as C for class, on 
	a class name.<br />
	<br />
	For example: CPersonInfo and TEmployee are incorrect type names;
	<SPAN class="code-changed">PersonInfo</SPAN>
	and
	<SPAN class="code-changed">Employee</SPAN>
	are correct type names.
	<br />
	<br />
	<b>Interface Naming:</b> Prefix interface names with the letter I, to indicate 
	that the type is an interface.<br />
	<br />
	For example: Comparable or Disposable are incorrect interface names;
	<SPAN class="code-changed">IComparable</SPAN>
	or
	<SPAN class="code-changed">IDisposable</SPAN>
	are correct interface names.
	<br />
	<br />
	<b>Static Field Naming:</b> Do not use a Hungarian notation prefix on static 
	field names.
	<br />
	<br />
	<b>Parameter Naming:</b> Do not prefix parameter names with Hungarian type 
	notation.
	<br />
	<br />
	<b>Event Naming:</b> Do not use a prefix on the event declaration on the type.
  <br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Identifiers should have correct prefix', CheckId <b>CA1715</b></li>
		<li>'Identifiers should not have incorrect prefix', CheckId <b>CA1722</b></li>
		<li>'Events should not have before or after prefix', CheckId <b>CA1713</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Rename code element and its references to the specified name.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>PrefixUsage</i> - Should prefix be used or avoided. Possible values: None, Avoid, Use;</li>
	<li><i>PrefixToCheck</i> - Certain prefix to be checked;</li>
	<li><i>NextCharCapitalizationStyle</i> - Capitalization style of the next after 
	prefix char. Possible values: None, Lower, Upper.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Use "I" prefix for Interface types.</li>
    <li>Avoid to use "C" prefix for type names.</li>
    <li>Only Interface types should have "I" prefix.</li>
    <li>Event name must not have "Before" prefix.</li>
    <li>Event name must not have "After" prefix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class CSampleFileReader
  
    ...
  
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class <SPAN class=code-changed>SampleFileReader</SPAN>
  
    ...
  
  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class CSampleFileReader
  {
  
    ...
  
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class <SPAN class=code-changed>SampleFileReader</SPAN>
  {
  
    ...
  
  }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00016">
      <Name>Only Interface -&gt; "I" prefix</Name>
      <Title>Only Interface types should have "I" prefix</Title>
      <ClassName>UseOrAvoidCertainPrefixes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Delegate, Struct, Enumeration</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>9/30/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1715:IdentifiersShouldHaveCorrectPrefix;CA1722:IdentifiersShouldNotHaveIncorrectPrefix;CA1713:EventsShouldNotHaveBeforeOrAfterPrefix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00016</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseOrAvoidCertainPrefixes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>PrefixUsage</Name>
          <Value>Avoid</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrefixToCheck</Name>
          <Value>I</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>NextCharCapitalizationStyle</Name>
          <Value>Upper</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Some programming elements have name that begins with incorrect prefix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, only 
	certain programming elements should have names that begin with a specific 
	prefix.<br /><br />
	<b>Class Naming:</b> Do not use a type prefix, such as C for class, on 
	a class name.<br />
	<br />
	For example: CPersonInfo and TEmployee are incorrect type names;
	<SPAN class="code-changed">PersonInfo</SPAN>
	and
	<SPAN class="code-changed">Employee</SPAN>
	are correct type names.
	<br />
	<br />
	<b>Interface Naming:</b> Prefix interface names with the letter I, to indicate 
	that the type is an interface.<br />
	<br />
	For example: Comparable or Disposable are incorrect interface names;
	<SPAN class="code-changed">IComparable</SPAN>
	or
	<SPAN class="code-changed">IDisposable</SPAN>
	are correct interface names.
	<br />
	<br />
	<b>Static Field Naming:</b> Do not use a Hungarian notation prefix on static 
	field names.
	<br />
	<br />
	<b>Parameter Naming:</b> Do not prefix parameter names with Hungarian type 
	notation.
	<br />
	<br />
	<b>Event Naming:</b> Do not use a prefix on the event declaration on the type.
  <br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Identifiers should have correct prefix', CheckId <b>CA1715</b></li>
		<li>'Identifiers should not have incorrect prefix', CheckId <b>CA1722</b></li>
		<li>'Events should not have before or after prefix', CheckId <b>CA1713</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Rename code element and its references to the specified name.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>PrefixUsage</i> - Should prefix be used or avoided. Possible values: None, Avoid, Use;</li>
	<li><i>PrefixToCheck</i> - Certain prefix to be checked;</li>
	<li><i>NextCharCapitalizationStyle</i> - Capitalization style of the next after 
	prefix char. Possible values: None, Lower, Upper.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Use "I" prefix for Interface types.</li>
    <li>Avoid to use "C" prefix for type names.</li>
    <li>Only Interface types should have "I" prefix.</li>
    <li>Event name must not have "Before" prefix.</li>
    <li>Event name must not have "After" prefix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class CSampleFileReader
  
    ...
  
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class <SPAN class=code-changed>SampleFileReader</SPAN>
  
    ...
  
  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class CSampleFileReader
  {
  
    ...
  
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class <SPAN class=code-changed>SampleFileReader</SPAN>
  {
  
    ...
  
  }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00016">
      <Name>Event -&gt; Avoid "Before" Prefix</Name>
      <Title>Event name must not have "Before" prefix</Title>
      <ClassName>UseOrAvoidCertainPrefixes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Event</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>9/30/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1715:IdentifiersShouldHaveCorrectPrefix;CA1722:IdentifiersShouldNotHaveIncorrectPrefix;CA1713:EventsShouldNotHaveBeforeOrAfterPrefix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00016</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseOrAvoidCertainPrefixes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>PrefixUsage</Name>
          <Value>Avoid</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrefixToCheck</Name>
          <Value>Before</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>NextCharCapitalizationStyle</Name>
          <Value>Upper</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Some programming elements have name that begins with incorrect prefix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, only 
	certain programming elements should have names that begin with a specific 
	prefix.<br /><br />
	<b>Class Naming:</b> Do not use a type prefix, such as C for class, on 
	a class name.<br />
	<br />
	For example: CPersonInfo and TEmployee are incorrect type names;
	<SPAN class="code-changed">PersonInfo</SPAN>
	and
	<SPAN class="code-changed">Employee</SPAN>
	are correct type names.
	<br />
	<br />
	<b>Interface Naming:</b> Prefix interface names with the letter I, to indicate 
	that the type is an interface.<br />
	<br />
	For example: Comparable or Disposable are incorrect interface names;
	<SPAN class="code-changed">IComparable</SPAN>
	or
	<SPAN class="code-changed">IDisposable</SPAN>
	are correct interface names.
	<br />
	<br />
	<b>Static Field Naming:</b> Do not use a Hungarian notation prefix on static 
	field names.
	<br />
	<br />
	<b>Parameter Naming:</b> Do not prefix parameter names with Hungarian type 
	notation.
	<br />
	<br />
	<b>Event Naming:</b> Do not use a prefix on the event declaration on the type.
  <br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Identifiers should have correct prefix', CheckId <b>CA1715</b></li>
		<li>'Identifiers should not have incorrect prefix', CheckId <b>CA1722</b></li>
		<li>'Events should not have before or after prefix', CheckId <b>CA1713</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Rename code element and its references to the specified name.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>PrefixUsage</i> - Should prefix be used or avoided. Possible values: None, Avoid, Use;</li>
	<li><i>PrefixToCheck</i> - Certain prefix to be checked;</li>
	<li><i>NextCharCapitalizationStyle</i> - Capitalization style of the next after 
	prefix char. Possible values: None, Lower, Upper.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Use "I" prefix for Interface types.</li>
    <li>Avoid to use "C" prefix for type names.</li>
    <li>Only Interface types should have "I" prefix.</li>
    <li>Event name must not have "Before" prefix.</li>
    <li>Event name must not have "After" prefix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class CSampleFileReader
  
    ...
  
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class <SPAN class=code-changed>SampleFileReader</SPAN>
  
    ...
  
  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class CSampleFileReader
  {
  
    ...
  
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class <SPAN class=code-changed>SampleFileReader</SPAN>
  {
  
    ...
  
  }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00016">
      <Name>Event -&gt; Avoid "After" Prefix</Name>
      <Title>Event name must not have "After" prefix</Title>
      <ClassName>UseOrAvoidCertainPrefixes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Event</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>9/30/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1715:IdentifiersShouldHaveCorrectPrefix;CA1722:IdentifiersShouldNotHaveIncorrectPrefix;CA1713:EventsShouldNotHaveBeforeOrAfterPrefix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00016</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseOrAvoidCertainPrefixes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>PrefixUsage</Name>
          <Value>Avoid</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>PrefixToCheck</Name>
          <Value>After</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>NextCharCapitalizationStyle</Name>
          <Value>Upper</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Some programming elements have name that begins with incorrect prefix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, only 
	certain programming elements should have names that begin with a specific 
	prefix.<br /><br />
	<b>Class Naming:</b> Do not use a type prefix, such as C for class, on 
	a class name.<br />
	<br />
	For example: CPersonInfo and TEmployee are incorrect type names;
	<SPAN class="code-changed">PersonInfo</SPAN>
	and
	<SPAN class="code-changed">Employee</SPAN>
	are correct type names.
	<br />
	<br />
	<b>Interface Naming:</b> Prefix interface names with the letter I, to indicate 
	that the type is an interface.<br />
	<br />
	For example: Comparable or Disposable are incorrect interface names;
	<SPAN class="code-changed">IComparable</SPAN>
	or
	<SPAN class="code-changed">IDisposable</SPAN>
	are correct interface names.
	<br />
	<br />
	<b>Static Field Naming:</b> Do not use a Hungarian notation prefix on static 
	field names.
	<br />
	<br />
	<b>Parameter Naming:</b> Do not prefix parameter names with Hungarian type 
	notation.
	<br />
	<br />
	<b>Event Naming:</b> Do not use a prefix on the event declaration on the type.
  <br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Identifiers should have correct prefix', CheckId <b>CA1715</b></li>
		<li>'Identifiers should not have incorrect prefix', CheckId <b>CA1722</b></li>
		<li>'Events should not have before or after prefix', CheckId <b>CA1713</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Rename code element and its references to the specified name.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>PrefixUsage</i> - Should prefix be used or avoided. Possible values: None, Avoid, Use;</li>
	<li><i>PrefixToCheck</i> - Certain prefix to be checked;</li>
	<li><i>NextCharCapitalizationStyle</i> - Capitalization style of the next after 
	prefix char. Possible values: None, Lower, Upper.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Use "I" prefix for Interface types.</li>
    <li>Avoid to use "C" prefix for type names.</li>
    <li>Only Interface types should have "I" prefix.</li>
    <li>Event name must not have "Before" prefix.</li>
    <li>Event name must not have "After" prefix.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class CSampleFileReader
  
    ...
  
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  Imports System.IO
  Imports System.Text
  
  Public Class <SPAN class=code-changed>SampleFileReader</SPAN>
  
    ...
  
  End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class CSampleFileReader
  {
  
    ...
  
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  using System.IO;
  using System.Text;
  
  public class <SPAN class=code-changed>SampleFileReader</SPAN>
  {
  
    ...
  
  }
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00017">
      <Name>Type -&gt; Avoid "Impl" Suffix</Name>
      <Title>Avoid to use "Impl" suffix for type names</Title>
      <ClassName>UseOrAvoidCertainSuffixes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface, Delegate, Struct, Enumeration, Module, Type</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00017</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseOrAvoidCertainSuffixes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixUsage</Name>
          <Value>Avoid</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Impl</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of some type ends with incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, only 
	the names of types that extend certain base types or that implement certain 
	interfaces, or types derived from these types, should end with specific 
	reserved suffixes.<br /><br />
	<b>Event Naming:</b><br />
	- Use an <b>EventHandler</b> suffix on event handler names.<br />
	- Name an event argument class with the <b>EventArgs</b> suffix.<br />
	- Do not use a suffix on the event declaration on the type.<br />
	<br />
	<b>Attribute Naming:</b><br />
	- You should always add the suffix <b>Attribute</b> to custom attribute classes.<br />
	<br />
	<b>Enumeration Type Naming:</b><br />
	- Do not use an <b>Enum</b> suffix on <b>Enum</b> type names.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>SuffixUsage</i> - Should suffix be used or avoided. Possible values: None, 
	Avoid, Use;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid to use "Impl" suffix for type names.</li>
    <li>Avoid to use "Enum" suffix for non enumeration types.</li>
    <li>Avoid to use "Flags" suffix for non enumeration types.</li>
    <li>Avoid to use "Delegate" suffix for non delegate types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class DictionaryImpl
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class <SPAN class=code-changed>MyDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class DictionaryImpl: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class <SPAN class=code-changed>MyDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00017">
      <Name>Enumeration -&gt; Avoid "Enum" Suffix</Name>
      <Title>Avoid to use "Enum" suffix for non enumeration types</Title>
      <ClassName>UseOrAvoidCertainSuffixes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface, Delegate, Struct, Module</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00017</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseOrAvoidCertainSuffixes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixUsage</Name>
          <Value>Avoid</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Enum</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of some type ends with incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, only 
	the names of types that extend certain base types or that implement certain 
	interfaces, or types derived from these types, should end with specific 
	reserved suffixes.<br /><br />
	<b>Event Naming:</b><br />
	- Use an <b>EventHandler</b> suffix on event handler names.<br />
	- Name an event argument class with the <b>EventArgs</b> suffix.<br />
	- Do not use a suffix on the event declaration on the type.<br />
	<br />
	<b>Attribute Naming:</b><br />
	- You should always add the suffix <b>Attribute</b> to custom attribute classes.<br />
	<br />
	<b>Enumeration Type Naming:</b><br />
	- Do not use an <b>Enum</b> suffix on <b>Enum</b> type names.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>SuffixUsage</i> - Should suffix be used or avoided. Possible values: None, 
	Avoid, Use;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid to use "Impl" suffix for type names.</li>
    <li>Avoid to use "Enum" suffix for non enumeration types.</li>
    <li>Avoid to use "Flags" suffix for non enumeration types.</li>
    <li>Avoid to use "Delegate" suffix for non delegate types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class DictionaryImpl
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class <SPAN class=code-changed>MyDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class DictionaryImpl: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class <SPAN class=code-changed>MyDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00017">
      <Name>Enumeration -&gt; Avoid "Flags" Suffix</Name>
      <Title>Avoid to use "Flags" suffix for non enumeration types</Title>
      <ClassName>UseOrAvoidCertainSuffixes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface, Delegate, Struct, Module</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00017</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseOrAvoidCertainSuffixes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixUsage</Name>
          <Value>Avoid</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Flags</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of some type ends with incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, only 
	the names of types that extend certain base types or that implement certain 
	interfaces, or types derived from these types, should end with specific 
	reserved suffixes.<br /><br />
	<b>Event Naming:</b><br />
	- Use an <b>EventHandler</b> suffix on event handler names.<br />
	- Name an event argument class with the <b>EventArgs</b> suffix.<br />
	- Do not use a suffix on the event declaration on the type.<br />
	<br />
	<b>Attribute Naming:</b><br />
	- You should always add the suffix <b>Attribute</b> to custom attribute classes.<br />
	<br />
	<b>Enumeration Type Naming:</b><br />
	- Do not use an <b>Enum</b> suffix on <b>Enum</b> type names.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>SuffixUsage</i> - Should suffix be used or avoided. Possible values: None, 
	Avoid, Use;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid to use "Impl" suffix for type names.</li>
    <li>Avoid to use "Enum" suffix for non enumeration types.</li>
    <li>Avoid to use "Flags" suffix for non enumeration types.</li>
    <li>Avoid to use "Delegate" suffix for non delegate types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class DictionaryImpl
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class <SPAN class=code-changed>MyDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class DictionaryImpl: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class <SPAN class=code-changed>MyDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00017">
      <Name>Non-Delegate -&gt; Avoid "Delegate" Suffix</Name>
      <Title>Avoid to use "Delegate" suffix for non delegate types</Title>
      <ClassName>UseOrAvoidCertainSuffixes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Interface, Struct, Enumeration, Module</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1711:IdentifiersShouldNotHaveIncorrectSuffix</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00017</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseOrAvoidCertainSuffixes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>SuffixUsage</Name>
          <Value>Avoid</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>SuffixToCheck</Name>
          <Value>Delegate</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The name of some type ends with incorrect suffix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to the Microsoft naming guidelines for the .NET Framework types, only 
	the names of types that extend certain base types or that implement certain 
	interfaces, or types derived from these types, should end with specific 
	reserved suffixes.<br /><br />
	<b>Event Naming:</b><br />
	- Use an <b>EventHandler</b> suffix on event handler names.<br />
	- Name an event argument class with the <b>EventArgs</b> suffix.<br />
	- Do not use a suffix on the event declaration on the type.<br />
	<br />
	<b>Attribute Naming:</b><br />
	- You should always add the suffix <b>Attribute</b> to custom attribute classes.<br />
	<br />
	<b>Enumeration Type Naming:</b><br />
	- Do not use an <b>Enum</b> suffix on <b>Enum</b> type names.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Identifiers should not have incorrect suffix', CheckId <b>CA1711</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>SuffixUsage</i> - Should suffix be used or avoided. Possible values: None, 
	Avoid, Use;</li>
	<li><i>SuffixToCheck</i> - Certain Suffix to be checked.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid to use "Impl" suffix for type names.</li>
    <li>Avoid to use "Enum" suffix for non enumeration types.</li>
    <li>Avoid to use "Flags" suffix for non enumeration types.</li>
    <li>Avoid to use "Delegate" suffix for non delegate types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' The following example shows incorrectly named types</SPAN>

Public Class DictionaryImpl
	Implements IDictionary
	
	...
	
End Class


<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class <SPAN class=code-changed>MyDictionary</SPAN>
	Implements IDictionary
	
	...
	
End Class

	</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// The following example shows incorrectly named types</SPAN>

public class DictionaryImpl: IDictionary
{
	
	...
	
}


<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class <SPAN class=code-changed>MyDictionary</SPAN>: IDictionary
{
	
	...
	
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00018">
      <Name>Flags Enumeration -&gt; Plural Name</Name>
      <Title>Enums should have plural names depending on Flag attribute</Title>
      <ClassName>UsePluralNameForEnumWithAttribute</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Enumeration</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1714:FlagsEnumsShouldHavePluralNames;CA1717:OnlyFlagsEnumsShouldHavePluralNames</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00018</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UsePluralNameForEnumWithAttribute.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>CheckFlagEnum</Name>
          <Value>True</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[An externally visible enumeration has the <b>System.FlagsAttribute</b> attribute specified,
	but does not ends in a plural word.<br />
	<br />
	<i>Or</i><br />
	<br />
	An externally visible enumeration ends in a plural word, but does not have
	the <b>System.FlagsAttribute</b> attribute specified.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The <b>System.FlagsAttribute</b> indicates that an enumeration can be treated as a bit field;
	that is, a set of flags. Bit fields are generally used for lists of elements that might occur
	in combination, whereas enumeration constants are generally used for lists of mutually exclusive
	elements.<br /><br />
	Therefore, if only one value of an enumeration can be specified at a time, then the name of the
	enumeration should be a singular word and the enum should not be marked with
	the <b>System.FlagsAttribute</b> attribute.<br /><br />
	If more than one value of the enumeration can be specified simultaneously, then the name of the
	enumeration should be a plural word and the enum should be marked with
	the <b>System.FlagsAttribute</b> attribute.
	<br /><br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Flags enums should have plural names', CheckId <b>CA1714</b></li>
		<li>'Only FlagsAttribute enums should have plural names', CheckId <b>CA1717</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Rename externally visible enumeration according to the <b>System.FlagsAttribute</b> attribute.<br />
	<br />
  The rule provides the following auto-correct options:
  <UL>
    <li>Rename enumeration and its references to the specified name.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>CheckFlagEnum</i> - Whether check Flag or Non-Flag enumeration.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Enums should have plural names depending on Flag attribute.</li>
    <li>Enums should have plural names depending on Flag attribute.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

&lt;FlagsAttribute( )&gt; _
Enum Color
  Red = 1
  Green = 2
  Blue = 4
End Enum


<SPAN class=code-selected>' This is the correct implementation</SPAN>

&lt;FlagsAttribute( )&gt; _
Enum <SPAN class=code-changed>Colors</SPAN>
  Red = 1
  Green = 2
  Blue = 4
End Enum
	</pre>
	<p>[C#]</p> 
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

[FlagsAttribute( )]
enum Color
{
  Red = 1,
  Green = 2,
  Blue = 4
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

[FlagsAttribute( )]
enum <SPAN class=code-changed>Colors</SPAN>
{
  Red = 1,
  Green = 2,
  Blue = 4
}
	</]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="NA00018">
      <Name>Only Flags Enumeration -&gt; Plural Name</Name>
      <Title>Enums should have plural names depending on Flag attribute</Title>
      <ClassName>UsePluralNameForEnumWithAttribute</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Enumeration</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Naming</RuleCategory>
      <RuleModificationDate>12/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1714:FlagsEnumsShouldHavePluralNames;CA1717:OnlyFlagsEnumsShouldHavePluralNames</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=NA00018</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UsePluralNameForEnumWithAttribute.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>CheckFlagEnum</Name>
          <Value>False</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[An externally visible enumeration has the <b>System.FlagsAttribute</b> attribute specified,
	but does not ends in a plural word.<br />
	<br />
	<i>Or</i><br />
	<br />
	An externally visible enumeration ends in a plural word, but does not have
	the <b>System.FlagsAttribute</b> attribute specified.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The <b>System.FlagsAttribute</b> indicates that an enumeration can be treated as a bit field;
	that is, a set of flags. Bit fields are generally used for lists of elements that might occur
	in combination, whereas enumeration constants are generally used for lists of mutually exclusive
	elements.<br /><br />
	Therefore, if only one value of an enumeration can be specified at a time, then the name of the
	enumeration should be a singular word and the enum should not be marked with
	the <b>System.FlagsAttribute</b> attribute.<br /><br />
	If more than one value of the enumeration can be specified simultaneously, then the name of the
	enumeration should be a plural word and the enum should be marked with
	the <b>System.FlagsAttribute</b> attribute.
	<br /><br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Flags enums should have plural names', CheckId <b>CA1714</b></li>
		<li>'Only FlagsAttribute enums should have plural names', CheckId <b>CA1717</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[Rename externally visible enumeration according to the <b>System.FlagsAttribute</b> attribute.<br />
	<br />
  The rule provides the following auto-correct options:
  <UL>
    <li>Rename enumeration and its references to the specified name.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
	<li><i>CheckFlagEnum</i> - Whether check Flag or Non-Flag enumeration.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Enums should have plural names depending on Flag attribute.</li>
    <li>Enums should have plural names depending on Flag attribute.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

&lt;FlagsAttribute( )&gt; _
Enum Color
  Red = 1
  Green = 2
  Blue = 4
End Enum


<SPAN class=code-selected>' This is the correct implementation</SPAN>

&lt;FlagsAttribute( )&gt; _
Enum <SPAN class=code-changed>Colors</SPAN>
  Red = 1
  Green = 2
  Blue = 4
End Enum
	</pre>
	<p>[C#]</p> 
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

[FlagsAttribute( )]
enum Color
{
  Red = 1,
  Green = 2,
  Blue = 4
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

[FlagsAttribute( )]
enum <SPAN class=code-changed>Colors</SPAN>
{
  Red = 1,
  Green = 2,
  Blue = 4
}
	</]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="PE00007">
      <Name>Class -&gt; Avoid unsealed attributes</Name>
      <Title>Avoid unsealed attributes</Title>
      <ClassName>AvoidUnsealedAttributes</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Performance</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Performance, CA1813:AvoidUnsealedAttributes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=PE00007</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidUnsealedAttributes.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A type inherits from <b>System.Attribute</b>, is not <b>abstract</b>, 
  and is not <b>sealed</b> (<b>NotInheritable</b> in Visual Basic).]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, classes for custom attributes should 
  be <b>sealed</b> (<b>NotInheritable</b> in Visual Basic), unless rare cases when you need 
  to inherit from the custom attribute.<br />
  <br />
  The .NET Framework methods for retrieving custom attributes, such as 
  <b>System.Attribute.GetCustomAttribute</b>, search the attribute inheritance hierarchy, 
  which can be a time consuming operation. Sealing the attribute class can improve performance, 
  eliminating the search through the inheritance hierarchy.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Avoid unsealed attributes', CheckId <b>CA1813</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
        <LI>Change type modifier to <b>sealed</b>.
        <LI>Change type modifier to <b>abstract</b>.
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid unsealed attributes.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

Imports System

&lt;AttributeUsage(AttributeTargets.Class Or AttributeTargets.Struct)&gt;  _
Public Class CustomUserAttribute ' class is not abstract and is not sealed
    Inherits Attribute
    
    Private m_Name As String
    
    Public Sub New(ByVal name As String)
        m_Name = name
    End Sub
    
    
    Public ReadOnly Property Name() As String
        Get
            Return m_Name
        End Get
    End Property
    
End Class 


<SPAN class="code-selected">' This is the correct implementation</SPAN>

Imports System

&lt;AttributeUsage(AttributeTargets.Class Or AttributeTargets.Struct)&gt;  _
Public <SPAN class="code-changed">NotInheritable</SPAN> Class CustomUserAttribute
    Inherits Attribute
    
    Private m_Name As String
    
    Public Sub New(ByVal name As String)
        m_Name = name
    End Sub
    
    
    Public ReadOnly Property Name() As String
        Get
            Return m_Name
        End Get
    End Property
    
End Class 

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
public class CustomUserAttribute: Attribute // class is not abstract and is not sealed
{
    
    private string m_Name;
    
    public CustomUserAttribute(string name)
    {
        m_Name = name;
    }
    
    
    public string Name()
    {
        get
        {
            return m_Name;
        }
    }
    
}


<SPAN class="code-selected">// This is the correct implementation</SPAN>

using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
public <SPAN class="code-changed">static</SPAN> class CustomUserAttribute: Attribute // class is not abstract and is not sealed
{
    
    private string m_Name;
    
    public CustomUserAttribute(string name)
    {
        m_Name = name;
    }
    
    
    public string Name()
    {
        get
        {
            return m_Name;
        }
    }
    
}

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="PE00008">
      <Name>Type -&gt; Remove if unused</Name>
      <Title>Remove unused internal classes</Title>
      <ClassName>RemoveUnusedInternalClasses</ClassName>
      <Scope>Internal, Private</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Struct</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Performance</RuleCategory>
      <RuleModificationDate>8/12/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Performance, CA1812:AvoidUninstantiatedInternalClasses</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=PE00008</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/RemoveUnusedInternalClasses.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The type is not externally visible and its instance is not created by code within the assembly.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Assembly-level (private or internal) types, that does not instantiated in the assembly, 
  increase the size of an assembly and degrade performance.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Avoid uninstantiated internal classes', CheckId <b>CA1812</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Comment out the type.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Remove unused internal classes.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="PE00012">
      <Name>Public Type -&gt; Remove if unused</Name>
      <Title>Remove unused public classes</Title>
      <ClassName>RemoveUnusedClasses</ClassName>
      <Scope>Public</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Struct</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Performance</RuleCategory>
      <RuleModificationDate>5/31/2011</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Performance, CA1812:AvoidUninstantiatedInternalClasses</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=PE00012</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/RemoveUnusedClasses.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The type is externally visible and its instance is not created by code within the assembly.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Public types, that does not instantiated in the assembly, 
  increase the size of an assembly and degrade performance.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Avoid uninstantiated internal classes', CheckId <b>CA1812</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Comment out the type.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Remove unused public classes.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="PE00010">
      <Name>Field -&gt; Do not initialize unnecessarily</Name>
      <Title>Do not initialize unnecessarily</Title>
      <ClassName>DoNotInitializeUnnecessarily</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Field</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Performance</RuleCategory>
      <RuleModificationDate>12/30/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Performance, CA1805:DoNotInitializeUnnecessarily</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=PE00010</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotInitializeUnnecessarily.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The field is initialized with its default value.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The fields, that is initialized with its default value in the constructor, 
  increase the size of an assembly and degrade performance. Such initialization is redundant, because
  the CLR (Common Language Runtime) initializes all fields with their default values before running the constructor.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not initialize unnecessarily', CheckId <b>CA1805</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Remove the field initialization.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not initialize unnecessarily.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

Imports System

Public Class MyClass
			
  Dim BoolField As Boolean
  Dim IntField As Integer
  Dim DoubleField As Double
  Dim StringField As String

  Sub New()

    ' The following initializations violate the rule
    BoolField = False
    IntField = 0
    DoubleField = 0
    StringField = Nothing

  End Sub

  ...

End Class


<SPAN class="code-selected">' This is the correct implementation</SPAN>

Imports System

Public Class MyClass
			
  Public BoolField As Boolean
  Public IntField As Integer
  Public DoubleField As Double
  Public StringField As String

  Sub New()

    ' Redundant initializations are removed

  End Sub

  ...

End Class

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

using System;

public class MyClass
{
    
  bool BoolField;
  int IntField;
  double DoubleField;
  string StringField;

  public MyClass()
  {

    // The following initializations violate the rule
    BoolField = false;
    IntField = 0;
    DoubleField = 0;
    StringField = null;

  }

  ...

}


<SPAN class="code-selected">// This is the correct implementation</SPAN>

using System;

public class MyClass
{
    
  bool BoolField;
  int IntField;
  double DoubleField;
  string StringField;

  public MyClass()
  {

    // Redundant initializations are removed

  }

  ...

}

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="PE00011">
      <Name>Check for an empty string using Equals -&gt; Do not use</Name>
      <Title>Do not check for empty strings using Equals</Title>
      <ClassName>DoNotCheckForEmptyStringsUsingEquals</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Expression</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Performance</RuleCategory>
      <RuleModificationDate>8/23/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Performance, CA1820:TestForEmptyStringsUsingStringLength</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=PE00011</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotCheckForEmptyStringsUsingEquals.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A string should not be compared to an empty string using <b>System.Object.Equals</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[<b>Length</b> property of a string should be compared with zero, rather than comparing a string with "" or <b>String.Empty</b>.
  <br />
  This technique delivers better performance.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Test for empty strings using string length', CheckId <b>CA1820</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
				<LI>Change the comparison to use the <b>IsNullOrEmpty(System.String)</b> method and test for the null string.</LI>
				<LI>Change the comparison to use the Length property and test for the null string.</LI>
				<LI>Change the comparison to use the <b>IsNullOrEmpty(System.String)</b> method.</LI>
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not check for empty strings using Equals.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

  Public Function JoinWords(words() As String, delimeter As String) As String

    Dim s As String = String.Empty
    Dim result As String = String.Empty
    Dim i As Integer

    For i = 0 To words.Length - 1
      s = words(i)
      If s &lt;&gt; "" Then ' Violates the rule
        If result = String.Empty Then ' Violates the rule
          result = s
        Else
          result &= delimeter & s
        End If
      End If
    Next i

    Return result

  End Function

<SPAN class="code-selected">' This is the correct implementation</SPAN>

  Public Function JoinWords(words() As String, delimeter As String) As String

    Dim s As String = String.Empty
    Dim result As String = String.Empty
    Dim i As Integer

    For i = 0 To words.Length - 1
      s = words(i)
      If <span class="code-changed">s.Length &lt;&gt; 0</span> Then
        If <span class="code-changed">result.Length = 0</span> Then
          result = s
        Else
          result &= delimeter & s
        End If
      End If
    Next i

    Return result

  End Function

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

  public string JoinWords(string[] words, string delimeter)
  {
    string s = String.Empty;
    string result = String.Empty;
    for (int i = 0; i &lt; words.Length; i++)
    {
      s = words[i];
      if (s != "") // Violates the rule
      {
        if (result == String.Empty) // Violates the rule
        {
          result = s;
        }
        else
        {
          result += delimeter + s;
        }
      }
    }
    return result;
  }

<SPAN class="code-selected">// This is the correct implementation</SPAN>

  public string JoinWords(string[] words, string delimeter)
  {
    string s = String.Empty;
    string result = String.Empty;
    for (int i = 0; i &lt; words.Length; i++)
    {
      s = words[i];
      if (<span class="code-changed">s.Length</span> != 0)
      {
        if (<span class="code-changed">result.Length</span> == 0)
        {
          result = s;
        }
        else
        {
          result += delimeter + s;
        }
      }
    }
    return result;
  }

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="PE00009">
      <Name>Field -&gt; Use constants where appropriate</Name>
      <Title>Use constants where appropriate</Title>
      <ClassName>UseConstantsWhereAppropriate</ClassName>
      <Scope>Internal, Private, Static, Readonly</Scope>
      <Severity>Warning</Severity>
      <Targets>Field</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Performance</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Performance, CA1802:UseLiteralsWhereAppropriate</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=PE00009</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/UseConstantsWhereAppropriate.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The field is declared as <b>static</b> and <b>readonly</b> (<b>Shared</b> and <b>ReadOnly</b> in Visual Basic), 
	but is initialized with a constant value.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The value of a <b>static readonly</b> (<b>Shared ReadOnly</b> in Visual Basic) field 
  is computed at runtime when the static constructor is called. If a static constructor 
  is not declared explicitly, the compiler emits it to initialize the field.<br />
  <br />
  The value of the <b>const</b> (<b>Const</b> in Visual Basic) field is computed in the 
  compile time and stored in the metadata. That increases runtime performance. Therefore, 
  <b>const</b> (<b>Const</b> in Visual Basic) field should be used instead of <b>static 
  readonly</b> (<b>Shared ReadOnly</b> in Visual Basic) field if the value of the field 
  is computable in the compile time.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Use literals where appropriate', CheckId <b>CA1802</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Replace <b>static readonly</b> (<b>Shared ReadOnly</b> in Visual Basic) modifiers with the <b>const</b> 
    (<b>Const</b> in Visual Basic) modifier.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Use constants where appropriate.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

Imports System

Public Class MyClass
			
  Shared ReadOnly IntField As Integer = 2
  Shared ReadOnly DoubleField As Double = IntField * 3.14
  Shared ReadOnly StringField As String = "string"

  ...

End Class


<SPAN class="code-selected">' This is the correct implementation</SPAN>

Imports System

Public Class MyClass
			
  Const IntField As Integer = 2
  Const DoubleField As Double = IntField * 3.14
  Const StringField As String = "string"

  ...

End Class

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

using System;

public class MyClass
{
    
  static readonly int IntField = 2;
  static readonly double DoubleField = IntField * 3.14;
  static readonly string StringField = "string";

  ...

}


<SPAN class="code-selected">// This is the correct implementation</SPAN>

using System;

public class MyClass
{
    
  const int IntField = 2;
  const double DoubleField = IntField * 3.14;
  const string StringField = "string";

  ...

}

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="PE00001">
      <Name>Dispose -&gt; Type -&gt; Dispose methods should call SuppressFinalize</Name>
      <Title>Dispose methods should call SuppressFinalize</Title>
      <ClassName>DisposeMethodsShouldCallSuppressFinalize</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Performance</RuleCategory>
      <RuleModificationDate>3/13/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Performance, CA1816:DisposeMethodsShouldCallSuppressFinalize</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=PE00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DisposeMethodsShouldCallSuppressFinalize.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A type implements <b>System.IDisposable.Dispose</b>, but does not prevent the <b>Finalize</b>
	method from running by calling the <b>GC.SuppressFinalize</b> method.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[<b>IDisposable.Dispose</b> method performs application-defined tasks associated 
	with freeing, releasing, or resetting unmanaged resources. Because the <b>Dispose</b>
	method must be called explicitly, objects that implement <b>IDisposable</b> must 
	also implement a finalizer to handle freeing resources when <b>Dispose</b> is 
	not called. By default, the garbage collector will automatically call an 
	object's finalizer prior to reclaiming its memory. However, once the <b>Dispose</b>
	method has been called, it is typically unnecessary for the garbage collector 
	to call the disposed object's finalizer. To prevent automatic finalization, <b>Dispose</b>
	implementations can call the <b>GC.SuppressFinalize</b> method.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Dispose methods should call SuppressFinalize', CheckId <b>CA1816</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<LI>
			Find the <b>Dispose</b> method and insert call to <b>GC.SuppressFinalize</b> at 
			the end of the method.</LI>
	</UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dispose methods should call SuppressFinalize.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example shows the basic design pattern for implementing <b>Dispose</b> 
	that satisfies the rule.
	<br />
	<p>[Visual Basic]</p>
	<pre class="code">
Public Class Sample
  Implements IDisposable
		
  ' Implement IDisposable
  
  Public Overloads Sub Dispose() Implements IDisposable.Dispose
    Dispose(True)
    GC.SuppressFinalize(Me)
  End Sub

  Protected Overloads Overridable Sub Dispose(disposing As Boolean)
    If disposing Then
      ' Free other state (managed objects).
    End If
    ' Free your own state (unmanaged objects).
    ' Set large fields to null.
  End Sub

  Protected Overrides Sub Finalize()
    ' Simply call Dispose(False).
    Dispose (False)
  End Sub
		
End Class
	
	</pre>
	<p>[C#]</p>
	<pre class="code">
public class Sample: IDisposable
{
		
  // Implement IDisposable
  
  public void Dispose()
  {
    Dispose(true);
    GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing)
  {
    if (disposing)
    {
      // Free other state (managed objects).
    }
    // Free your own state (unmanaged objects).
    // Set large fields to null.
  }

  ~Sample()
  {
    Dispose(false);
  }
		
}
	
	</]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="PE00002">
      <Name>Value Type -&gt; Override equals and operator equals</Name>
      <Title>Override equals and operator equals on value types</Title>
      <ClassName>OverrideEqualsAndOperatorEqualsOnValueTypes</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Struct</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Performance</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Performance, CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=PE00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/OverrideEqualsAndOperatorEqualsOnValueTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Equality operator <b>==</b> does not implemented by the public value type.<br />
	<br />
	Or<br />
	<br />
	<b>System.Object.Equals</b> does not overrided by the public value type.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The inherited implementation of <B>Equals</B> for value types compares the contents of all fields
	using the Reflection library, which is computationally expensive.<br /><br />
	The following guidelines should be considered for implementing a value type:
	<ul>
    <li>Consider overriding <b>Equals</b> to gain increased performance over that provided by the default implementation of <b>Equals</b> on <b>ValueType</b>.</li>
    <li>If you override <b>Equals</b> and the language supports operator overloading, you must overload the equality operator for your value type.</li>
  </ul>
	<i>This rule is similar to <b>FxCop</b> rule 'Override equals and operator equals on value types', CheckId <b>CA1815</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Override <b>System.Object.Equals</b> method.</LI>
    <LI>Implement the equality operator.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Override equals and operator equals on value types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Imports System
  
  Public Structure Point
    Private _x As Integer
    Private _y As Integer

    Public Sub New(ByVal x As Integer, ByVal y As Integer)
      _x = x
      _y = y
    End Sub

    Public ReadOnly Property X As Integer
      Get
        Return _x
      End Get
    End Property

    Public ReadOnly Property Y As Integer
      Get
        Return _y
      End Get
    End Property

  End Structure


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Imports System
  
  Public Structure Point
    Private _x As Integer
    Private _y As Integer

    Public Sub New(ByVal x As Integer, ByVal y As Integer)
      _x = x
      _y = y
    End Sub

    Public ReadOnly Property X As Integer
      Get
        Return _x
      End Get
    End Property

    Public ReadOnly Property Y As Integer
      Get
        Return _y
      End Get
    End Property
    
    Public Overloads Function GetHashCode() As Integer
      Return _x Xor _y
    End Function

    Public Overloads Function Equals(ByVal obj As Object) As Boolean
        If Not (TypeOf obj Is Point) Then
            Return False
        End If
        Return Equals(CType(obj, Point))
    End Function

    Public Overloads Function Equals(ByVal other As Point) As Boolean
        If _x &lt;&gt; other.X Then
            Return False
        End If
        Return _y = other.Y
    End Function

    Public Shared Operator ==(ByVal point1 As Point, ByVal point2 As Point) As Boolean
      Return point1.Equals(point2)
    End Operator

    Public Shared Operator &lt;&gt;(ByVal point1 As Point, ByVal point2 As Point) As Boolean
      Return Not point1.Equals(point2)
    End Operator
    
  End Structure
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  using System;
  
  public struct Point
  {
    private int _x;
    private int _y;

    public Point(int x, int y)
    {
      _x = x;
      _y = y;
    }

    public int X
    {
      get
      {
        return _x;
      }
    }

    public int Y
    {
      get
      {
        return _y;
      }
    }

  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  using System;
  
  public struct Point
  {
    private int _x;
    private int _y;

    public Point(int x, int y)
    {
      _x = x;
      _y = y;
    }

    public int X
    {
      get
      {
        return _x;
      }
    }

    public int Y
    {
      get
      {
        return _y;
      }
    }
    
    public override int GetHashCode()
    {
      return _x ^ _y;
    }

    public override bool Equals(object obj)
    {
        if (obj.GetType() != typeof(Point)
        {
            return false;
        }
        return Equals((Point)obj);
    }

    public override bool Equals(Point other)
    {
        if (_x != other.X)
        {
            return false;
        }
        return _y == other.Y;
    }

    public static bool operator==(Point point1, Point point2)
    {
      return point1.Equals(point2);
    }

    public static operator!=(Point point1, Point point2)
    {
      return !point1.Equals(point2);
    }
    
  }
	
	</]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="PE00005">
      <Name>Property -&gt; Should not return arrays</Name>
      <Title>Properties should not return arrays</Title>
      <ClassName>PropertiesShouldNotReturnArrays</ClassName>
      <Scope>Public, Protected</Scope>
      <Severity>Warning</Severity>
      <Targets>Property</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Performance</RuleCategory>
      <RuleModificationDate>1/20/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Performance, CA1819:PropertiesShouldNotReturnArrays</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=PE00005</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/PropertiesShouldNotReturnArrays.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A public or protected property in a public type returns an array.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The property must return a copy of the array, to keep the array tamper-proof, because of arrays 
  returned by properties are not write-protected. Calling of such property affects performance 
  negatively. According to Microsoft .NET Framework guidelines, a method should be used when returning array.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Properties should not return arrays', CheckId <b>CA1819</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Convert property to getter and/or setter method.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Properties should not return arrays.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

Imports System

Public Class Persons

    Private _names As String()

    Public Sub New(ByVal names As String())
        _names = names
    End Sub

    ' Violates the rule: the public property returns array
    Public ReadOnly Property Names() As String()
        Get
            Return CType(_names.Clone(), String())
        End Get
    End Property

End Class
 

<SPAN class="code-selected">' This is the correct implementation</SPAN>

Imports System

Public Class Persons

    Private _names As String()

    Public Sub New(ByVal names As String())
        _names = names
    End Sub

    ' Correct implementation: the property converted to method
    <SPAN class="code-changed">Public Function GetNames() As String()</SPAN>
        Return CType(_names.Clone(), String())
    <SPAN class="code-changed">End Function</SPAN>

End Class


	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

using System;

public class Persons
{

    private string[] _names;

    public Persons(string[] names)
    {
        _names = names;
    }

    // Violates the rule: the public property returns array
    public string[] Names
    {
        get
        {
            return (string[])_names.Clone();
        }
    }

}
 

<SPAN class="code-selected">// This is the correct implementation</SPAN>

using System;

public class Persons
{

    private string[] _names;

    public Persons(string[] names)
    {
        _names = names;
    }

    // Correct implementation: the property converted to method
    <SPAN class="code-changed">public string[] GetNames()</SPAN>
    {
        return (string[])_names.Clone();
    }

}


	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="PE00006">
      <Name>Finalize -&gt; Method -&gt; Remove if empty</Name>
      <Title>Remove empty finalizers</Title>
      <ClassName>RemoveEmptyFinalizers</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Performance</RuleCategory>
      <RuleModificationDate>3/13/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Performance, CA1821:RemoveEmptyFinalizers</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=PE00006</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/RemoveEmptyFinalizers.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A type implements a finalizer that is empty or calls only the base type finalizer.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The protected <b>Finalize</b> method should only be implemented if the type must 
  release one ore more unmanaged resources that it has directly allocated. 
  Unnecessary <b>Finalize</b> method results in overhead at instantiation and suboptimal 
  usage of memory.<br />
  The entire finalizer should be enclosed in <b>#if DEBUG</b> / <b>#endif</b> directives, 
  if it is required for debugging.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Remove empty finalizers', CheckId <b>CA1821</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
        <LI>Comment out the empty finalizer.
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Remove empty finalizers.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

Public Class TestClass1

    Private Message As String

    ' Rule violation: empty finalizer
    Protected Overrides Sub Finalize()
    End Sub
    
End Class 


Public Class TestClass2

    Private Message As String

    ' Rule violation: if the DEBUG directive is not present, the finalizer will be empty
    Protected Overrides Sub Finalize()
    
        Debug.Print(Message)
    
    End Sub
    
End Class 


<SPAN class="code-selected">' This is the correct implementation</SPAN>

Public Class TestClass2

    Private Message As String

    ' Correct implementation: the finalizer is not empty when the DEBUG directive is present
<SPAN class="code-changed">#if DEBUG</SPAN>
    Protected Overrides Sub Finalize()
    
        Debug.Print(Message)
    
    End Sub
<SPAN class="code-changed">#endif</SPAN>    
    
End Class 

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

public class TestClass1
{

    private string message;

    // Rule violation: empty finalizer
    ~TestClass1()
    {
    }
    
}


public class TestClass2
{

    private string message;

    // Rule violation: if the DEBUG directive is not present, the finalizer will be empty
    ~TestClass1()
    {
    
        Debug.Print(message);
    
    }
    
}


<SPAN class="code-selected">// This is the correct implementation</SPAN>

public class TestClass2
{

    private string message;

    // Correct implementation: the finalizer is not empty when the DEBUG directive is present
<SPAN class="code-changed">#if DEBUG</SPAN>
    ~TestClass1()
    {
    
        Debug.Print(message);
    
    }
<SPAN class="code-changed">#endif</SPAN>    
    
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="PE00003">
      <Name>Method -&gt; Remove unused locals</Name>
      <Title>Remove unused locals</Title>
      <ClassName>RemoveUnusedLocals</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method, Operator</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Performance</RuleCategory>
      <RuleModificationDate>2/5/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Performance, CA1804:RemoveUnusedLocals</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=PE00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/RemoveUnusedLocals.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A method declares a local variable, but does not use the variable except possibly 
    as the recipient of an assignment statement.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Unused local variables and unnecessary assignments increase the size of an assembly and degrade performance.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Remove unused locals', CheckId <b>CA1804</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
      <UL>
        <LI>Comment out the declaration of the local variable.
      </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Remove unused locals.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class="code-selected">' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Windows.Forms

Public Class TestClass1
    
    ' Rule violation: local variables are not used in the method and therefore unnecessary
    Sub TestMethod()
      
         Dim i As Integer
         Dim s As String = "Test string"
         Dim textBox1 As New TextBox()
         Dim myIntArray() As Integer = {1, 2, 3, 4, 5}

    End Sub
    
End Class 

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class="code-selected">// This code will trigger the rule violation</SPAN>

using System;
using System.Windows.Forms;

public class TestClass1
{
    
    // Rule violation: local variables are not used in the method and therefore unnecessary
    public void TestMethod()
    {
      
         int i;
         string s = "Test string";
         TextBox textBox1 = new TextBox();
         int[] myIntArray = new int[5] {1, 2, 3, 4, 5};

    }
    
}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="PE00004">
      <Name>Method -&gt; Remove if unused</Name>
      <Title>Remove unused private methods</Title>
      <ClassName>RemoveUnusedPrivateMethods</ClassName>
      <Scope>Private</Scope>
      <Severity>Warning</Severity>
      <Targets>Method, Operator</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Performance</RuleCategory>
      <RuleModificationDate>1/18/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Performance, CA1811:AvoidUncalledPrivateCode</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=PE00004</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/RemoveUnusedPrivateMethods.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A method does not have callers in the assembly.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Assembly-level (private or internal) methods, that does not have callers in the assembly, 
  and is not invoked by a delegate or by the CLR, increase the size of an assembly and degrade performance.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Avoid uncalled private code', CheckId <b>CA1811</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Comment out the uncalled method.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Remove unused private methods.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="SE00002">
      <Name>Class -&gt; Should only extend aptca base types</Name>
      <Title>Aptca types should only extend aptca base types</Title>
      <ClassName>AptcaTypesShouldExtendAptcaBaseTypes</ClassName>
      <Scope>Public</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>10/13/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2117:AptcaTypesShouldOnlyExtendAptcaBaseTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AptcaTypesShouldExtendAptcaBaseTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Type in the assembly derives from the type declared in another assembly that 
	does not have <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, types in assemblies marked with the 
  <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute shouldn't 
  derive from types defined in assemblies that aren't marked with the 
  <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute. (By 
  default, public and protected types in strong-named assemblies are protected with 
  an <b>InheritanceDemand</b>, but the 
  <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute disables this protection.)<br />
  <br />
  <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute can be applied only to 
  strong-named assemblies that are meant to be called from partially trusted assemblies. (By 
  default, strong-named assemblies can be called only by fully trusted assemblies.)<br />
  <br />
  The security issue occurs when a type in an assembly marked with the  
  <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute inherits from a type 
  in another assembly that isn't marked with this attribute and that is supposed to contain 
  private data. In that case, untrusted caller gain access to information that should be 
  available to fully trusted types only.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Aptca types should only extend aptca base types', CheckId <b>CA2117</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<LI>Add <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute to the 
		assembly</LI>
		<LI>Remove <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute 
		from the assembly</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Aptca types should only extend aptca base types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

' This type contains private data in an assembly 
' that is NOT marked with <b>System.Security.AllowPartiallyTrustedCallersAttribute</b>
Public Class LoginData
    Public ReadOnly Name As String = "John Smith"
    Public ReadOnly Password As String = "pass"
End Class

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

' This type is placed in an assembly 
' marked with <b>System.Security.AllowPartiallyTrustedCallersAttribute</b>

&lt;Assembly: AllowPartiallyTrustedCallers()&gt;

Public Class PersonalData
    Inherits LoginData
    
    Public Overrides Function ToString() As String
        Return Me.Name & ", " & Me.Password
    End Function
    
End Class


' The main assembly isn't fully trusted but can read private data.
Sub Main()
    Dim data As New PersonalData
    Console.WriteLine(data) ' Displays "John Smith, pass"
End Sub


<SPAN class=code-selected>' This is the correct implementation</SPAN>

' Mark the first assembly with the 
' <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute, 
' if it is possible

<SPAN class=code-changed>&lt;Assembly: AllowPartiallyTrustedCallers()&gt;</SPAN>

Public Class LoginData
    Public ReadOnly Name As String = "John Smith"
    Public ReadOnly Password As String = "pass"
End Class


&lt;Assembly: AllowPartiallyTrustedCallers()&gt;

Public Class PersonalData
    Inherits LoginData
    
    Public Overrides Function ToString() As String
        Return Me.Name & ", " & Me.Password
    End Function
    
End Class


' Alternatively, the <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute
' should be removed from the second assembly
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

// This type contains private data in an assembly 
// that is NOT marked with <b>System.Security.AllowPartiallyTrustedCallersAttribute</b>
public class LoginData
{
    public readonly string Name = "John Smith";
    Public readonly string Password = "pass";
}

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

// This type is placed in an assembly 
// marked with <b>System.Security.AllowPartiallyTrustedCallersAttribute</b>

[assembly:AllowPartiallyTrustedCallers()]

public class PersonalData: LoginData
{
    
    public override string ToString()
    {
        return this.Name + ", " + this.Password;
    }
    
}


// The main assembly isn't fully trusted but can read private data.
static void Main()
{
    PersonalData data = new PersonalData();
    Console.WriteLine(data); // Displays "John Smith, pass"
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

// Mark the first assembly with the 
// <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute, 
// if it is possible

<SPAN class=code-changed>[Assembly: AllowPartiallyTrustedCallers()]</SPAN>

public class LoginData
{
    public readonly string Name = "John Smith";
    Public readonly string Password = "pass";
}


[assembly:AllowPartiallyTrustedCallers()]

public class PersonalData: LoginData
{
    
    public override string ToString()
    {
        return this.Name + ", " + this.Password;
    }
    
}


// Alternatively, the <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute
// should be removed from the second assembly
	
	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00006">
      <Name>Assembly -&gt; Should declare minimum security</Name>
      <Title>Assemblies should declare minimum security</Title>
      <ClassName>AssembliesShouldDeclareMinimumSecurity</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Project</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>7/30/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2209:AssembliesShouldDeclareMinimumSecurity</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00006</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AssembliesShouldDeclareMinimumSecurity.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Assembly does not have attributes specifying its minimum, optional, or refused security permissions.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Assemblies should be marked with permission attributes specifying suitable <b>RequestMinimum</b>, 
	<b>RequestOptional</b>, and <b>RequestRefuse</b> actions.<br />
	<br />
	This rule ensures that the assembly has only the permissions that it strictly needs for its chores. 
	By reducing the prmission set assigned to the assembly, you make it harder for malicious code to exploit 
	your assembly to access protected resources.<br />
	<br />
	The <b>RequestMinimum</b> action specifies the permissions that are necessary for the assembly 
	to work correctly; if the .NET runtime can't grant these permissions, the assembly won't be 
	loaded and a <b>System.Security.Policy.PolicyException</b> is thrown. The <b>RequestOptional</b> 
	action specifies the permissions that the assembly would like to use but that aren't crucial 
	for its operations; if one of these permissions isn't granted, the assembly loads all the same, 
	but its user interfaceshould disable or hide all commands that would perform a prohibited 
	action. The <b>RequestRefuse</b> action specifies permissionsthat the .NET runtime should 
	never grant to the assembly.<br />
	<br />
	The permission set granted to the assembly consists of all the permissions marked with the 
	<b>RequestMinimum</b> action, plus all the permissions marked with the <b>RequestOptional</b> 
	action, minus all the permissions marked with the <b>RequestRefuse</b> action. In all cases, 
	however, an assembly won't be given permissions that aren't granted by the policy level and 
	the code group the assembly belongs to.
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Assemblies should declare minimum security', CheckId <b>CA2209</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Add suitable attribute to the assembly.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Assemblies should declare minimum security.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example shows the attributes that can be applied to an assembly that requires 
  permission to create user interface elements and access files by means of common file 
  dialogs, that wants to be granted permission to use performance counters (but that can 
  run without them), and that explicitly refuses to receive the permission to call 
  unmanaged code:<br />
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

Imports System
Imports System.Security
Imports System.Security.Permissions

&lt;Assembly: UIPermission(SecurityAction.RequestMinimum, Unrestricted:=True)&gt;
&lt;Assembly: FileDialogPermission(SecurityAction.RequestMinimum, Unrestricted:=True)&gt;
&lt;Assembly: PerformanceCounterPermission(SecurityAction.RequestOptional, Unrestricted:=True)&gt;
&lt;Assembly: SecurityPermission(SecurityAction.RequestRefuse, UnmanagedCode:=True)&gt;

Namespace UserLibrary

	...

End Namespace

</pre>
	<p>[C#]</p> 
	<pre class="code">

using System;
using System.Security;
using System.Security.Permissions;

[assembly:UIPermission(SecurityAction.RequestMinimum, Unrestricted=true)]
[assembly:FileDialogPermission(SecurityAction.RequestMinimum, Unrestricted=true)]
[assembly:PerformanceCounterPermission(SecurityAction.RequestOptional, Unrestricted=true)]
[assembly:SecurityPermission(SecurityAction.RequestRefuse, UnmanagedCode=true)]

namespace UserLibrary
{

	...

}

</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00019">
      <Name>Field -&gt; Array fields should not be read only</Name>
      <Title>Array fields should not be read only</Title>
      <ClassName>ArrayFieldsShouldNotBeReadOnly</ClassName>
      <Scope>Public, Protected</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Field</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2105:ArrayFieldsShouldNotBeReadOnly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00019</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ArrayFieldsShouldNotBeReadOnly.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[An externally visible field that holds an array is declared read-only.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, a field should be marked with the <b>ReadOnly</b> (Visual Basic) 
  or <b>readonly</b> (C#) keyword if the value of the field must not change after instantiation. If a read-only field 
  contains an array, the reference to the array cannot be changed. However, the elements of such array can be changed.
  Therefore, an externally visible read-only field that holds an array maight be exploited and cause security 
  vulnerability.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Array fields should not be read only', CheckId <b>CA2105</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Change field modifier and create a method that returns a clone of an array.</LI>
		<LI>Manually replace the array with a strongly typed collection that cannot be changed.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Array fields should not be read only.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Namespace SecureData

  Public Class AccountManager
		
    Public ReadOnly AccountValues As Decimal() = {10000, 20000, 30000}

    ...

  End Class

End Namespace 


' This class can use and modify secure data in the read-only field
Public Class AccountsProcessor

  Public Sub ProcessAccounts()

    Dim Accounts As AccountManager = New AccountManager()

    Dim values As Decimal() = Accounts.AccountValues

    ' the element of the read-only array was modified
    values(1) = 100000

  End Sub

End Class



<SPAN class=code-selected>' This is the correct implementation</SPAN>

Namespace SecureData

  Public Class AccountManager
		
    ' Field visibility changed from <b>Public</b> to <b>Private</b>
    <SPAN class=code-changed>Private</SPAN> AccountValues As Decimal() = {10000, 20000, 30000}

    ' New method returns a clone of an array
    <SPAN class=code-changed>Public Function GetAccountValues() As Decimal()

      Return CType(AccountValues.Clone(), Decimal())

    End Function</SPAN>
    
    ...

  End Class

End Namespace 


' This class can use and secure data, but cannot modify
Public Class AccountsProcessor

  Public Sub ProcessAccounts()

    Dim Accounts As AccountManager = New AccountManager()

    Dim values As Decimal() = Accounts.<SPAN class=code-changed>GetAccountValues()</SPAN>

    ' Local copy of data was modified.
    values(1) = 100000
    ' Secure data in the AccountManager class stays unchanged.

  End Sub

End Class

' Alternatively, the AccountValues array can be replaced 
' with a strongly typed collection that cannot be changed
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

namespace SecureData
{

  public class AccountManager
  {
		
    public readonly decimal[] AccountValues = new decimal[3]{10000, 20000, 30000};

    ...

  }

}


// This class can use and modify secure data in the read-only field
public class AccountsProcessor
{

  public void ProcessAccounts()
  {

    AccountManager Accounts = new AccountManager();

    decimal[] values = Accounts.AccountValues;

    // the element of the read-only array was modified
    values[1] = 100000;

  }

}



<SPAN class=code-selected>// This is the correct implementation</SPAN>

namespace SecureData
{

  public class AccountManager
  {
		
    // Field visibility changed from <b>Public</b> to <b>Private</b>
    <SPAN class=code-changed>private</SPAN> decimal[] AccountValues = new decimal[3] {10000, 20000, 30000};

    // New method returns a clone of an array
    <SPAN class=code-changed>public decimal[] GetAccountValues()
    {

      return (decimal[])AccountValues.Clone();

    }</SPAN>
    
    ...

  }

}


// This class can use and secure data, but cannot modify
public class AccountsProcessor
{

  public void ProcessAccounts()
  {

    AccountManager Accounts = new AccountManager();

    decimal[] values = Accounts.<SPAN class=code-changed>GetAccountValues()</SPAN>;

    // Local copy of data was modified.
    values[1] = 100000;
    // Secure data in the AccountManager class stays unchanged.

  }

}

// Alternatively, the AccountValues array can be replaced 
// with a strongly typed collection that cannot be changed
	
	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00020">
      <Name>Method -&gt; Aptca methods should only call aptca methods</Name>
      <Title>Aptca methods should only call aptca methods</Title>
      <ClassName>AptcaMethodsShouldOnlyCallAptcaMethods</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>12/8/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2116:AptcaMethodsShouldOnlyCallAptcaMethods</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00020</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AptcaMethodsShouldOnlyCallAptcaMethods.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Method in an assembly with the <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute calls 
  method in assembly that does not have the attribute.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, methods in assemblies marked with the 
  <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute should call methods in another assembly 
  only if the other assembly is also marked with the <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute. 
  This guideline ensures that untrusted assemblies cannot use the assembly marked with 
  <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute to call into an assembly that isn't supposed 
  to be available to untruted callers.<br />
  <br />
  Methods in assemblies marked with the <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute 
  should always demand one or more permissions from callers; exceptions to this rule are sometimes necessary 
  but you should carefully review your code to ensure that untrusted assemblies cannot use your 
  public methods to perform dangerous actions.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Aptca methods should only call aptca methods', CheckId <b>CA2116</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<LI>Add <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> attribute to the assembly</LI>
		<LI>Remove <b>System.Security.AllowPartiallyTrustedCallersAttribute</b> from the assembly</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Aptca methods should only call aptca methods.</li>
  </ul>]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="SE00021">
      <Name>Method -&gt; Wrap vulnerable finally clauses in outer try</Name>
      <Title>Wrap vulnerable finally clauses in outer try</Title>
      <ClassName>WrapVulnerableFinallyClausesInOuterTry</ClassName>
      <Scope>Public, Protected</Scope>
      <Severity>Error</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>1/21/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2124:WrapVulnerableFinallyClausesInOuterTry</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00021</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/WrapVulnerableFinallyClausesInOuterTry.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[An externally visible method contains a try-finally block. 
	The finally block appears to reset security state and is not enclosed in a finally block.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, always should be added a <b>Catch</b> 
  (<b>catch</b> in C#) clause that traps all exceptions if the code in the <b>Try</b> 
  (<b>try</b> in C#) block modifies any property of the current thread in a way that 
  might be exploited by malicious code, for example, by impersonating a user with higher 
  privileges.<br />
  <br />
  A malicious exception filters presented in the call stack might execute before the <b>Finally</b> 
  (<b>finally</b> in C#) block. An exception filter is a <b>When</b> clause implemented in Visual Basic.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Wrap vulnerable finally clauses in outer try', CheckId <b>CA2124</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<LI>Wrap the finally clause in an outer try block with an associated catch that simply rethrows.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Wrap vulnerable finally clauses in outer try.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class ServerTasks

  ' Violation: Try/Finally block is not wrapped.
  Public Shared Sub PerformTask()
    Try
      ' Impersonate a different, more privileged user here.
      Dim WindowsImpersonationContext impersonationContext = WindowsIdentity.Impersonate(privilegedUserToken)
      
      ...
      
    Finally
      ' Revert to original user.
      impersonationContext.Undo()
      
      ...
      
    End Try
  End Sub
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class ServerTasks

  Public Shared Sub PerformTask()
    <SPAN class=code-changed>Try</SPAN>
      Try
        ' Impersonate a different, more privileged user here.
        Dim WindowsImpersonationContext impersonationContext = WindowsIdentity.Impersonate(privilegedUserToken)
      
        ...
      
      Finally
        ' Revert to original user.
        impersonationContext.Undo()
      
        ...
      
      End Try
    <SPAN class=code-changed>Catch
      Throw
    End Try</SPAN>
  End Sub
End Class

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class ServerTasks
{

  // Violation: Try/Finally block is not wrapped.
  public static void PerformTask()
  {
    try
    {
      // Impersonate a different, more privileged user here.
      WindowsImpersonationContext impersonationContext = WindowsIdentity.Impersonate(privilegedUserToken);
      
      ...
    
    }  
    finally
    {
      // Revert to original user.
      impersonationContext.Undo();      
    }
  }
}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

public class ServerTasks
{

  public static void PerformTask()
  {
    <SPAN class=code-changed>try</SPAN>
    {
      try
      {
        // Impersonate a different, more privileged user here.
        WindowsImpersonationContext impersonationContext = WindowsIdentity.Impersonate(privilegedUserToken);
      
        ...
    
      }  
      finally
      {
        // Revert to original user.
        impersonationContext.Undo();
        
        ...
      
      }
    }
    <SPAN class=code-changed>catch
    {
      throw;
    }</SPAN>
  }
}

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00018">
      <Name>Method -&gt; Security should be a superset of type</Name>
      <Title>Method security should be a superset of type</Title>
      <ClassName>MethodSecurityShouldBeASupersetOfType</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>10/9/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2114:MethodSecurityShouldBeASupersetOfType</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00018</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/MethodSecurityShouldBeASupersetOfType.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Type has declarative security and its method has declarative security for the same 
	security action, and the security action is not <b>LinkDemand</b> or <b>InheritanceDemand</b>, 
	and the permissions checked by the type are not a subset of the permissions checked by the method.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[If the same declarative security action is applied to both a type and one of its methods, 
  the permission checked at the method level should be more restrictive than the permission 
  checked at the type level. (This gudeline doesn't apply to <b>LinkDemand</b> actions.)<br />
  <br />
  If you mark both a type and one of its methods for the same security action but for a different 
  range of permissions, the two permissions are not combined together. Instead, the type-level 
  permission is ignored and only the method-level permission is applied.<br />
  <br />
  If this guideline is ignored, malicious code might bypass the more restrictive type-level 
  permissions by obtaining an istance of the type by some other means - for example, using 
  a factory method exposed by a trusted assembly - and then invoke the method without any 
  security exception.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Method security should be a superset of type', CheckId <b>CA2114</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<LI>Add required attribute(s) to the method.</LI>
		<LI>Remove required attribute(s) from the type.</LI>
		<LI>Remove required attribute(s) from the method.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Method security should be a superset of type.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

&lt;FileIOPermission(SecurityAction.Demand, Unresticted:=True)&gt; _
Public Class FileProcessing
  
  &lt;FileIOPermission(SecurityAction.Demand, Read:="C:\Text")&gt; _
  Public Function GetFile(ByVal fileName As String) As String
  
    ...
    
  End Function
  
  ...
  
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

&lt;FileIOPermission(SecurityAction.Demand, Unresticted:=True)&gt; _
Public Class FileProcessing
  
  Public Function GetFile(ByVal fileName As String) As String
  
    ...
    
  End Function
  
  ...
  
End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

[FileIOPermission(SecurityAction.Demand, Unresticted = true)]
public class FileProcessing
{
  
  [FileIOPermission(SecurityAction.Demand, Read = "C:\Text")]
  public string GetFile(string fileName)
  {
  
    ...
    
  }
  
  ...
  
}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

[FileIOPermission(SecurityAction.Demand, Unresticted = true)]
public class FileProcessing
{
  
  public string GetFile(string fileName)
  {
  
    ...
    
  }
  
  ...
  
}
	
	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00017">
      <Name>Struct -&gt; Review declarative security</Name>
      <Title>Review declarative security on value types</Title>
      <ClassName>ReviewDeclarativeSecurityOnValueTypes</ClassName>
      <Scope>Public, Protected</Scope>
      <Severity>Error</Severity>
      <Targets>Struct</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>10/8/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2108:ReviewDeclarativeSecurityOnValueTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00017</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ReviewDeclarativeSecurityOnValueTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[An externally visible structure is secured by <b>System.Security.Permissions.SecurityAction.Demand</b> or 
	<b>System.Security.Permissions.SecurityAction.LinkDemand</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, a value type or its default constructor should not be 
  protected with an imperative <b>System.Security.Permissions.SecurityAction.Demand</b> or 
  <b>System.Security.Permissions.SecurityAction.LinkDemand</b> security action.<br />
  <br />
  The .NET Framework allocates and initializes value types by means of their default 
  (parameterless) constructor, and then executes any constructor with parameters explicitly 
  invoked by the caller. If such a constructor is protected with a 
  <b>System.Security.Permissions.SecurityAction.Demand</b> or 
  <b>System.Security.Permissions.SecurityAction.LinkDemand</b> security action and the caller 
  doesn't pass the security check, the .NET Framework throws an exception, but the instance of the 
  value type still exists (as initialized by the default constructor) and its members can be used freely.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Review declarative security on value types', CheckId <b>CA2108</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
	  <LI>Remove attribute(s) from the structure.</LI>
	  <LI>Remove attribute(s) from the constructor.</LI>
	  <LI>Remove demand or link demand from the constructor manually.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Review declarative security on value types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

' Violation: structure should not be protected with <b>System.Security.Permissions.SecurityAction.Demand</b>
&lt;System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.Demand, Name := "FullTrust")&gt; _
Public Class Point

  Public X As Double
  Public Y As Double

  Sub New(ByVal x As Double, ByVal y As Double)
    Me.X = x
    Me.Y = y
  End Sub

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System

' Attribute has been removed
Public Class Point

  Public X As Double
  Public Y As Double

  Sub New(ByVal x As Double, ByVal y As Double)
    Me.X = x
    Me.Y = y
  End Sub

End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

// Violation: structure should not be protected with <b>System.Security.Permissions.SecurityAction.Demand</b>
[System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.Demand, Name = "FullTrust")]
public class Point
{

  public double X;
  public double Y;

  Point(double x, double y)
  {
    this.X = x;
    this.Y = y;
  }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;

// Attribute has been removed
public class Point
{

  public double X;
  public double Y;

  Point(double x, double y)
  {
    this.X = x;
    this.Y = y;
  }

}
	
	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00016">
      <Name>Method -&gt; Review deny and permit only usage</Name>
      <Title>Review deny and permit only usage</Title>
      <ClassName>ReviewDenyAndPermitOnlyUsage</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalWarning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>9/30/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2107:ReviewDenyAndPermitOnlyUsage</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00016</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ReviewDenyAndPermitOnlyUsage.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A method contains a security check that specifies the 
  <b>System.Security.Permissions.SecurityAction.PermitOnly</b> or 
  <b>System.Security.Permissions.SecurityAction.Deny</b> security action.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The <b>System.Security.Permissions.SecurityAction.PermitOnly</b> action defines a white list 
  containing only the permissions that should be granted, whereas the 
  <b>System.Security.Permissions.SecurityAction.Deny</b> action defines a black list containing 
  all the permissions that should not be granted. According to Microsoft .NET Framework guidelines, 
  white lists are preferable to black lists, therefore <b>System.Security.Permissions.SecurityAction.PermitOnly</b> 
  action is favorable over <b>System.Security.Permissions.SecurityAction.Deny</b> action. However,
  it is quite impactical to deny all the permissions that considered potentially dangerous and it is 
  difficult to anticipate all the permissions that might be required.<br />
  <br />
  Unreasoned using of <b>System.Security.Permissions.SecurityAction.Deny</b> and <b
  >System.Security.Permissions.SecurityAction.PermitOnly</b> security actions might alter the 
  default behavior of the stack walk. Therefore, code that uses these security actions should be 
  carefully evaluated by specialists in .NET Framework security.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Review deny and permit only usage', CheckId <b>CA2107</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
	  <LI>Remove attribute(s) from the method.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Review declarative security on value types.</li>
  </ul>
    <p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="SE00015">
      <Name>Method -&gt; Review visible event handlers</Name>
      <Title>Review visible event handlers</Title>
      <ClassName>ReviewVisibleEventHandlers</ClassName>
      <Scope>Public, Protected</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2109:ReviewVisibleEventHandlers</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00015</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ReviewVisibleEventHandlers.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[An externally visible event-handling method was detected.<br />
  <br />
  <b>- OR -</b><br />
  <br />
  An externally visible method was detected that is decorated with a security demand 
  and exposing an <b>EventArgs</b> parameter.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, private scope should be 
  used for all event handlers.<br />
  <br />
  The <b>Demand</b> security action checks whether an untrusted caller is in the call stack 
  but cannot check whether the handler was added to the event source by untrusted code; also, 
  the permission might be asserted at the time the event is raised. Therefore, malicious 
  clients might attach your event handler to an event source so that your handler unknowingly 
  executes dangerous code on behalf of the untrusted client.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Review visible event handlers', CheckId <b>CA2109</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
	  <LI>Change method modifier to <b>Private</b> (<b>private</b> in C#).</LI>
	  <LI>Change method modifier to <b>Friend</b> (<b>internal</b> in C#).</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Review visible event handlers.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System

Public Class EventHandler
	
  ' Violation: event-handling method is public
  Public Sub HandleSomeEvent(sender As Object, e As EventArgs)
  
  ...
  
  End Sub

  ...

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System

Public Class EventHandler
	
  ' Correct implementation
  <SPAN class=code-changed>Private</SPAN> Sub HandleSomeEvent(sender As Object, e As EventArgs)
  
  ...
  
  End Sub

  ...

End Class
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;

public class EventHandler
{
	
  // Violation: event-handling method is public
  public void HandleSomeEvent(object sender, EventArgs e)
  {
  
  ...
  
  }

  ...

}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

using System;

public class EventHandler
{
	
  <SPAN class=code-changed>private</SPAN> void HandleSomeEvent(object sender, EventArgs e)
  {
  
  ...
  
  }

  ...

}
	
	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00014">
      <Name>Type -&gt; Secure serialization constructors</Name>
      <Title>Secure serialization constructors</Title>
      <ClassName>SecureSerializationConstructors</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Class, Struct</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>9/29/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2120:SecureSerializationConstructors</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SecureSerializationConstructors.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Type implements the <b>System.Runtime.Serialization.ISerializable</b> interface, has a 
  serialization constructor 	with the <b> System.Runtime.Serialization.SerializationInfo</b>, 
	<b>System.Runtime.Serialization.StreamingContext</b> parameter signature.
	This constructor is not secured by a security check, but one or more of the regular 
	constructors in the type is secured.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, the constructor implied by the 
  <b>System.Runtime.Serialization.ISerializable</b> interface should be protected 
  with the same security actions used to protect other constructors.<br />
  <br />
  Ignoring this guideline might result in a security risk because a malicious caller 
  might serialize an instance obtained through a factory method exposed by a trusted 
  assembly and then create a copy of it at a later time.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Secure serialization constructors', CheckId <b>CA2120</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Add required attribute(s) to the serialization constructor.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Secure serialization constructors.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions
Imports System.Runtime.Serialization

&lt;Assembly: AllowPartiallyTrustedCallersAttribute()&gt;

&lt;Serializable()&gt; _
Public Class Person
    Implements ISerializable

    Private _firstName As String
    Private _lastName As String
    
    Public ReadOnly Property FirstName() As String
        Get
            Return _firstName
        End Get
    End Property

    Public ReadOnly Property LastName() As String
        Get
            Return _lastName
        End Get
    End Property

    &lt;SecurityPermission(SecurityAction.Demand, ControlPrincipal:=True)&gt; _
    Public Sub New(ByVal firstName As String, ByVal lastName As String)
        Me._firstName = firstName
        Me._lastName = lastName
    End Sub

    ' Violation: Serialization constructor does not protected 
    ' with the same security action as regular constructor
    Protected Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)
        _firstName = CType(info.GetValue("_firstName", GetType(String)), String)
        _lastName = CType(info.GetValue("_lastName", GetType(String)), String)
    End Sub

    Public Overridable Sub GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext) _
        Implements ISerializable.GetObjectData

        info.AddValue("_firstName", _firstName)
        info.AddValue("_lastName", _lastName)
    End Sub

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions
Imports System.Runtime.Serialization

&lt;Assembly: AllowPartiallyTrustedCallersAttribute()&gt;

&lt;Serializable()&gt; _
Public Class Person
    Implements ISerializable

    Private _firstName As String
    Private _lastName As String
    
    Public ReadOnly Property FirstName() As String
        Get
            Return _firstName
        End Get
    End Property

    Public ReadOnly Property LastName() As String
        Get
            Return _lastName
        End Get
    End Property

    &lt;SecurityPermission(SecurityAction.Demand, ControlPrincipal:=True)&gt; _
    Public Sub New(ByVal firstName As String, ByVal lastName As String)
        Me._firstName = firstName
        Me._lastName = lastName
    End Sub

    ' Serialization constructor demands same permissions as regular constructor
    <SPAN class=code-changed>&lt;SecurityPermission(SecurityAction.Demand, ControlPrincipal:=True)&gt; _</SPAN>
    Protected Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)
        _firstName = CType(info.GetValue("_firstName", GetType(String)), String)
        _lastName = CType(info.GetValue("_lastName", GetType(String)), String)
    End Sub

    Public Overridable Sub GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext) _
        Implements ISerializable.GetObjectData

        info.AddValue("_firstName", _firstName)
        info.AddValue("_lastName", _lastName)
    End Sub

End Class

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;
using System.Runtime.Serialization;

[assembly:AllowPartiallyTrustedCallersAttribute()]

[Serializable()]
public class Person: ISerializable
{

    private string _firstName;
    private string _lastName;
    
    public string FirstName()
    {
        get
        {
            return _firstName;
        }
    }

    public string LastName()
    {
        get
        {
            return _lastName;
        }
    }

    [SecurityPermission(SecurityAction.Demand, ControlPrincipal = true)]
    public Person(string firstName, string lastName)
    {
        this._firstName = firstName;
        this._lastName = lastName;
    }

    // Violation: Serialization constructor does not protected 
    // with the same security action as regular constructor
    protected Person(SerializationInfo info, StreamingContext context)
    {
        _firstName = (string)info.GetValue("_firstName", string.GetType());
        _lastName = (string)info.GetValue("_lastName", string.GetType());
    }

    public virtual void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
    {

        info.AddValue("_firstName", _firstName);
        info.AddValue("_lastName", _lastName);
    }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;
using System.Runtime.Serialization;

[assembly:AllowPartiallyTrustedCallersAttribute()]

[Serializable()]
public class Person: ISerializable
{

    private string _firstName;
    private string _lastName;
    
    public string FirstName()
    {
        get
        {
            return _firstName;
        }
    }

    public string LastName()
    {
        get
        {
            return _lastName;
        }
    }

    [SecurityPermission(SecurityAction.Demand, ControlPrincipal = true)]
    public Person(string firstName, string lastName)
    {
        this._firstName = firstName;
        this._lastName = lastName;
    }

    ' Serialization constructor demands same permissions as regular constructor
    <SPAN class=code-changed>[SecurityPermission(SecurityAction.Demand, ControlPrincipal = true)]</SPAN>
    protected Person(SerializationInfo info, StreamingContext context)
    {
        _firstName = (string)info.GetValue("_firstName", string.GetType());
        _lastName = (string)info.GetValue("_lastName", string.GetType());
    }

    public virtual void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
    {

        info.AddValue("_firstName", _firstName);
        info.AddValue("_lastName", _lastName);
    }

}

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00013">
      <Name>Public/Protected Instance Field -&gt; Do not declare in protected with link demand type</Name>
      <Title>Secured types should not expose fields</Title>
      <ClassName>SecuredTypesShouldNotExposeFields</ClassName>
      <Scope>Public, Protected</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Field</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2112:SecuredTypesShouldNotExposeFields</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00013</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SecuredTypesShouldNotExposeFields.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Externally visible type is protected with a <b>System.Security.Permissions.SecurityAction.LinkDemand</b>, 
  has public field.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, types protected with 
  <b>System.Security.Permissions.SecurityAction.LinkDemand</b> security action 
  should not expose public fields because this action protects only properties and methods. 
  If an assembly without all necessary permissions can grab a reference to an instance of a 
  type protected with a <b>System.Security.Permissions.SecurityAction.LinkDemand</b> security 
  action, the assembly can freely access all the public fields.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Secured types should not expose fields', CheckId <b>CA2112</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Change field modifier to <b>Private</b> (<b>private</b> in C#).</LI>
    <LI>Create public property from the field.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Secured types should not expose fields.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace AccountsManagement
	
  &lt;System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name := "FullTrust")&gt; _
  Public Class Account

    ' Violation: fields are not secured
    Public AccountNumber As String
    Public AccountValue As Decimal

    Sub New(ByVal accountNumber As String, ByVal accountValue As Decimal)
      Me.AccountNumber = accountNumber
      Me.AccountValue = accountValue
    End Sub
    
  End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace AccountsManagement
	
  &lt;System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name := "FullTrust")&gt; _
  Public Class Account

    <SPAN class=code-changed>Private _accountNumber</SPAN> As String
    <SPAN class=code-changed>Private _accountValue</SPAN> As Decimal

    Sub New(ByVal accountNumber As String, ByVal accountValue As Decimal)
      Me.<SPAN class=code-changed>_accountNumber</SPAN> = accountNumber
      Me.<SPAN class=code-changed>_accountValue</SPAN> = accountValue
    End Sub

    <SPAN class=code-changed>Public Property AccountNumber() As String
      Get

        Return _accountNumber

      End Get

      Set(ByVal value As String)

        _accountNumber = value

      End Set
    End Property

    Public Property AccountValue() As Decimal
      Get

        Return _accountValue

      End Get

      Set(ByVal value As Decimal)

        _accountValue = value

      End Set
    End Property</SPAN>

  End Class

End Namespace

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace AccountsManagement
{
	
  [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name = "FullTrust")]
  public class Account
  {

    // Violation: fields are not secured
    public string AccountNumber;
    public decimal AccountValue;

    Account(string accountNumber, decimal accountValue)
    {
      this.AccountNumber = accountNumber;
      this.AccountValue = accountValue;
    }
    
  }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace AccountsManagement
{
	
  [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name = "FullTrust")]
  public class Account
  {

    <SPAN class=code-changed>private string _accountNumber</SPAN>;
    <SPAN class=code-changed>private decimal _accountValue</SPAN>;

    Account(string accountNumber, decimal accountValue)
    {
      this.<SPAN class=code-changed>_accountNumber</SPAN> = accountNumber;
      this.<SPAN class=code-changed>_accountValue</SPAN> = accountValue;
    }

    <SPAN class=code-changed>public string AccountNumber
    {
      get
      {

        return _accountNumber;

      }

      set
      {

        _accountNumber = value;

      }
    }

    public decimal AccountValue
    {
      get
      {

        return _accountValue;

      }

      set
      {

        _accountValue = value;

      }
    }</SPAN>

  }

}

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00012">
      <Name>Type -&gt; Link demands require inheritance demands</Name>
      <Title>Type link demands require inheritance demands</Title>
      <ClassName>TypeLinkDemandsRequireInheritanceDemands</ClassName>
      <Scope>Public, Protected</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>9/25/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2126:TypeLinkDemandsRequireInheritanceDemands</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00012</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/TypeLinkDemandsRequireInheritanceDemands.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Externally visible unsealed type is protected with a link demand, has an overridable 
  method, and neither the type nor the method is protected with an inheritance demand.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, a type level 
  <b>SecurityAction.InheritanceDemand</b> action should be used for any nonsealed type 
  that is marked with a <b>SecurityAction.LinkDemand</b> action if the type has one or 
  more <b>Overridable</b> (<b>virtual</b> in C#) methods. Alternatively, 
  <b>SecurityAction.InheritanceDemand</b> action should be used for each virtual method.
  (The <b>SecurityAction.InheritanceDemand</b> action has no effect on nonvirtual members.)<br />
  <br />
  Protecting an overridable member with a <b>SecurityAction.LinkDemand</b> action isn't 
  sufficient if the type isn't sealed because malicious code might wait until a trusted 
  assembly invokes (and indirectly JIT-compiles) the protected method and then instantiate 
  an object that derives from the secured type but overrides the virtual member.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Type link demands require inheritance demands', CheckId <b>CA2126</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<LI>Apply inheritance demands for the same permission as the type link demand to the type.</LI>
		<LI>Apply inheritance demands for the same permission as the type link demand to the method.</LI>
		<LI>Apply inheritance demands for the same permission as the method link demand to the type.</LI>
		<LI>Apply inheritance demands for the same permission as the method link demand to the method.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Type link demands require inheritance demands.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace DocumentsProcessing

  &lt;FileIOPermission(SecurityAction.LinkDemand, Unrestricted := True)&gt; _
  Public Class Document
		
	' Violation: the method is not secured with an inheritance demand
    Public Overridable Function GetDocumentText() As String
		
      ...
			
    End Function
		
  End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace DocumentsProcessing

  &lt;FileIOPermission(SecurityAction.LinkDemand, Unrestricted := True)&gt; _
  Public Class Document
		
    <SPAN class=code-changed>&lt;FileIOPermission(SecurityAction.InheritanceDemand, Unrestricted := True)&gt; _</SPAN>
    Public Overridable Function GetDocumentText() As String
		
      ...
			
    End Function
		
  End Class

End Namespace

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace DocumentsProcessing
{

  [FileIOPermission(SecurityAction.LinkDemand, Unrestricted = true)]
  public class Document
  {
		
	// Violation: the method is not secured with an inheritance demand
    public virtual string GetDocumentText()
    {
		
      ...
			
    }
		
  }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace DocumentsProcessing
{

  [FileIOPermission(SecurityAction.LinkDemand, Unrestricted = true)]
  public class Document
  {
		
    <SPAN class=code-changed>[FileIOPermission(SecurityAction.InheritanceDemand, Unrestricted = true)]</SPAN>
    public virtual string GetDocumentText()
    {
		
      ...
			
    }
		
  }

}

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00011">
      <Name>Method -&gt; Secure asserts</Name>
      <Title>Secure asserts</Title>
      <ClassName>SecureAsserts</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>2/2/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2106:SecureAsserts</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00011</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SecureAsserts.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The method asserts a permission and no security checks are performed on the caller member.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Because calling Assert removes the requirement that all code in the call chain must be granted 
  permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.
  If you assert a permission without performing any checks on the caller, the 
  caller might be able to indirectly execute code using your permissions.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Secure asserts', CheckId <b>CA2106</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<LI>Add a security demand (<b>System.Security.PermissionSet(SecurityAction.LinkDemand)</b>) to the 
		method or type.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Secure asserts.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace SystemLibrary

  Public Class SystemClass
		
    Private DataFiles() As String
		
    ...
		
    &lt;System.Security.SecurityCritical()&gt; _
    Public Sub ProcessDataFile(fileName As String)
      Dim filePermission As New FileIOPermission(PermissionState.Unrestricted)
      filePermission.Assert()
		
      ...
			
    End Sub

    ' Violates the rule: no security checks are performed
    Public Sub ProcessAllDataFiles()
    
      For i = 0 To DataFiles.Length - 1
      
        ProcessDataFile(DataFiles(i))
			
      Next i
		
    End Sub

  End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace SystemLibrary

  Public Class SystemClass
		
    Private DataFiles() As String
		
    ...
		
    &lt;System.Security.SecurityCritical()&gt; _
    Public Sub ProcessDataFile(fileName As String)
      Dim filePermission As New FileIOPermission(PermissionState.Unrestricted)
      filePermission.Assert()
		
      ...
			
    End Sub

    <SPAN class=code-changed>&lt;System.Security.PermissionSet(SecurityAction.LinkDemand, Unrestricted := True)&gt; _</SPAN>
    Public Sub ProcessAllDataFiles()
    
      For i = 0 To DataFiles.Length - 1
      
        ProcessDataFile(DataFiles(i))
			
      Next i
		
    End Sub

  End Class

End Namespace

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace SystemLibrary
{

  public class SystemClass
  {
		
    private string[] DataFiles;
		
    ...
		
    [System.Security.SecurityCritical()]
    public void ProcessDataFile(string fileName)
    {
      FileIOPermission filePermission = new FileIOPermission(PermissionState.Unrestricted);
      filePermission.Assert();
		
      ...
			
    }

    // Violates the rule: no security checks are performed
    public void ProcessAllDataFiles()
    {
    
      for (int i = 0; i < DataFiles.Length; i++)
      {
      
        ProcessDataFile(DataFiles[i]);
			
      }
		
    }

  }

}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace SystemLibrary
{

  public class SystemClass
  {
		
    private string[] DataFiles;
		
    ...
		
    [System.Security.SecurityCritical()]
    public void ProcessDataFile(string fileName)
    {
      FileIOPermission filePermission = new FileIOPermission(PermissionState.Unrestricted);
      filePermission.Assert();
		
      ...
			
    }

    <SPAN class=code-changed>[System.Security.PermissionSet(SecurityAction.LinkDemand, Unrestricted = true)]</SPAN>
    public void ProcessAllDataFiles()
    {
    
      for (int i = 0; i < DataFiles.Length; i++)
      {
      
        ProcessDataFile(DataFiles[i]);
			
      }
		
    }

  }

}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00010">
      <Name>Type, Method -&gt; Security transparent code should not assert</Name>
      <Title>Security transparent code should not assert</Title>
      <ClassName>SecurityTransparentCodeShouldNotAssert</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Class, Struct, Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>7/22/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2128:SecurityTransparentCodeShouldNotAssert</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00010</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SecurityTransparentCodeShouldNotAssert.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Type or member is marked as SecurityTransparent 
  or mixed transparent/critical is not granted sufficient permissions to assert permissions.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Any call to <b>CodeAccessPermission.Assert</b> from transparent code will cause a 
  <b>System.Security.SecurityException</b> to be thrown at run time. Each transparent or mixed transparent/critical 
  member which calls <b>CodeAccessPermission.Assert</b> should be marked with 
  <b>System.Security.SecurityCriticalAttribute</b> attribute to avoid this issue.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Security transparent code should not assert', CheckId <b>CA2128</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<LI>Add <b>System.Security.SecurityCriticalAttribute</b> to the member</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Security transparent code should not assert.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace SystemLibrary

  Public Class SystemClass
		
    ' Violates the rule: code is security transparent, but calls assert
    Public Sub ProcessDataFiles()
      Dim filePermission As New FileIOPermission(PermissionState.Unrestricted)
      filePermission.Demand()
      filePermission.Assert()
		
      ...
			
    End Sub

  End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace SystemLibrary

  Public Class SystemClass
		
    <SPAN class=code-changed>&lt;System.Security.SecurityCritical()&gt; _</SPAN>
    Public Sub ProcessDataFiles()
      Dim filePermission As New FileIOPermission(PermissionState.Unrestricted)
      filePermission.Demand()
      filePermission.Assert()
		
      ...
			
    End Sub

  End Class

End Namespace

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace SystemLibrary
{

  public class SystemClass
  {
		
    // Violates the rule: code is security transparent, but calls assert
    public void ProcessDataFiles()
    {
      FileIOPermission filePermission = new FileIOPermission(PermissionState.Unrestricted);
      filePermission.Demand();
      filePermission.Assert();
		
      ...
			
    }

  }

}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace SystemLibrary
{

  public class SystemClass
  {
		
    <SPAN class=code-changed>[System.Security.SecurityCritical()]</SPAN>
    public void ProcessDataFiles()
    {
      FileIOPermission filePermission = new FileIOPermission(PermissionState.Unrestricted);
      filePermission.Demand();
      filePermission.Assert();
		
      ...
			
    }

  }

}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00009">
      <Name>Method -&gt; Do not indirectly expose with link demands</Name>
      <Title>Do not indirectly expose methods with link demands</Title>
      <ClassName>DoNotIndirectlyExposeMethodsWithLinkDemands</ClassName>
      <Scope>Public, Protected</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00009</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotIndirectlyExposeMethodsWithLinkDemands.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The member has a link demand and is called by the member that does not perform any security checks.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, you should not access members protected with
  a <b>SecurityAction.LinkDemand</b> security action, from members that are not protected with 
  similar <b>SecurityAction.LinkDemand</b> security action.<br />
  <br />
  Unlike the <b>SecurityAction.Demand</b> security action, which checks the permissions of all the 
  callers in the stack, the <b>SecurityAction.LinkDemand</b> action check only the permissions of 
  the immediate caller and does it only when the method is JIT-compiled (rather then 
  at each method call). The behavior can improve performance but opens up a few 
  security risks. A malicious client might wait until a trusted assembly invokes 
  (and indirectly JIT-compiles) the protected method and then instantiate an object 
  that derives from the secured type but overrides the virtual member.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not indirectly expose methods with link demands', CheckId <b>CA2122</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<LI>Add necessary attribute to the member</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not indirectly expose methods with link demands.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace DocumentsProcessing

  Public Class Document
		
    &lt;FileIOPermission(SecurityAction.LinkDemand, Unrestricted := True)&gt; _
    Public Function GetDocumentText() As String
		
      ...
			
    End Function

    ' Violates the rule: the method does not protected with similar LinkDemand security action
    Public Function IndirectlyExposeDocumentText() As String
		
      Return this.GetDocumentText()
			
    End Function
		
  End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace DocumentsProcessing

  Public Class Document
		
    &lt;FileIOPermission(SecurityAction.LinkDemand, Unrestricted := True)&gt; _
    Public Function GetDocumentText() As String
		
      ...
			
    End Function

    <SPAN class=code-changed>&lt;FileIOPermission(SecurityAction.LinkDemand, Unrestricted := True)&gt; _</SPAN>
    Public Function IndirectlyExposeDocumentText() As String
		
      Return this.GetDocumentText()
			
    End Function
		
  End Class

End Namespace

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace DocumentsProcessing
{

  public class Document
  {
		
    [FileIOPermission(SecurityAction.LinkDemand, Unrestricted = true)]
    public string GetDocumentText()
    {
		
      ...
			
    }

    // Violates the rule: the method does not protected with similar LinkDemand security action
    public string IndirectlyExposeDocumentText()
    {
		
      return this.GetDocumentText();
			
    }
		
  }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace DocumentsProcessing
{

  public class Document
  {
		
    [FileIOPermission(SecurityAction.LinkDemand, Unrestricted = true)]
    public string GetDocumentText()
    {
		
      ...
			
    }

    <SPAN class=code-changed>[FileIOPermission(SecurityAction.LinkDemand, Unrestricted = true)]</SPAN>
    public string IndirectlyExposeDocumentText()
    {
		
      return this.GetDocumentText();
			
    }
		
  }

}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00008">
      <Name>Type, Method -&gt; Review suppress unmanaged code security usage</Name>
      <Title>Review suppress unmanaged code security usage</Title>
      <ClassName>ReviewSuppressUnmanagedCodeSecurityUsage</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Class, Struct, Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2118:ReviewSuppressUnmanagedCodeSecurityUsage</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00008</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ReviewSuppressUnmanagedCodeSecurityUsage.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A public or protected type or member is marked with the <b>System.Security.SuppressUnmanagedCodeSecurity</b> attribute.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, you should avoid using the 
  <b>System.Security.SuppressUnmanagedCodeSecurity</b> attribute at the type level in public or protected types 
  as well as avoid applying the <b>System.Security.SuppressUnmanagedCodeSecurity</b> attribute to 
  public and protected members.<br />
  <br />
  By default, the .NET Framework makes a full Demand for methods that call unmanaged code through PInvoke or 
  COM Interop services. If you mark the method (or its enclosing type) with the 
  <b>System.Security.SuppressUnmanagedCodeSecurity</b> attribute, the .NET Framework makes a LinkDemand for 
  the unmanaged code permission.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Review suppress unmanaged code security usage', CheckId <b>CA2118</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<LI>Remove <b>System.Security.SuppressUnmanagedCodeSecurityAttribute</b> attribute from a type or member</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Review suppress unmanaged code security usage.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace SystemLibrary

  Public Class SystemClass
		
    ' Violates the rule
    &lt;SuppressUnmanagedCodeSecurityAttribute()&gt; _
    Public Sub DoSomethingDangerous()
		
      ...
			
    End Sub

  End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace SystemLibrary

  Public Class SystemClass
		
    ' Attribute has been removed
    Public Sub DoSomethingDangerous()
		
      ...
			
    End Sub

  End Class

End Namespace

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace SystemLibrary
{

  public class SystemClass
  {
		
    // Violates the rule
    [SuppressUnmanagedCodeSecurityAttribute()]
    public void DoSomethingDangerous()
    {
		
      ...
			
    }

  }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace SystemLibrary
{

  public class SystemClass
  {
		
    // Attribute has been removed
    public void DoSomethingDangerous()
    {
		
      ...
			
    }

  }

}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00007">
      <Name>Method -&gt; Should have identical link demands to base method</Name>
      <Title>Override link demands should be identical to base</Title>
      <ClassName>OverrideLinkDemandsShouldBeIdenticalToBase</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2123:OverrideLinkDemandsShouldBeIdenticalToBase</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00007</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/OverrideLinkDemandsShouldBeIdenticalToBase.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Method in a <b>public</b> type implements an interface or overrides a method, and does not marked with the same <b>SecurityAction.LinkDemand</b> security action as the interface method or virtual method.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, if you override a method marked 
  with a <b>SecurityAction.LinkDemand</b> security action, the method in the derived type should 
  be marked with the same <b>SecurityAction.LinkDemand</b> security action.<br />
  <br />
  Unlike the <b>SecurityAction.Demand</b> security action, which checks the permissions of all the 
  callers in the stack, the <b>SecurityAction.LinkDemand</b> action check only the permissions of 
  the immediate caller and does it only when the method is JIT-compiled (rather then 
  at each method call). The behavior can improve performance but opens up a few 
  security risks. A malicious client might wait until a trusted assembly invokes 
  (and indirectly JIT-compiles) the protected method and then instantiate an object 
  that derives from the secured type but overrides the virtual member.
  <br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Override link demands should be identical to base', CheckId <b>CA2123</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
		<LI>Add necessary attribute to the method</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Override link demands should be identical to base.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace DocumentsProcessing

  Public Class Document
		
    &lt;FileIOPermission(SecurityAction.LinkDemand, Unrestricted := True)&gt; _
    Public Overridable Function GetDocumentText() As String
		
      ...
			
    End Function
		
  End Class

  Public Class SecureDocument
    Inherits Document
		
    ' Violation: The method does not marked with LinkDemand security action,
    ' but the base class version does.
    Public Overrides Function GetDocumentText() As String
		
      ...
			
    End Function
		
  End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Security
Imports System.Security.Permissions

Namespace DocumentsProcessing

  Public Class Document
		
    &lt;FileIOPermission(SecurityAction.LinkDemand, Unrestricted := True)&gt; _
    Public Overridable Function GetDocumentText() As String
		
      ...
			
    End Function
		
  End Class

  Public Class SecureDocument
    Inherits Document
		
    <SPAN class=code-changed>&lt;FileIOPermission(SecurityAction.LinkDemand, Unrestricted := True)&gt; _</SPAN>
    Public Overrides Function GetDocumentText() As String
		
      ...
			
    End Function
		
  End Class

End Namespace

	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace DocumentsProcessing
{

  public class Document
  {
		
    [FileIOPermission(SecurityAction.LinkDemand, Unrestricted = true)]
    public virtual string GetDocumentText()
    {
		
      ...
			
    }
		
  }

  public class SecureDocument: Document
  {
		
    // Violation: The method does not marked with LinkDemand security action,
    // but the base class version does.
    public override string GetDocumentText()
    {
		
      ...
			
    }
		
  }

}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

using System;
using System.Security;
using System.Security.Permissions;

namespace DocumentsProcessing
{

  public class Document
  {
		
    [FileIOPermission(SecurityAction.LinkDemand, Unrestricted = true)]
    public virtual string GetDocumentText()
    {
		
      ...
			
    }
		
  }

  public class SecureDocument: Document
  {
		
    <SPAN class=code-changed>[FileIOPermission(SecurityAction.LinkDemand, Unrestricted = true)]</SPAN>
    public override string GetDocumentText()
    {
		
      ...
			
    }
		
  }

}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00005">
      <Name>Method -&gt; GetObjectData is not marked with SecurityPermissionAttribute</Name>
      <Title>Secure GetObjectData overrides</Title>
      <ClassName>SecureGetObjectDataOverrides</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Class, Struct</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>3/28/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2110:SecureGetObjectDataOverrides</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00005</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SecureGetObjectDataOverrides.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Method <b>GetObjectData</b> declared in the type that implements the <b>System.Runtime.Serialization.ISerializable</b> 
	interface is not protected by security permission <b>System.Security.Permissions.SecurityPermissionAttribute.SerializationFormatter</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The <b>GetObjectData</b> method should be protected by demanding 
	<b>System.Security.Permissions.SecurityPermissionAttribute.SerializationFormatter</b> permissions.<br />
	<br />
	If the <b>GetObjectData</b> method is not protected by a security check for <b>SerializationFormatter</b>, 
	it might result in a security risk because a malicious caller might serialize an instance obtained through 
	a factory method exposed by a trusted assembly and then create a copy of it at a later time, or it might 
	manufacture a stream of data containing arbitrary values and use it to create an invalid instance of the type.
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Secure GetObjectData overrides', CheckId <b>CA2110</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Add attribute <b>SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter=true)</b> to <b>GetObjectData</b> method.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Secure GetObjectData overrides.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System.Runtime.Serialization

Public Class PersonalData
    Implements ISerializable
    
    &lt;SecurityPermission(SecurityAction.Demand, ControlPrincipal:=True)&gt; _
    Sub New (ByVal name As String)
      ...
    End Sub
		
	...
		
    ' Might result in a security risk!
    Public Sub GetObjectData(ByVal info As SerializationInfo, _
        ByVal context As StreamingContext) _
        Implements ISerializable.GetObjectData
		  
        ...
		  
    End Sub

End Class	

<SPAN class=code-selected>' This is the correct implementation</SPAN>
	
Imports System.Runtime.Serialization

Public Class PersonalData
    Implements ISerializable
    
    &lt;SecurityPermission(SecurityAction.Demand, ControlPrincipal:=True)&gt; _
    Sub New (ByVal name As String)
        ...
    End Sub
		
	...
		
    <SPAN class=code-changed>&lt;SecurityPermission(SecurityAction.Demand, SerializationFormatter:=True)&gt; _</SPAN>
    Public Sub GetObjectData(ByVal info As SerializationInfo, _
        ByVal context As StreamingContext) _
        Implements ISerializable.GetObjectData
		  
          ...
		  
    End Sub

End Class	


</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System.Runtime.Serialization;

public class PersonalData: ISerializable
{
    
    [SecurityPermission(SecurityAction.Demand, ControlPrincipal = true)]
    PersonalData (string name)
    {
      ...
    }
		
	...
		
    // Might result in a security risk!
    public void ISerializable.GetObjectData(SerializationInfo info,
        StreamingContext context)
    {
		  
        ...
		  
    }

}

<SPAN class=code-selected>// This is the correct implementation</SPAN>


using System.Runtime.Serialization;

public class PersonalData: ISerializable
{
    
    [SecurityPermission(SecurityAction.Demand, ControlPrincipal = true)]
    PersonalData (string name)
    {
      ...
    }
		
	...
		
    <SPAN class=code-changed>[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]</SPAN>
    public void ISerializable.GetObjectData(SerializationInfo info,
        StreamingContext context)
    {
		  
        ...
		  
    }

}


</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00004">
      <Name>Type -&gt; Should not provide overridable implementation of internal interface</Name>
      <Title>Seal methods that satisfy private interfaces</Title>
      <ClassName>SealMethodsThatSatisfyPrivateInterfaces</ClassName>
      <Scope>Public</Scope>
      <Severity>Error</Severity>
      <Targets>Class, Struct</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2119:SealMethodsThatSatisfyPrivateInterfaces</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00004</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/SealMethodsThatSatisfyPrivateInterfaces.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Inheritable public type provides overridable method implementation of a <b>Friend</b> (<b>internal</b> in C#) interface.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[A public type that implements a method of an internal 
	interface using the <b>Overridable</b> (<b>virtual</b> in C#) modifier allows the method 
	to be overridden by a derived type that is outside the assembly. Such scenario can create the following security vulnerability: 
	If a second type in the defining assembly calls the method and expects an internal-only contract, behavior might be 
	compromised when, instead, the overridden method in the outside assembly is executed. 
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Seal methods that satisfy private interfaces', CheckId <b>CA2119</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Change type modifier to <b>NotInheritable</b> (<b>sealed</b> in C#).</LI>
    <LI>Change type modifier to <b>Friend</b> (<b>internal</b> in C#).</LI>
    <LI>Implement the method without <b>Overridable</b> modifier (<b>virtual</b> in C#).</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Seal methods that satisfy private interfaces.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
	
Imports System

Namespace SecurityAccessLibrary

   Interface IValidateUser
      Function IsValidated() As Boolean
   End Interface

   Public Class BaseValidator
      Implements IValidateUser
   
      Overridable Function IsValidated() As Boolean _ 
         Implements IValidateUser.IsValidated
         Return False
      End Function

   End Class

   Public Class SecureDataProvider
   
	  Private UserAccountInfo As SecureData
   
      Public Function GetSecureData(validator As BaseValidator) As SecureData

         If validator.IsValidated() = True Then
            Return UserAccountInfo
         Else
            Return Nothing
         End If

      End Sub
      
      ...
   
   End Class

End Namespace

' How the violator can exploit security vulnerability from the example above:

' external code
Imports System

Namespace SecurityAccessLibrary

   Public Class SecurityViolator
      Inherits BaseValidator
   
      Overrides Function IsValidated() As Boolean 
         Return True
      End Function

      Shared Sub Main()
         Dim dataProvider As New SecureDataProvider()
         Console.WriteLine(dataProvider.GetSecureData(New SecurityViolator()))
      End Sub

   End Class

End Namespace

<SPAN class=code-selected>' This is the correct implementation</SPAN>
	
Imports System

Namespace SecurityAccessLibrary

   Interface IValidateUser
      Function IsValidated() As Boolean
   End Interface

   Public <SPAN class=code-changed>NotInheritable</SPAN> Class BaseValidator
      Implements IValidateUser
   
      Function IsValidated() As Boolean _ 
         Implements IValidateUser.IsValidated
         Return False
      End Function

   End Class

   Public Class SecureDataProvider
   
      Private UserAccountInfo As SecureData
   
      Public Function GetSecureData(validator As BaseValidator) As SecureData

         If validator.IsValidated() = True Then
            Return UserAccountInfo
         Else
            Return Nothing
         End If

      End Sub
      
      ...
   
   End Class

End Namespace


</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
	
using System;

namespace SecurityAccessLibrary
{

   interface IValidateUser
   {
      bool IsValidated();
   }

   public class BaseValidator: IValidateUser
   {
   
      virtual bool IValidateUser.IsValidated()
      {
         return false;
      }

   }

   public class SecureDataProvider
   {
   
	  private SecureData serAccountInfo;
   
      public SecureData GetSecureData(BaseValidator validator)
      {

         if (validator.IsValidated() == true)
         {
            return UserAccountInfo;
         }
         else
         {
            return null;
         }

      }
      
      ...
   
   }

}

// How the violator can exploit security vulnerability from the example above:

// external code
using System;

namespace SecurityAccessLibrary
{

   public class SecurityViolator: BaseValidator
   {
   
      override bool IsValidated() 
      {
         return true;
      }

      static void Main()
      {
         SecureDataProvider dataProvider = new SecureDataProvider();
         Console.WriteLine(dataProvider.GetSecureData(new SecurityViolator()));
      }

   }

}

<SPAN class=code-selected>' This is the correct implementation</SPAN>

using System;

namespace SecurityAccessLibrary
{

   interface IValidateUser
   {
      bool IsValidated();
   }

   public <SPAN class=code-changed>sealed</SPAN> class BaseValidator: IValidateUser
   {
   
      virtual bool IValidateUser.IsValidated()
      {
         return false;
      }

   }

   public class SecureDataProvider
   {
   
	  private SecureData serAccountInfo;
   
      public SecureData GetSecureData(BaseValidator validator)
      {

         if (validator.IsValidated() == true)
         {
            return UserAccountInfo;
         }
         else
         {
            return null;
         }

      }
      
      ...
   
   }

}


</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00003">
      <Name>Field -&gt; Should not have read-only modifier if return type is mutable</Name>
      <Title>Do not declare read only mutable reference types</Title>
      <ClassName>DoNotDeclareReadOnlyMutableReferenceTypes</ClassName>
      <Scope>Public, Protected</Scope>
      <Severity>Error</Severity>
      <Targets>Field</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2104:DoNotDeclareReadOnlyMutableReferenceTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotDeclareReadOnlyMutableReferenceTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value />
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Externally visible read-only field has a return type that is mutable. A mutabe type is a type whose instance data can be modified.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[A mutabe type is a type whose instance data can be modified. Mutable type can change the value 
	of an instance of the class. In the opposite, an immutable type cannot change its value once 
	it is instantiated.<br />
	<br />
	The <b>System.Text.StringBuilder</b> class, which contains members that can change the value 
	of its instance, is an example of a mutable reference type. The <b>System.String</b> class, which 
	can never change its value once it is instantiated, is an example of an immutable reference type.<br />
	<br />
	The <b>ReadOnly</b> modifier (<b>readonly</b> in C#) on a reference type field prevents the field 
	from being replaced by another instance of the reference type. But in the same time the field's instance 
	data can be modified through the reference type.
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Do not declare read only mutable reference types', CheckId <b>CA2104</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Remove <b>ReadOnly</b> modifier from the field (<b>readonly</b> in C#).</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not declare read only mutable reference types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
	
Imports System.Text

Public Class SampleBufferedReader

    ' read-only field has a return type that is mutable
    Shared Protected ReadOnly Buffer As StringBuilder

    Shared Sub New()
        Buffer = New StringBuilder()
    End Sub
    
    ...

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>
	
Imports System.Text

Public Class SampleBufferedReader

    // <b>ReadOnly</b> modifier is removed
    Shared Protected Buffer As StringBuilder

    Shared Sub New()
        Buffer = New StringBuilder()
    End Sub
    
    ...

End Class


</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
	
using System.Text;

public class SampleBufferedReader
{

    // read-only field has a return type that is mutable
    protected static readonly StringBuilder Buffer;

    static SampleBufferedReader()
    {
        Buffer = new StringBuilder();
    }
    
    ...

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>
	
using System.Text;

public class SampleBufferedReader
{

    // <b>readonly</b> modifier is removed
    protected static StringBuilder Buffer;

    static SampleBufferedReader()
    {
        Buffer = new StringBuilder();
    }
    
    ...

}


</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SE00001">
      <Name>Field -&gt; Pointers should not be visible</Name>
      <Title>Pointers should not be visible</Title>
      <ClassName>PointersShouldNotBeVisible</ClassName>
      <Scope>Public, Protected</Scope>
      <Severity>CriticalError</Severity>
      <Targets>Field</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Security</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Security, CA2111:PointersShouldNotBeVisible</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SE00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/PointersShouldNotBeVisible.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Externally visible field that has <b>System.IntPtr</b> or <b>System.UIntPtr</b> 
  return type is not read-only.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[<b>System.IntPtr</b> and <b>System.UIntPtr</b> are platform-specific types that are 
  used to represent a pointer or a handle for accessing unmanaged memory. 
  Malicious code can change the value of the pointer, if a pointer is not read-only, 
  private, or internal. That can potentially cause application or system failures or 
  allow access to arbitrary locations in memory.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Pointers should not be visible', CheckId <b>CA2111</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
		<LI>Make field read-only.
		<LI>Change field modifier to <b>internal</b> (<b>Friend</b> in Visual Basic).
		<LI>Change field modifier to <b>private</b>.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Pointers should not be visible.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System

Namespace SecurityTestLibrary

   Public Class ExposedPointers

        Public exposedPointer1 As IntPtr
        Public exposedPointer2 As UIntPtr
        Protected exposedPointer3 As IntPtr

   End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System

Namespace SecurityTestLibrary

   Public Class ProtectedPointers

        Friend  protectedPointer1 As IntPtr
        Private protectedPointer2 As IntPtr

        Public ReadOnly protectedPointer3 As IntPtr
        Protected ReadOnly protectedPointer4 As UIntPtr

   End Class

End Namespace
	
	</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;

namespace SecurityTestLibrary
{

   public class ExposedPointers
   {

        public IntPtr exposedPointer1;
        public UIntPtr exposedPointer2;
        protected IntPtr exposedPointer3;

   }

}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

using System;

namespace SecurityTestLibrary
{

   public class ProtectedPointers
   {

        internal IntPtr protectedPointer1;
        private IntPtr protectedPointer2;

        public readonly IntPtr protectedPointer3;
        protected readonly UIntPtr protectedPointer4;

   }

}
	
	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="SP00002">
      <Name>Comment -&gt; Should be spelled correctly</Name>
      <Title>Comments should be spelled correctly</Title>
      <ClassName>CommentsShouldBeSpelledCorrectly</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Comment</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Spelling</RuleCategory>
      <RuleModificationDate>10/17/2011</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1704:IdentifiersShouldBeSpelledCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SP00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/CommentsShouldBeSpelledCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>MinWordLength</Name>
          <Value>4</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>Dictionary</Name>
          <Value>en_US</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Comment contains word, which is not recognized by the spelling checker library.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule was created to check spelling of comment strings. Spelling of each word 
  in the comment is checked against the standard dictionary. If the word cannot be found in 
  the standard dictionary the user has possibility to save it in the custom dictionary 
  for further checks.<br />
  <br />
  The English version of the spelling checker is only supported in present.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Change unrecognized word to the word from dictionary.</LI>
    <LI>Add unrecognized word to the custom dictionary.</LI>
    <LI>Change unrecognized word in comment text to the specified text.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Comments should be spelled correctly.</li>
  </ul>
  <p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="SP00003">
      <Name>XML Comment -&gt; Should be spelled correctly</Name>
      <Title>XML Comments should be spelled correctly</Title>
      <ClassName>XmlCommentsShouldBeSpelledCorrectly</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>XmlComment</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Spelling</RuleCategory>
      <RuleModificationDate>10/17/2011</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1704:IdentifiersShouldBeSpelledCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SP00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/XmlCommentsShouldBeSpelledCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>MinWordLength</Name>
          <Value>4</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>Dictionary</Name>
          <Value>en_US</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[XML comment contains word, which is not recognized by the spelling checker library.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule was created to check spelling of XML comment strings. Spelling of each word 
  in the XML comment is checked against the standard dictionary. If the word cannot be found in 
  the standard dictionary the user has possibility to save it in the custom dictionary 
  for further checks.<br />
  <br />
  The English version of the spelling checker is only supported in present.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Change XML comment to the text with corrected words from dictionary.</LI>
    <LI>Add unrecognized word to the custom dictionary.</LI>
    <LI>Change unrecognized word in XML comment text to the specified text.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>XML comments should be spelled correctly.</li>
  </ul>
  <p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="SP00001">
      <Name>Code Element -&gt; Should be spelled correctly</Name>
      <Title>Identifiers should be spelled correctly</Title>
      <ClassName>IdentifiersShouldBeSpelledCorrectly</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Namespace, Class, Interface, Delegate, Struct, Enumeration, Module, Type, Variable, LocalConstant, Method, Operator, Event, Property, Indexer, EnumerationItem, Parameter, Constant, Field, Member</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Spelling</RuleCategory>
      <RuleModificationDate>8/5/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Naming, CA1704:IdentifiersShouldBeSpelledCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=SP00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IdentifiersShouldBeSpelledCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>MinWordLength</Name>
          <Value>4</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>Dictionary</Name>
          <Value>en_US</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Code element name contains word, which is not recognized by the spelling checker library.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The rule was created to check spelling of the identifiers. Each new word in the identifier 
  starts from capital letter. Spelling of each word in the identifiers is checked against the 
  standard dictionary. If the word cannot be found in the standard dictionary the user has 
  possibility to save it in the custom dictionary for further checks.<br />
  <br />
  The English version of the spelling checker is only supported in present.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
	<UL>
    <LI>Rename code element and its references to correct word.</LI>
    <LI>Add unrecognized word to the custom dictionary.</LI>
    <LI>Rename code element and its references to the specified name.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Identifiers should be spelled correctly.</li>
  </ul>
  <p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="US00030">
      <Name>Method -&gt; Always close SQL resources</Name>
      <Title>Always close SQL resources</Title>
      <ClassName>AlwaysCloseSQLResources</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/25/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00030</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AlwaysCloseSQLResources.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AssumeThirdPartyMethodsCouldStoreResourceReferences</Name>
          <Value>False</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Method opens <b>System.Data.SqlClient.SqlConnection</b> but <b>Close</b> or <b>Dispose</b>
  is not called 
  <br /><br />- OR -<br /><br />
  Method performs call to <b>ExecuteReader</b> of <b>System.Data.SqlClient.SqlCommand</b> 
  class but <b>Close</b> or <b>Dispose</b> of returned <b>System.Data.SqlClient.SqlDataReader</b> 
  is not called.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This rule detects situations when a resource leak is created by having a call to a
  method that opens an <b>SqlConnection</b> and not closing it with an appropriate method.
  The following is the list of methods considered for opening and closing the
  resources.<br/><br/>
  Resouce openers:
  <ul>
    <li>System.Data.SqlClient.SqlConnection.Open</li>
    <li>System.Data.SqlClient.SqlCommand.ExecuteReader</li>
  </ul>
  Resource closers:
  <ul>
    <li>System.Data.SqlClient.SqlConnection.Close</li>
    <li>System.Data.SqlClient.SqlConnection.Dispose</li>
    <li>System.ComponentModel.Component.Dispose</li>
    <li>System.Data.SqlClient.SqlDataReader.Close</li>
    <li>System.Data.SqlClient.SqlDataReader.Dispose</li>
    <li>System.IDisposable.Dispose</li>
  </ul>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Add method call that closes SQL resource.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
  <li>Always close SQL resources.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
    <SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Public Sub Foo0()
      <SPAN class=code-selected>' Violates the rule</SPAN>
      Dim connection As New SqlConnection()
      connection.Open()
    End Sub

    Public Sub Foo1()
      <SPAN class=code-selected>' Violates the rule</SPAN>
      Dim command As New SqlCommand()
      Dim reader As SqlDataReader = command.ExecuteReader()
    End Sub
    
    <SPAN class=code-selected>' This is the correct implementation</SPAN>
    Public Class SomeClass
      Private _listConnections As List(Of SqlConnection)
      Private _listReader As List(Of SqlDataReader)

      Public Sub New()
        _listConnections = New List(Of SqlConnection)()
        _listReader = New List(Of SqlDataReader)()
      End Sub

      Public Sub Bar0()
        Using connection As New SqlConnection()
          connection.Open()
        End Using
      End Sub

      Public Sub Bar1()
        Dim connection As New SqlConnection()
        connection.Open()
        ' some code
        connection.Close()
      End Sub

      Public Sub Bar2()
        Dim command As New SqlCommand()
        Dim reader As SqlDataReader = command.ExecuteReader()
        reader.Dispose()
      End Sub

      Public Sub Bar3()
        Dim command As New SqlCommand()
            
        Using reader As SqlDataReader = command.ExecuteReader()
          ' some code
        End Using
      End Sub

      Public Sub Bar4()
      ' Enabled: Assume third-party methods could store resource references
        Dim connection As New SqlConnection()
        connection.Open()
        _lstCon.Add(connection)
        ' can be closed in other code
      End Sub

      Public Sub Bar5()
      ' Enabled: Assume third-party methods could store resource references
        Dim command As New SqlCommand()
        Dim reader As SqlDataReader = command.ExecuteReader()
        _lstReader.Add(reader)
        ' can be closed in other code
      End Sub
    End Class
  </pre>
  <p>[C#]</p>
    <pre class="code">
    <SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    public void Foo0()
    {
      <SPAN class=code-selected>// Violates the rule</SPAN>
      SqlConnection connection = new SqlConnection();
      connection.Open();
    }
    public void Foo1()
    {
      <SPAN class=code-selected>// Violates the rule</SPAN>
      SqlCommand command = new SqlCommand();
      SqlDataReader reader = command.ExecuteReader();
    }
    
    <SPAN class=code-selected>// This is the correct implementation</SPAN>
    public class SomeClass
    {
        private List<SqlConnection> _listConnections;
        private List<SqlDataReader> _listReader;
        
        public SomeClass()
        {
          _listConnections = new List<SqlConnection>();
          _listReader = new List<SqlDataReader>();
        }

        public void Bar0()
        {
          using (SqlConnection connection = new SqlConnection())
          {
            connection.Open();
          }
        }

        public void Bar1()
        {
          SqlConnection connection = new SqlConnection();
          connection.Open();
          // some code
          connection.Close();
        }

        public void Bar2()
        {
          SqlCommand command = new SqlCommand();
          SqlDataReader reader = command.ExecuteReader();
          reader.Dispose();
        }

        public void Bar3()
        {
          SqlCommand command = new SqlCommand();
          using (SqlDataReader reader = command.ExecuteReader())
          {
            // some code
          }
        }

        public void Bar4() // Enabled: Assume third-party methods could store resource references
        {
          SqlConnection connection = new SqlConnection();
          connection.Open();
          _lstCon.Add(connection); // can be closed in other code
        }

        public void Bar5() // Enabled: Assume third-party methods could store resource references
        {
          SqlCommand command = new SqlCommand();
          SqlDataReader reader = command.ExecuteReader();
          _lstReader.Add(reader); // can be closed in other code
        }
      }
</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00029">
      <Name>Method -&gt; Always close standard IO streams</Name>
      <Title>Always close standard IO streams</Title>
      <ClassName>AlwaysCloseStandardIOStreams</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/25/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00029</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AlwaysCloseStandardIOStreams.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AssumeThirdPartyMethodsCouldStoreResourceReferences</Name>
          <Value>False</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Method opens standard <b>IO Stream</b> but not closes or disposes it. 
  <br /><br />- OR -<br /><br />
  Method opens standard <b>Reader</b> but not closes or disposes it. 
  <br /><br />- OR -<br /><br />
  Method opens standard <b>Witer</b> but not closes or disposes it. 
  <br /><br />- OR -<br /><br />
  Method opens standard <b>File</b> but not closes or disposes it. 
  <br /><br />- OR -<br /><br />
  Method opens standard <b>Security.Cryptography.CryptoStream</b> but not closes or disposes it.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This rule detects situations when a resource leak is created by having a call to a
  method that opens an I/O Stream and not closing it with an appropriate method.
  The following is the list of classes that this rule handles while detecting
  resources leaks.
  <ul>
    <li>System.CodeDom.Compiler.IndentedTextWriter</li>
    <li>System.IO.BinaryReader</li>
    <li>System.IO.BinaryWriter</li>
    <li>System.IO.BufferedStream</li>
    <li>System.IO.FileInfo (factory for producing wrappers)
    <li>System.IO.File (factory for producing wrappers)
    <li>System.IO.StreamReader
    <li>System.IO.StreamWriter
    <li>System.Resources.ResourceReader
    <li>System.Resources.ResourceSet
    <li>System.Resources.ResourceWriter
    <li>System.Resources.ResXResourceReader
    <li>System.Resources.ResXResourceWriter
    <li>System.Xml.XmlTextReader
    <li>System.Xml.XmlTextWriter
    <li>System.Xml.XmlValidatingReader
    <li>Security.Cryptography.CryptoStream
  </ul>
  Each of these classes supports methods such as <b>Create</b>, <b>Open</b>, <b>OpenRead</b>, etc.
  which will be considered to open the resource.
  A corresponding call to a clsoing method such as <b>Close</b> or <b>Dispose</b> is expected to
  be present along every execution path before the variable that holds a reference to
  the opened resource goes out of scope.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Add method call that closes IO stream.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Always close standard IO streams.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
    <SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Public Sub Foo0()
      <SPAN class=code-selected>' Violates the rule</SPAN>
      Dim sw As New StreamWriter()
      ' some code
    End Sub

    Public Sub Foo1()
      <SPAN class=code-selected>' Violates the rule</SPAN>
      Dim file As New File()
      file.Open()
      ' some code
    End Sub
    
    <SPAN class=code-selected>' This is the correct implementation</SPAN>

    Public Class SomeClass
      Private _listWriter As List(Of StreamWriter)

      Public Sub New()
        _listWriter = New List(Of StreamWriter)()
      End Sub

      Public Sub Bar0()
        Using sw As New StreamWriter()
          ' some code
        End Using
      End Sub

      Public Sub Bar1()
        Dim file As New File()
        file.Open()
        ' some code
        file.Close()
      End Sub

      Public Sub Bar2()
        Dim file As New File()
        ' file is not opened
      End Sub

      Public Sub Bar3()
      ' Enabled: Assume third-party methods could store resource references
        Dim sw As New StreamWriter()
        _swList.Add(sw)
        ' can be closed in other code
        ' some code
      End Sub
    End Class
  </pre>
  <p>[C#]</p>
    <pre class="code">
    <SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    public void Foo0()
    {
      <SPAN class=code-selected>// Violates the rule</SPAN>
      StreamWriter sw = new StreamWriter();
      // some code
    }
    public void Foo1()
    {
      <SPAN class=code-selected>// Violates the rule</SPAN>
      File file = new File();
      file.Open();
      // some code
    }
    
    <SPAN class=code-selected>// This is the correct implementation</SPAN>
    public class SomeClass
    {
        private List<StreamWriter> _listWriter;

        public SomeClass()
        {
          _listWriter = new List<StreamWriter>();
        }

        public void Bar0()
        {
          using(StreamWriter sw = new StreamWriter())
          {
            // some code
          }
        }

        public void Bar1()
        {
          File file = new File();
          file.Open();
          // some code
          file.Close();
        }

        public void Bar2()
        {
          File file = new File(); // file is not opened
        }

        public void Bar3() // Enabled: Assume third-party methods could store resource references
        {
          StreamWriter sw = new StreamWriter();
          _swList.Add(sw); // can be closed in other code
          // some code
        }
      }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00027">
      <Name>Method -&gt; Always provide names for threads</Name>
      <Title>Always provide names for threads</Title>
      <ClassName>AlwaysProvideNamesForThreads</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/25/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00027</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AlwaysProvideNamesForThreads.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[It is very difficult to work with threads without names during debugging.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This reports a violation whenever the call to the constructor of <b>Thread</b> is not
  immediately followed by an assignment to the <b>Name</b> property of the threads.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options depending from detected violation:
  <ul>
    <li>Set a thread name in the method manually</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Always provide names for threads.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
  Public Sub Foo0()
    <SPAN class=code-selected>' Violation: no name is provided for the thread</SPAN>
    Dim th As New Thread()
    ' some code
  End Sub

  Public Sub Foo1()
    <SPAN class=code-selected>' Violation: Name is provided but not immediately after the Thread constructor</SPAN>
    Dim th As New Thread()
    ' some code
    th.Name = "thread name"
  End Sub

<SPAN class=code-selected>' This is the correct implementation</SPAN>
  Public Sub Bar()
    Dim th As New Thread()
    th.Name = "Worker thread!"
  End Sub
</pre>
  <p>[C#]</p>
  <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
  public void Foo0()
  {
    <SPAN class=code-selected>// Violation: no name is provided for the thread</SPAN>
    Thread th = new Thread();
    // some code
  }

  public void Foo1()
  {
    <SPAN class=code-selected>// Violation: Name is provided but not immediately after the Thread constructor</SPAN>
    Thread th = new Thread();
    // some code
    th.Name = "thread name";
  }
  
<SPAN class=code-selected>// This is the correct implementation</SPAN>
  public void Bar()
  {
    Thread th = new Thread();
    th.Name = "Worker thread!";
  }
</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00025">
      <Name>Method -&gt; Avoid control statements with empty bodies</Name>
      <Title>Avoid control statements with empty bodies</Title>
      <ClassName>AvoidControlStatementsWithEmptyBodies</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/29/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00025</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidControlStatementsWithEmptyBodies.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A conditional statement that is immediately followed by a closing statement (e.g. a semicolon) is usually a typo.
  <br/><br/>- OR -<br/><br/>
  Missing out or improper handling important conditions that can even cause security holes.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This rule identifies <b>if</b>, <b>for</b>, <b>while</b>, <b>do while</b>, <b>else</b> and <b>switch</b> statements with empty
  bodies. An error is reported for each occurrence.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Fill the empty body control statement manually.</li>
  </li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid control statements with empty bodies.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
    <SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Public Class SomeClassWithViolations
      Public Sub Foo_If()
        Dim a As Integer = 0
        If a < 4 Then
        End If
        
        ' some code
      End Sub

      Public Sub Foo_If2()
        Dim a As Integer = 0
        If a > 4 Then
        End If

        ' some code
      End Sub

      Public Sub Foo_Switch()
        Dim a As Integer = 0
        Select Case a
        End Select
        
        ' some code
      End Sub

      Public Sub Foo_Else()
        Dim a As Integer = 0
        If a > 5 Then
          ' some code
        Else
        End If
      End Sub

      Public Sub Foo_For()
        For value As Integer = 0 To 5
        Next
        
        ' some code
      End Sub

      Public Sub Foo_While()
        Dim a As Integer = 0
        While a < 5
        End While

        ' some code
      End Sub

      Public Sub Foo_Do()
        Dim a As Integer = 0
        Do
        Loop While a < 5
        
        ' some code
      End Sub
    End Class

<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Public Class SomeClass
      Public Sub Foo_If()
        Dim a As int = 0
        If a < 4 Then
          ' some code
        End If
      End Sub

      Public Sub Foo_Switch()
        Dim a As Integer = 0
        Select Case a
          Case 3
          ' some code
        End Select
      End Sub

      Public Sub Foo_Else()
        Dim a As Integer = 0
        If a > 5 Then
          ' some code
        Else
          ' some code
        End If
      End Sub

      Public Sub Foo_For()
        For value As Integer = 0 To 5
          ' some code
        Next
      End Sub

      Public Sub Foo_While()
        Dim a As Integer = 0
        While a < 5
          a += 1
        End While
      End Sub

      Public Sub Foo_Do()
        Dim a As Integer = 0
        Do
          a += 1
        Loop While a < 5
      End Sub
    End Class
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    public class SomeClassWithViolations
    {
      public void Foo_If()
      {
        int a= 0;
        if (a < 4)
          ;
        // some code
      }

      public void Foo_If2()
      {
        int a = 0;
        if (a > 4)
        {
        }

        // some code
      }

      public void Foo_Switch()
      {
        int a = 0;
        switch (a)
        {
        }

        // some code
      }

      public void Foo_Else()
      {
        int a = 0;
        if (a > 5)
        {
          // some code
        }
        else
        {
        }
      }

      public void Foo_For()
      {
        for (; ; )
        {
        }

        // some code
      }

      public void Foo_While()
      {
        int a = 0;
        while (a < 5)
        {
        }

        // some code
      }

      public void Foo_Do()
      {
        int a = 0;
        do
        {
        }
        while (a < 5);

        // some code
      }
    }

<SPAN class=code-selected>// This is the correct implementation</SPAN>
    public class SomeClass
    {
      public void Foo_If()
      {
        int a = 0;
        if (a < 4)
        {
          // some code
        }
      }

      public void Foo_Switch()
      {
        int a = 0;
        switch (a)
        {
          case 3:
            {
              // some code
              break;
            }
        }
      }

      public void Foo_Else()
      {
        int a = 0;
        if (a > 5)
        {
          // some code
        }
        else
        {
          // some code
        }
      }

      public void Foo_For()
      {
        for (; ; )
        {
          // some code
        }
      }

      public void Foo_While()
      {
        int a = 0;
        while (a < 5)
        {
          a++;
        }
      }

      public void Foo_Do()
      {
        int a = 0;
        do
        {
          a++;
        }
        while (a < 5);
      }
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00020">
      <Name>Method -&gt; Avoid empty</Name>
      <Title>Avoid empty methods</Title>
      <ClassName>AvoidEmptyMethods</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Sealed, Static, Readonly, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/29/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00020</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidEmptyMethods.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Placeholder empty methods are not filled with a code which can lead to bugs or errors in application behaviour.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This rule identifies code that declares a method with an empty body. An error is
  reported for each occurrence.
  <br/><br/>
  This rule does not apply for <b>abstract</b>, <b>virtual</b>, or <b>override</b> methods to
  reserve the use of polymorphism.
  <br/><br/>
  Prevents missing out implementation of important methods such as logging methods or
  methods that need to take important actions under abnormal cirucmstances, which are
  important for security.
  <br/><br/>
  During development empty methods often get introduced as place-holders for something
  to be implemented at a later time. For example, we could have a method that is
  supposed to log some error condition, but the developer decided to work on the
  normal cases first. These methods should get filled in before the product is
  released. To avoid oversights of this nature, it is best to ensure that there are no
  empty methods unless explicitly allowed (possibly via suppression of the violation).]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Comment out the empty method.</li>
    <li>Remove the empty method.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid empty methods.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Public Class SomeClass
      <SPAN class=code-selected>' Violates the rule</SPAN>
      Public Sub EmptyMethod()
      End Sub
    End Class
    
<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Public Class BaseClass
      <SPAN class=code-selected>' Overridable method is an exception to the rule</SPAN>
      Public Overridable Sub VirtualMethod_NoError()
      End Sub
    End Class

    Public MustInherit Class Tests
      Inherits BaseTest
      Public Sub NotEmptyMethod()
        ' some code
      End Sub
      <SPAN class=code-selected>' MustOverride method is an exception to the rule</SPAN>
      Public MustOverride Sub EmptyMethod_NoError()
    End Class
    
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    public class SomeClass
    {
      <SPAN class=code-selected>// Violates the rule</SPAN>
      public void EmptyMethod()
      {
      }
    }

<SPAN class=code-selected>// This is the correct implementation</SPAN>
    public class BaseClass
    {
      <SPAN class=code-selected>// Virtual method is an exception to the rule</SPAN>
      public virtual void VirtualMethod_NoError()
      {
      }
    }

    public abstract class Tests: BaseTest
    {
      public void NotEmptyMethod()
      {
        // some code
      }

      <SPAN class=code-selected>// Abstract method is an exception to the rule</SPAN>
      public abstract void EmptyMethod_NoError();
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00028">
      <Name>Method -&gt; Avoid use of 'new' keyword for hiding methods</Name>
      <Title>Avoid use of 'new' keyword for hiding methods</Title>
      <ClassName>AvoidUseNewKeywordForHidingMethods</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Method</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/25/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00028</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidUseNewKeywordForHidingMethods.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[C# lets you redefine a method in the base class using the keyword <b>new</b> which can confuse the users of the class]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This rule triggers on each use of the <b>new</b> key word when it is used to hide a method in the base class.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Remove the <b>new</b> keyword from the method manually.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid use of new keyword for hiding methods</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Public Class Parent
      Public Function foo() As Integer
        Return 100
      End Function
    End Class

    Public Class Child
      Inherits Parent
      <SPAN class=code-selected>' Violates the rule</SPAN>
      Public Shadows Function foo() As Integer
        Return 200
      End Function
    End Class

<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Public Class Parent
      Public Overridable Function foo() As Integer
        Return 100
      End Function
    End Class

    Public Class Child
      Inherits Parent
      Public Overrides Function foo() As Integer
        Return 200
      End Function
    End Class
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    public class Parent
    {
      public int foo()
      {
        return 100;
      }
    }

    public class Child : Parent
    {
      <SPAN class=code-selected>// Violates the rule</SPAN>
      public new int foo()
      {
        return 200;
      }
    }

<SPAN class=code-selected>// This is the correct implementation</SPAN>
    public class Parent
    {
      public virtual int foo()
      {
        return 100;
      }
    }

    public class Child : Parent
    {
      public override int foo()
      {
        return 200;
      }
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00021">
      <Name>Method -&gt; Avoid System.Console 'Write()' or 'WriteLine()' statements</Name>
      <Title>Avoid System.Console 'Write()' or 'WriteLine()' statements</Title>
      <ClassName>AvoidSystemConsoleWriteMethods</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/29/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00021</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/AvoidSystemConsoleWriteMethods.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>ExcludeList</Name>
          <Value>Main,Show,Verbose</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Disallows the use of <b>System.Console.WriteLine()</b> or <b>System.Console.Write()</b> for
  debugging purposes.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[All debugging statements should be cleaned up before the product is released.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Comment out the method call.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Avoid System.Console 'Write()' or 'WriteLine()' statements</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Public Sub Foo0()
      <SPAN class=code-selected>' Violates the rule</SPAN>
      Console.WriteLine("Some debug information")
    End Sub

<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Public Sub Main()
    <SPAN class=code-selected>' Main is an exception to the rule</SPAN>
      Console.WriteLine("Some debug information")
    End Sub

    Public Sub Foo0()
      <SPAN class=code-selected>' Comment out the violation block</SPAN>
      ' Console.WriteLine("Some debug information");
    End Sub
  </pre>
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    public void Foo0()
    {
      <SPAN class=code-selected>// Violates the rule</SPAN>
      Console.WriteLine("Some debug information");
    }

<SPAN class=code-selected>// This is the correct implementation</SPAN>
    public void Main()
    {
      <SPAN class=code-selected>// Main is an exception to the rule</SPAN>
      Console.WriteLine("Some debug information");
    }

    public void Foo0()
    {
      <SPAN class=code-selected>// Comment out the violation block</SPAN>
      // Console.WriteLine("Some debug information");
    }
  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00001">
      <Name>Custom Serialization -&gt; Type -&gt; Call base class methods on ISerializable types</Name>
      <Title>Call base class methods on ISerializable types</Title>
      <ClassName>CallBaseClassMethodsOnISerializableTypes</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Error</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/13/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2236:CallBaseClassMethodsOnISerializableTypes</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/CallBaseClassMethodsOnISerializableTypes.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Type derives from a type that implements the <b>System.Runtime.Serialization.ISerializable</b>
  interface, implements <b>System.Runtime.Serialization.ISerializable.GetObjectData</b>
  method but does not call the
  <span class="code-fragment">GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</span>
  method of the base type.<br />
  <br />
  Or<br />
  <br />
  Type derives from a type that implements the <b>System.Runtime.Serialization.ISerializable</b>
  interface, implements the serialization constructor with the <b>(System.Runtime.Serialization.SerializationInfo</b>,
  <b>System.Runtime.Serialization.StreamingContext)</b> parameter signature, but 
  does not call the serialization constructor of the base type.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Implementing <b>System.Runtime.Serialization.ISerializable</b> involves implementing the 
  <span class="code-fragment">GetObjectData</span> method and a special constructor that is used when
  the object is deserialized. Derived classes should call the
  <span class="code-fragment">GetObjectData</span> method and serialization constructor of
  the base object if the latter implements <b>System.Runtime.Serialization.ISerializable.</b>
  In opposite case, the type will not be serialized and de-serialized correctly.
  But if the derived type does not introduces any new fields, then the type does not need to implement
  the <span class="code-fragment">GetObjectData</span> method and special serialization constructor.
  It does not need to call the base type equivalents as well.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Call base class methods on ISerializable types', CheckId <b>CA2236</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Find method <b>System.Runtime.Serialization.ISerializable.GetObjectData</b> and 
    insert a <span class="code-fragment">GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</span> 
    call at the beginning or at the end of the method.</li>
    <li>Find constructor with the <b>(System.Runtime.Serialization.SerializationInfo, 
	  System.Runtime.Serialization.StreamingContext)</b> parameter signature and 
	  insert a call of the base type serialization constructor at the beginning of the constructor.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>
      Call base class methods on ISerializable types.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

Imports System.Runtime.Serialization

' The following base type implements ISerializable interface
&lt;Serializable()&gt; _
Public Class Person
    Implements ISerializable

    Private _firstName As String
    Private _lastName As String

    Public ReadOnly Property FirstName() As String
        Get
            Return _firstName
        End Get
    End Property

    Public ReadOnly Property LastName() As String
        Get
            Return _lastName
        End Get
    End Property

    Public Sub New(ByVal firstName As String, ByVal lastName As String)
        Me._firstName = firstName
        Me._lastName = lastName
    End Sub

    ' Special serialization constructor
    Protected Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)
        _firstName = CType(info.GetValue("_firstName", GetType(String)), String)
        _lastName = CType(info.GetValue("_lastName", GetType(String)), String)
    End Sub

    Public Overridable Sub GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext) _
        Implements ISerializable.GetObjectData

        info.AddValue("_firstName", _firstName)
        info.AddValue("_lastName", _lastName)

    End Sub

End Class

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

&lt;Serializable&gt; _
Public Class Employee
    Inherits Person

    Private _salary As Decimal

    Public ReadOnly Property Salary() As Decimal
        Get
            Return _salary
        End Get
    End Property

    Public Sub New(ByVal firstName As String, ByVal lastName As String, ByVal salary As Decimal)

        MyBase.New(firstName, lastName)
        Me._salary = salary

    End Sub

    Protected Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)
        _salary = CType(info.GetValue("_salary", GetType(Decimal)), Decimal)
    End Sub

    Public Overrides Sub GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext)
        info.AddValue("_salary", _salary)
    End Sub

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

&lt;Serializable&gt; _
Public Class Employee
    Inherits Person

    Private _salary As Decimal

    Public ReadOnly Property Salary() As Decimal
        Get
            Return _salary
        End Get
    End Property

    Public Sub New(ByVal firstName As String, ByVal lastName As String, ByVal salary As Decimal)

        MyBase.New(firstName, lastName)
        Me._salary = salary

    End Sub

    Protected Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)
        <SPAN class=code-changed>MyBase.New(info, context)</SPAN>
        _salary = CType(info.GetValue("_salary", GetType(Decimal)), Decimal)
    End Sub

    Public Overrides Sub GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext)
        <SPAN class=code-changed>MyBase.GetObjectData(info, context)</SPAN>
        info.AddValue("_salary", _salary)
    End Sub

End Class


	</pre>
  <p>[C#]</p>
  <pre class="code">

using System.Runtime.Serialization;

// The following base type implements ISerializable interface
[Serializable()]
public class Person: ISerializable
{

    private string _firstName;
    private string _lastName;

    public string FirstName
    {
        get
        {
            return _firstName;
        }
    }

    public string LastName
    {
        get
        {
            return _lastName;
        }
    }

    public Person(string firstName, string lastName)
    {
        this._firstName = firstName;
        this._lastName = lastName;
    }

    // Special serialization constructor
    protected Person(SerializationInfo info, StreamingContext context)
    {
        _firstName = (string)info.GetValue("_firstName", string.GetType());
        _lastName = (string)info.GetValue("_lastName", string.GetType());
    }

    public virtual void ISerializable.GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext)
    {

        info.AddValue("_firstName", _firstName);
        info.AddValue("_lastName", _lastName);

    }

}

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

[Serializable]
public class Employee: Person
{

    private decimal _salary;

    public decimal Salary
    {
        get
        {
            return _salary;
        }
    }

    public Employee(string firstName, string lastName, decimal salary):
      base(firstName, lastName)
    {

        this._salary = salary;

    }

    protected Employee(SerializationInfo info, StreamingContext context)
    {
        _salary = (decimal)(info.GetValue("_salary", decimal.GetType());
    }

    public override void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        info.AddValue("_salary", _salary);
    }

}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

[Serializable]
public class Employee: Person
{

    private decimal _salary;

    public decimal Salary
    {
        get
        {
            return _salary;
        }
    }

    public Employee(string firstName, string lastName, decimal salary):
      base(firstName, lastName)
    {

        this._salary = salary;

    }

    protected Employee(SerializationInfo info, StreamingContext context):
      <SPAN class=code-changed>base(info, context)</SPAN>
    {
        _salary = (decimal)(info.GetValue("_salary", decimal.GetType());
    }

    public override void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        <SPAN class=code-changed>base.GetObjectData(info, context);</SPAN>
        info.AddValue("_salary", _salary);
    }

}


	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00024">
      <Name>Method -&gt; Close database connections in 'finally' block</Name>
      <Title>Close database connections in 'finally' block</Title>
      <ClassName>CloseDatabaseConnectionInFinallyBlock</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/25/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00024</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/CloseDatabaseConnectionInFinallyBlock.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>FullTypeNameRegExp</Name>
          <Value>^(System\.Data\.)(.*)(Connection)$</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MethodNameRegExp</Name>
          <Value>Close</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Close and release database connection under all circumstances.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This rule triggers whenever a call to the closing
  method from given connection type is not present in 
  a <b>finally</b> block. If the resource is used via 
  a <b>using</b> statement the rule will not trigger.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Add <b>finally</b> block and add the method call that closes database connection.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
  <li>Close data base connections in 'finally' block.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
    <SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Imports System.Data.SqlClient
    Namespace myApplication
      Class MyClientApplication
        Public Sub myMethod(connection As SqlConnection)
          Try
              ' do something
            connection.Open()
              ' handle error
          Catch exc As Exception
          End Try
          <SPAN class=code-selected>' Violates the rule</SPAN>
          connection.Close()
        End Sub
      End Class
    End Namespace
    
    <SPAN class=code-selected>' This is the correct implementation</SPAN>
    Imports System.Data.SqlClient
    Namespace myApplication
      Class MyClientApplication
        Public Sub myMethod(connection As SqlConnection)
          Try
              ' do something
            connection.Open()
              ' handle error
          Catch exc As Exception
          Finally
            connection.Close()  <span class=code-selected>' Fix</span>
          End Try
        End Sub
      End Class
    End Namespace
  </pre>
  <p>[C#]</p>
  <pre class="code">
    <SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    using System.Data.SqlClient;
    namespace myApplication
    {
      class MyClientApplication
      {
        public void myMethod(SqlConnection connection)
        {
          try
          {
            connection.Open();
            // do something
          }
          catch(Exception exc)
          {
            // handle error
          }
          
          <SPAN class=code-selected>// Violates the rule</SPAN>
          connection.Close();
        }
      }
    }
    
    <SPAN class=code-selected>// This is the correct implementation</SPAN>
    using System.Data.SqlClient;
    namespace myApplication
    {
      class MyClientApplication
      {
        public void myMethod(SqlConnection connection)
        {
          try
          {
            connection.Open();
            // do something
          }
          catch(Exception exc)
          {
            // handle error
          }
          finally
          {
            connection.Close(); <span class=code-selected>// Fix</span>
          }
        }
      }
    }
</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00022">
      <Name>Method -&gt; Do not explicitly call 'System.GC.Collect()' or 'System.GC.Collect(int)'</Name>
      <Title>Do not explicitly call 'System.GC.Collect()' or 'System.GC.Collect(int)'</Title>
      <ClassName>DoNotCallGCCollectMethod</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/29/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00022</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotCallGCCollectMethod.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Garbage collection could be very costly and should be avoided by all means - except
  in benchmarking code.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This rule identifies explicit calls of the <b>System.GC.Collect</b> method. An error is
  reported for each occurrence.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Comment out <span class="code-fragment">System.GC.Collect</span> method call.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
  <li>Do not explicitly call 'System.GC.Collect()' or 'System.GC.Collect(int)'.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Namespace Examples.Rules.GC
      Public Class GC
        Private Sub Method()
            '..
          Try
          Finally
            '..
            <SPAN class=code-selected>' Violates the rule</SPAN>
            System.GC.Collect()
          End Try
        End Sub
      End Class
    End Namespace
    
<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Namespace Examples.Rules.GC
      Public Class GCFixed
        Private Sub Method()
            '..
          Try
            '..
            ' System.GC.Collect() <SPAN class=code-selected>' Fixed by commenting out</SPAN>
          Finally
          End Try
        End Sub
      End Class
    End Namespace
  </pre>
  <p>[C#]</p>
  <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    namespace Examples.Rules.GC
    {
      public class GC
      {
        void Method()
        {
          try
          {
            //..
          }
          finally
          {
            //..
            <SPAN class=code-selected>// Violates the rule</SPAN>
            System.GC.Collect();
          }
        }
      }
    }
    
<SPAN class=code-selected>// This is the correct implementation</SPAN>
    namespace Examples.Rules.GC
    {
      public class GCFixed
      {
        void Method()
        {
          try
          {
            //..
          }
          finally
          {
            //..
            // System.GC.Collect() <SPAN class=code-selected>// Fixed by commenting out</SPAN>
          }
        }
      }
    }
</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00017">
      <Name>Calls without local implementation -&gt; Should not be prefixed with the 'base.' ('MyBase.' in Visual Basic)</Name>
      <Title>Do not prefix calls with 'base' ('MyBase' in Visual Basic) unless local implementation exists</Title>
      <ClassName>DoNotPrefixCallsWithBaseUnlessNeeded</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Expression</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>12/8/2009</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00017</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DoNotPrefixCallsWithBaseUnlessNeeded.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The call to the method is unnecessarily prefixed with <b>base</b> (<b>MyBase</b> in Visual Basic) keyword.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The <b>base</b> (<b>MyBase</b> in Visual Basic) keyword is used to access members of the base class from within a derived class. 
  The call to the method should only use the <b>base</b> 
  keyword if the item is declared <b>virtual</b> (<b>Overridable</b> in Visual Basic) in the base class and an override is defined 
  in the local class, i.e. if a method on the base class has been overridden by another method.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Replace <b>base</b> (<b>MyBase</b> in Visual Basic) keyword with <b>this</b> (<b>Me</b> in Visual Basic) keyword on the method call.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Do not prefix calls with 'base' ('MyBase' in Visual Basic) unless local implementation exists.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class Person

  Public FirstName As String
  Public LastName As String
  
  Public Sub PrintInfo()
  
  ...
  
  End Sub
  
End Class

Public Class Employee
  Inherits Person

  Public Position As String
  Public Salary As Decimal
  
  Public Sub PrintReport()
  
    ' Violation
    MyBase.PrintInfo()

    ...
  
  End Sub

End Class	


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class Person

  Public FirstName As String
  Public LastName As String
  
  Public Sub PrintInfo()
  
  ...
  
  End Sub
  
End Class

Public Class Employee
  Inherits Person

  Public Position As String
  Public Salary As Decimal
  
  Public Sub PrintReport()
  
    <SPAN class=code-changed>Me</SPAN>.PrintInfo()

    ...
  
  End Sub

End Class	


- Or -

Public Class Person

  Public FirstName As String
  Public LastName As String
  
  Public Overridable Sub PrintInfo()
  
    ...
  
  End Sub
  
End Class

Public Class Employee
  Inherits Person

  Public Position As String
  Public Salary As Decimal
  
  Public Overrides Sub PrintInfo()
  
    ...
  
  End Sub
  
  Public Sub PrintReport()
  
    MyBase.PrintInfo()

    ...
  
  End Sub

End Class	

</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class Person
{

  public string FirstName;
  public string LastName;
  
  public void PrintInfo()
  {
  
    ...
  
  }
  
}

public class Employee: Person
{

  public string Position;
  public decimal Salary;
  
  public void PrintReport()
  {
  
    ' Violation
    base.PrintInfo();

    ...
  
  }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class Person
{

  public string FirstName;
  public string LastName;
  
  public void PrintInfo()
  {
  
    ...
  
  }
  
}

public class Employee: Person
{

  public string Position;
  public decimal Salary;
  
  public void PrintReport()
  {
  
    <SPAN class=code-changed>this</SPAN>.PrintInfo();

    ...
  
  }

}

- Or -

public class Person
{

  public string FirstName;
  public string LastName;
  
  public virtual void PrintInfo()
  {
  
    ...
  
  }
  
}

public class Employee: Person
{

  public string Position;
  public decimal Salary;

  public override void PrintInfo()
  {
  
    ...
  
  }
  
  public void PrintReport()
  {
  
    base.PrintInfo();

    ...
  
  }

}

</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00023">
      <Name>Property -&gt; Lock both when either set or get is locked</Name>
      <Title>Lock both when either set or get is locked for a property</Title>
      <ClassName>LockBothGetSetForProperty</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>Property</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>4/3/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00023</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/LockBothGetSetForProperty.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Property has both <b>get</b> and <b>set</b> methods and only one of the methods uses a <b>lock</b> and the other does not
  <br/><br/>- OR -<br/><br/>
  Property has both <b>get</b> and <b>set</b> methods and both of them use <b>lock</b>, but <b>lock</b> on different objects]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[If one of the methods in a property requires a <b>lock</b>, then it is very likely that the
  other one also needs it. Not locking can lead to issues that are very hard to detect
  and debug since the issues are usually not easy to reproduce.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Lock both <b>get</b> and <b>set</b> accessors on the same object for the property.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Lock both when either set or get is locked for a property</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">
<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
    Public Class SomeClass
      Private a As Object
      Private DeadBolt As New Object()
      <span class=code-selected>' Violates the rule.</span>
      Public Property SomeObject() As Object
        Get
          SyncLock DeadBolt
            Return a
          End SyncLock
        End Get
        Set
          a = value
        End Set
      End Property
    End Class
    
<SPAN class=code-selected>' This is the correct implementation</SPAN>
    Public Class SomeClass
      Private a As Object
      Private DeadBolt As New Object()
      Public Property SomeObject() As Object
        Get
          SyncLock DeadBolt
            Return a
          End SyncLock
        End Get
        Set
          SyncLock DeadBolt
            a = value
          End SyncLock
        End Set
      End Property
    End Class
  </pre>
  <p>[C#]</p>
  <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
    public class SomeClass
    {
      private object a;
      private object DeadBolt = new object();
      <span class=code-selected>// Violates the rule.</span>
      public object SomeObject
      {
        get
        {
          lock (DeadBolt)
          {
            return a;
          }
        }
        set
        {
          a = value;
        }
      }
    }
    
<SPAN class=code-selected>// This is the correct implementation</SPAN>
    public class SomeClass
    {
      private object a;
      private object DeadBolt = new object();
      public object SomeObject
      {
        get
        {
          lock (DeadBolt)
          {
            return a;
          }
        }
        set
        {
          lock (DeadBolt)
          {
            a = value;
          }
        }
      }
    }
</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00016">
      <Name>Local calls -&gt; Should be prefixed with 'this.' ('Me.' in Visual Basic)</Name>
      <Title>Calls to local members should be prefixed with 'this.' ('Me.' in Visual Basic)</Title>
      <ClassName>PrefixMemberCallsWithSelf</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Expression</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>12/8/2009</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00016</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/PrefixMemberCallsWithSelf.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The call to the method does not begin with the <b>this.</b> (<b>Me.</b> in Visual Basic) prefix.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The call to the method must begin with the <b>this.</b> (<b>Me.</b> in Visual Basic) prefix to indicate that the item is a member of class. 
	This rule makes the code clearer as it indicates the scope of the method.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Add <b>this.</b> (<b>Me.</b> in Visual Basic) prefix to the method call.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Calls to local members should be prefixed with the 'this.' ('Me.' in Visual Basic).</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
	
Public Class SampleClass
  
  Private Sub DoSomething(ByVal param As Integer)
  
    ...
    
  End Sub 

  Public Sub DoSomethingElse()

    ' Method call is not prefixed
    DoSomething(1)
    ...
    
  End Sub 

End Class	

<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class SampleClass
  
  Private Sub DoSomething(ByVal param As Integer)
  
    ...
    
  End Sub 

  Public Sub DoSomethingElse()

    <SPAN class=code-changed>Me</SPAN>.DoSomething(1)
    ...
    
  End Sub 

End Class	

</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
	
public class SampleClass
{
  
  private void DoSomething(int param)
  {
  
    ...
    
  }

  public void DoSomethingElse()
  {

    // Violation: Method call is not prefixed
    DoSomething(1);
    ...
    
  }

}

<SPAN class=code-selected>// This is the correct implementation</SPAN>

public class SampleClass
{
  
  private void DoSomething(int param)
  {
  
    ...
    
  }

  public void DoSomethingElse()
  {

    <SPAN class=code-changed>this</SPAN>.DoSomething(1);
    ...
    
  }

}

</pre>
	<p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00002">
      <Name>Dispose -&gt; Field -&gt; Disposable fields should be disposed</Name>
      <Title>Disposable fields should be disposed</Title>
      <ClassName>DisposableFieldsShouldBeDisposed</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Field</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/13/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2213:DisposableFieldsShouldBeDisposed</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DisposableFieldsShouldBeDisposed.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A type implements <b>System.IDisposable</b> interface and declares field, which 
  is of type that implements <b>System.IDisposable</b> as well, but the <b>Dispose</b>
  method of the declaring type does not call the <b>Dispose</b> method of this 
  field.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[The <b>Dispose</b> method of the type, which implements <b>System.IDisposable</b>
  interface, should release all the resources that it owns. The <b>Dispose</b> method 
  of the type should call the <b>Dispose</b> method for each field that hold a 
  reference to a disposable object.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Disposable fields should be disposed', CheckId <b>CA2213</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>
      Find method <b>Dispose</b>(<span class="code-fragment">disposing</span>) and 
      insert a
      <span class="code-fragment">Dispose()</span>
      call at the end of the dispose snippet in the code path where
      <span class="code-fragment">disposing</span>
      is True.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>
      Disposable fields should be disposed.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br>
  <p>[Visual Basic]</p>
  <pre class="code">

' The following code shows type
' that implements <b>System.IDisposable</b> interface
Public Class DisposableType
  Implements IDisposable

  Protected disposed As Boolean = False

  ' This method disposes the base object's resources.
  Protected Overridable Sub Dispose(ByVal disposing As Boolean)
    If Not Me.disposed Then
      If disposing Then
      
        ...
      
      End If

      Me.disposed = True
      
    End If
  End Sub

  Public Sub Dispose() Implements IDisposable.Dispose
    Dispose(True)
    GC.SuppressFinalize(Me)
  End Sub
  
  Protected Overrides Sub Finalize()
    Try
      Dispose(False)
    Catch
    
      ...
    
    Finally
      MyBase.Finalize()
    End Try
    
  End Sub
  
End Class

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class AnotherDisposableType
  Implements IDisposable

  Private _disposableField As New DisposableType()
  
  Protected disposed As Boolean = False

  ' Violation: Disposable field _disposableField is not disposed
  Protected Overridable Sub Dispose(ByVal disposing As Boolean)
    If Not Me.disposed Then
      If disposing Then
      
        ...
      
      End If

      Me.disposed = True
      
    End If
  End Sub

  Public Sub Dispose() Implements IDisposable.Dispose
    Dispose(True)
    GC.SuppressFinalize(Me)
  End Sub
  
  Protected Overrides Sub Finalize()
    Try
      Dispose(False)
    Catch
    
      ...
    
    Finally
      MyBase.Finalize()
    End Try
    
  End Sub
  
End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class AnotherDisposableType
  Implements IDisposable

  Private _disposableField As New DisposableType()
  
  Protected disposed As Boolean = False

  ' This method disposes the base object's resources.
  Protected Overridable Sub Dispose(ByVal disposing As Boolean)
    If Not Me.disposed Then
      If disposing Then
      
        ...
       
        <SPAN class=code-changed>_disposableField.Dispose(disposing)</SPAN>
      
      End If

      Me.disposed = True
      
    End If
  End Sub

  Public Sub Dispose() Implements IDisposable.Dispose
    Dispose(True)
    GC.SuppressFinalize(Me)
  End Sub
  
  Protected Overrides Sub Finalize()
    Try
      Dispose(False)
    Catch
    
      ...
    
    Finally
      MyBase.Finalize()
    End Try
    
  End Sub
  
End Class


</pre>
  <p>[C#]</p>
  <pre class="code">

// The following code shows type
// that implements <b>System.IDisposable</b> interface
public class DisposableType: IDisposable
{

  protected bool disposed = false;

  // This method disposes the base object's resources.
  protected virtual void Dispose(bool disposing)
  {
    if (!this.disposed)
    {
      if (disposing)
      {
      
        ...
        
      }
      
      this.disposed = true;
    }
  }

  public void Dispose()
  {
    Dispose(true);
    GC.SuppressFinalize(this);
  }
  
  ~DisposableType()
  {
    Dispose(false);
  }
  
}

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class AnotherDisposableType: IDisposable
{

  private DisposableType _disposableField = new DisposableType();
  
  protected bool disposed = false;

  // Violation: Disposable field _disposableField is not disposed
  protected virtual void Dispose(bool disposing)
  {
    if (!this.disposed)
    {
      if (disposing)
      {
      
        ...
        
      }
      
      this.disposed = true;
    }
  }

  public void Dispose()
  {
    Dispose(true);
    GC.SuppressFinalize(this);
  }
  
  ~DisposableType()
  {
    Dispose(false);
  }
  
}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

public class AnotherDisposableType: IDisposable
{

  private DisposableType _disposableField = new DisposableType();
  
  protected bool disposed = false;

  protected virtual void Dispose(bool disposing)
  {
    if (!this.disposed)
    {
      if (disposing)
      {
      
        ...
        
        <SPAN class=code-changed>_disposableField.Dispose(disposing);</SPAN>
      }
      
      this.disposed = true;
    }
  }

  public void Dispose()
  {
    Dispose(true);
    GC.SuppressFinalize(this);
  }
  
  ~DisposableType()
  {
    Dispose(false);
  }
  
}


</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00003">
      <Name>Dispose -&gt; Type -&gt; Should declare finalizer</Name>
      <Title>Disposable types should declare finalizer</Title>
      <ClassName>DisposableTypesShouldDeclareFinalizer</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/13/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2216:DisposableTypesShouldDeclareFinalizer</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DisposableTypesShouldDeclareFinalizer.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The type contains field of a type that suggest the use of unmanaged resource, but
	does not implement a finalizer as described by <b>System.Object.Finalize</b>.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, if a type has <b>System.IntPtr</b>,
  <b>System.UIntPtr</b>, or <b>System.Runtime.InteropServices.HandleRef</b> fields, 
  than it most likely stores pointers to unmanaged resources and therefore.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Disposable types should declare finalizer', CheckId <b>CA2216</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Implement finalizer (desctructor) that calls method <span class="code-fragment">Dispose(Boolean)</span>.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Disposable types should declare finalizer.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Public Class SampleType
    Implements IDisposable

    Private _someUnmanagedResource As UIntPtr
    Protected disposed As Boolean = False
    
    Sub New()
      ' Allocate the unmanaged resource ...
      _someUnmanagedResource = ...
    End Sub

    Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
        If disposing Then
        
          ...
          
        End If
        
        ' Release unmanaged resources
        ...
        
        _someUnmanagedResource = IntPtr.Zero
    
        Me.disposed = True

      End If
    End Sub

    Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
    End Sub
    
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Public Class SampleType
    Implements IDisposable

    Private _someUnmanagedResource As UIntPtr
    Protected disposed As Boolean = False
    
    Sub New()
      ' Allocate the unmanaged resource ...
      _someUnmanagedResource = ...
    End Sub

    Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
        If disposing Then
        
          ...
          
        End If
        
        ' Release unmanaged resources
        ...
        
        _someUnmanagedResource = IntPtr.Zero
    
        Me.disposed = True

      End If
    End Sub

    Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
    End Sub
    
    <SPAN class=code-changed>Protected Overrides Sub Finalize()
      Try
        Dispose(False)
      Catch
        ' Deal with errors or just ignore them
      Finally
        ' Invoke the base object's Finalize method
        MyBase.Finalize()
      End Try
    End Sub</SPAN>
    
  End Class


</pre>
	<p>[C#]</p> 
<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

  public class SampleType: IDisposable
  {

    private UIntPtr _someUnmanagedResource;
    protected bool disposed = false;
    
    SampleType()
    {
      // Allocate the unmanaged resource ...
      _someUnmanagedResource = ...
    }

    protected virtual void Dispose(bool disposing)
    {
      if (!this.disposed)
      {
        if (disposing)
        {
      
          ...
        
        }
      
        // Release unmanaged resources
        ...
        
        _someUnmanagedResource = IntPtr.Zero;
        
        this.disposed = true;
      }
    }

    public void Dispose()
    {
      Dispose(true);
      GC.SuppressFinalize(this);
    }
    
  }


<SPAN class=code-selected>// This is the correct implementation</SPAN>

  public class SampleType: IDisposable
  {

    private UIntPtr _someUnmanagedResource;
    protected bool disposed = false;
    
    SampleType()
    {
      // Allocate the unmanaged resource ...
      _someUnmanagedResource = ...
    }

    protected virtual void Dispose(bool disposing)
    {
      if (!this.disposed)
      {
        if (disposing)
        {
      
          ...
        
        }
      
        // Release unmanaged resources
        ...
        
        _someUnmanagedResource = IntPtr.Zero;
        
        this.disposed = true;
      }
    }

    public void Dispose()
    {
      Dispose(true);
      GC.SuppressFinalize(this);
    }
    
    <SPAN class=code-changed>~DisposableType()
    {
      Dispose(false);
    }</SPAN>
    
  }


</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00004">
      <Name>Dispose -&gt; Method -&gt; Should call base class dispose</Name>
      <Title>Dispose methods should call base class dispose</Title>
      <ClassName>DisposeMethodsShouldCallBaseClassDispose</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class, Struct</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/13/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2215:DisposeMethodsShouldCallBaseClassDispose</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00004</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/DisposeMethodsShouldCallBaseClassDispose.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The type derives from a type that implements the <b>System.IDisposable</b> 
	interface, implements <b>Dispose</b> method, but does not call the <B>Dispose</B> method of the base type.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, if the type derives from a type that implements
	the <b>System.IDisposable</b> interface, it must call the <B>Dispose</B> method of the base type
	from within its own implemented <B>Dispose</B> method.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Dispose methods should call base class dispose', CheckId <b>CA2215</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Find method <b>Dispose</b> and insert <span class="code-fragment">Dispose()</span> 
    call at the end of the method.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Dispose methods should call base class dispose.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
<pre class="code">

' The following code shows type
' that implements <b>System.IDisposable</b> interface
Public Class BaseDisposableType
  Implements IDisposable

  Protected disposed As Boolean = False

  ' This method disposes the base object's resources.
  Protected Overridable Sub Dispose(ByVal disposing As Boolean)
    If Not Me.disposed Then
      If disposing Then
      
        ...
      
      End If

      Me.disposed = True
      
    End If
  End Sub

  Public Sub Dispose() Implements IDisposable.Dispose
    Dispose(True)
    GC.SuppressFinalize(Me)
  End Sub
  
  Protected Overrides Sub Finalize()
    Try
      Dispose(False)
    Catch
    
      ...
    
    Finally
      MyBase.Finalize()
    End Try
    
  End Sub
  
End Class

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Public Class DerivedDisposableType
  Inherits BaseDisposableType

  ' This method disposes the derived object's resources.
  Protected Overrides Sub Dispose(ByVal disposing As Boolean)
    If Not Me.disposed Then
      If disposing Then
        ' Release disposable objects used by this instance here.
        
        ...
        
      End If
      ' Release unmanaged resources here.
      
      ...

    End If
    
  End Sub

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Public Class DerivedDisposableType
  Inherits BaseDisposableType

  ' This method disposes the derived object's resources.
  Protected Overrides Sub Dispose(ByVal disposing As Boolean)
    If Not Me.disposed Then
      If disposing Then
        ' Release disposable objects used by this instance here.
        
        ...
        
      End If
      ' Release unmanaged resources here.
      
      ...
      
      ' Call the base object's Dispose protected method.
      <SPAN class=code-changed>MyBase.Dispose(disposing)</SPAN>

    End If
    
  End Sub

End Class


</pre>
	<p>[C#]</p> 
<pre class="code">

// The following code shows type
// that implements <b>System.IDisposable</b> interface
public class BaseDisposableType: IDisposable
{

  protected bool disposed = false;

  // This method disposes the base object's resources.
  protected virtual void Dispose(bool disposing)
  {
    if (!this.disposed)
    {
      if (disposing)
      {
      
        ...
        
      }
      
      this.disposed = true;
    }
  }

  public void Dispose()
  {
    Dispose(true);
    GC.SuppressFinalize(this);
  }
  
  ~DisposableType()
  {
    Dispose(false);
  }
  
}

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

public class DerivedDisposableType: BaseDisposableType
{

  // This method disposes the derived object's resources.
  protected override void Dispose(bool disposing)
  {
    if (!this.disposed)
    {
      if (disposing)
      {
        // Release disposable objects used by this instance here.
      
        ...
      
      }
      // Release unmanaged resources here.
    
      ...

    }
    
  }

}


<SPAN class=code-selected>' This is the correct implementation</SPAN>

public class DerivedDisposableType: BaseDisposableType
{

  // This method disposes the derived object's resources.
  protected override void Dispose(bool disposing)
  {
    if (!this.disposed)
    {
      if (disposing)
      {
        // Release disposable objects used by this instance here.
      
        ...
      
      }
      // Release unmanaged resources here.
    
      ...

      // Call the base object's Dispose protected method.
      <SPAN class=code-changed>base.Dispose(disposing);</SPAN>

    }
    
  }

}


</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00005">
      <Name>Finalize -&gt; Method -&gt; Should be protected</Name>
      <Title>Finalizers should be protected</Title>
      <ClassName>FinalizersShouldBeProtected</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2221:FinalizersShouldBeProtected</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00005</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/FinalizersShouldBeProtected.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The type implements a finalizer that does not have <b>protected</b> modifier.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, types that implement finalizer must use
  <b>protected</b> modifier. This rule is enforced by the C# and Visual Basic compilers.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Finalizers should be protected', CheckId <b>CA2221</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Find finalizer and change its modifier to <b>protected</b>.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Finalizers should be protected.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Public Class SampleType
    Implements IDisposable

    Protected disposed As Boolean = False
    
    ...
    
    Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
        If disposing Then
        
          ...
          
        End If
        
        ' Release unmanaged resources
        ...
        
        Me.disposed = True

      End If
    End Sub

    Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
    End Sub
    
    Overrides Sub Finalize()
      Try
        Dispose(False)
      Catch
        ' Deal with errors or just ignore them
      Finally
        ' Invoke the base object's Finalize method
        MyBase.Finalize()
      End Try
    End Sub
    
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Public Class SampleType
    Implements IDisposable

    Protected disposed As Boolean = False
    
    ...
    
    Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
        If disposing Then
        
          ...
          
        End If
        
        ' Release unmanaged resources
        ...
        
        Me.disposed = True

      End If
    End Sub

    Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
    End Sub
    
    <SPAN class=code-changed>Protected</SPAN> Overrides Sub Finalize()
      Try
        Dispose(False)
      Catch
        ' Deal with errors or just ignore them
      Finally
        ' Invoke the base object's Finalize method
        MyBase.Finalize()
      End Try
    End Sub
    
  End Class


	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00006">
      <Name>Finalize -&gt; Method -&gt; Should call base class finalizer</Name>
      <Title>Finalizers should call base class finalizer</Title>
      <ClassName>FinalizersShouldCallBaseClassFinalizer</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/13/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2220:FinalizersShouldCallBaseClassFinalizer</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00006</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/FinalizersShouldCallBaseClassFinalizer.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The type overrides <b>System.Object.Finalize</b> method,
  but does not call the <B>Finalize</B> method of the base type.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, finalization must be propagated
  through the inheritance hierarchy. Therefore, the type must call <B>Finalize</B> method
  of its base class from within its own implemnted <B>Finalize</B> method.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Finalizers should call base class finalizer', CheckId <b>CA2220</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Find finalizer and insert <span class="code-fragment">MyBase.Finalize()</span> 
    call at the end of the method.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Finalizers should call base class finalizer.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

  Public Class SampleType
    Implements IDisposable

    Protected disposed As Boolean = False
    
    ...
    
    Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
        If disposing Then
        
          ...
          
        End If
        
        ' Release unmanaged resources
        ...
        
        Me.disposed = True

      End If
    End Sub

    Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
    End Sub
    
    Protected Overrides Sub Finalize()
      Try
        Dispose(False)
      Catch
        ' Deal with errors or just ignore them
      Finally
      
        ...

      End Try
    End Sub
    
  End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

  Public Class SampleType
    Implements IDisposable

    Protected disposed As Boolean = False
    
    ...
    
    Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
        If disposing Then
        
          ...
          
        End If
        
        ' Release unmanaged resources
        ...
        
        Me.disposed = True

      End If
    End Sub

    Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
    End Sub
    
    Protected Overrides Sub Finalize()
      Try
        Dispose(False)
      Catch
        ' Deal with errors or just ignore them
      Finally
      
        ...
      
        ' Invoke the base object's Finalize method
        <SPAN class=code-changed>MyBase.Finalize()</SPAN>
      End Try
    End Sub
    
  End Class


	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00007">
      <Name>Serialization -&gt; Type -&gt; Implement "GetObjectData" method correctly</Name>
      <Title>Implement ISerializable correctly</Title>
      <ClassName>ImplementISerializableCorrectly</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Error</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2240:ImplementISerializableCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00007</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ImplementISerializableCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The type implements the <b>System.Runtime.Serialization.ISerializable</b> interface and contains 
	<B>GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</B> 
	method which is not externally visible. 
	<br /><br />- OR -<br /><br />
	Non sealed type implements the <b>System.Runtime.Serialization.ISerializable</b> interface and contains 
	<B>GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</B> 
	method which is not overridable. 
	<br /><br />- OR -<br /><br />
	The type implements the <b>System.Runtime.Serialization.ISerializable</b> interface,
	but does not override the <B>GetObjectData(System.Runtime.Serialization.SerializationInfo,
	System.Runtime.Serialization.StreamingContext)</B> method and the type declares instance fields
	that are not marked with the <b>System.NonSerializedAttribute</b> attribute.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[If a type is derived from one that implements the 
	<b>System.Runtime.Serialization.ISerializable</b> interface and it has instance fields that need to be serialized,
	the derived class must implement both the serialization constructor as well as the <b>GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</b> method.
	Fields that are not to be serialized should be marked with the <b>NonSerializedAttribute</b> attribute, which explicitly excludes the target field from the serialization process.
	<br /><br />
	Implementations of the <b>GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</b> 
	method should be externally visible, if the type is not sealed. That enable derived types to call and override the method.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Implement ISerializable correctly', CheckId <b>CA2240</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options depending from detected violation:
  <UL>
    <LI>Find method 
    <B>GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</B> 
    and change its modifier. 
    <LI>Add method 
    <B>GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</B> 
    and add instance fields to the serialization process.
    <LI>Add empty method <B>GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</B>.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Implement ISerializable correctly.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

' Parent type Person implements ISerializable interface,
' but derived Employee type does not override GetObjectData method and
' introduces new _salary property, which is not marked with NonSerializedAttribute attribute

Imports System.Runtime.Serialization

' The following parent type implements ISerializable interface
&lt;Serializable()&gt; _
Public Class Person
    Implements ISerializable

    Private _firstName As String
    Private _lastName As String

    Public ReadOnly Property FirstName() As String
        Get
            Return _firstName
        End Get
    End Property

    Public ReadOnly Property LastName() As String
        Get
            Return _lastName
        End Get
    End Property

    Public Sub New(ByVal firstName As String, ByVal lastName As String)
        Me._firstName = firstName
        Me._lastName = lastName
    End Sub

    ' Special serialization constructor
    Protected Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)
        _firstName = CType(info.GetValue("_firstName", GetType(String)), String)
        _lastName = CType(info.GetValue("_lastName", GetType(String)), String)
    End Sub

    Public Overridable Sub GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext) _
        Implements ISerializable.GetObjectData

        info.AddValue("_firstName", _firstName)
        info.AddValue("_lastName", _lastName)

    End Sub

End Class

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
	
' Violation: the GetObjectData method does not overrided to serialize new _salary property.
&lt;Serializable&gt; _
Public Class Employee
    Inherits Person

	Private _salary As Decimal

    Public ReadOnly Property Salary() As Decimal
        Get
            Return _salary
        End Get
    End Property

    Public Sub New(ByVal firstName As String, ByVal lastName As String, ByVal salary As Decimal)
    
        MyBase.New(firstName, lastName)

        Me._salary = salary
        
    End Sub

    Protected Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)

        MyBase.New(info, context)

        _salary = CType(info.GetValue("_salary", GetType(Decimal)), Decimal)

    End Sub

End Class

<SPAN class=code-selected>' This is the correct implementation</SPAN>

&lt;Serializable&gt; _
Public Class Employee
    Inherits Person

    Private _salary As Decimal

    Public ReadOnly Property Salary() As Decimal
        Get
            Return _salary
        End Get
    End Property

    Public Sub New(ByVal firstName As String, ByVal lastName As String, ByVal salary As Decimal)

        MyBase.New(firstName, lastName)
        Me._salary = salary

    End Sub

    Protected Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)
        MyBase.New(info, context)
        _salary = CType(info.GetValue("_salary", GetType(Decimal)), Decimal)
    End Sub

<SPAN class=code-changed>
    Public Overrides Sub GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext)
        MyBase.GetObjectData(info, context)
        info.AddValue("_salary", _salary)
    End Sub
</SPAN>

End Class


</pre>
	<p>[C#]</p>
	<pre class="code">

// Parent type Person implements ISerializable interface,
// but derived Employee type does not override GetObjectData method and
// introduces new _salary property, which is not marked with NonSerializedAttribute attribute

using System.Runtime.Serialization;

// The following base type implements ISerializable interface
[Serializable()]
public class Person: ISerializable
{

    private string _firstName;
    private string _lastName;

    public string FirstName
    {
        get
        {
            return _firstName;
        }
    }

    public string LastName
    {
        get
        {
            return _lastName;
        }
    }

    public Person(string firstName, string lastName)
    {
        this._firstName = firstName;
        this._lastName = lastName;
    }

    // Special serialization constructor
    protected Person(SerializationInfo info, StreamingContext context)
    {
        _firstName = (string)info.GetValue("_firstName", string.GetType());
        _lastName = (string)info.GetValue("_lastName", string.GetType());
    }

    public virtual void ISerializable.GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext)
    {

        info.AddValue("_firstName", _firstName);
        info.AddValue("_lastName", _lastName);

    }

}

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
	
// Violation: the GetObjectData method does not overrided to serialize new _salary property.
[Serializable]
public class Employee: Person
{

    private decimal _salary;

    public decimal Salary
    {
        get
        {
            return _salary;
        }
    }

    public Employee(string firstName, string lastName, decimal salary):
      base(firstName, lastName)
    {

        this._salary = salary;

    }

    protected Employee(SerializationInfo info, StreamingContext context):
      base(info, context)
    {
        _salary = (decimal)(info.GetValue("_salary", decimal.GetType());
    }

}

<SPAN class=code-selected>// This is the correct implementation</SPAN>

[Serializable]
public class Employee: Person
{

    private decimal _salary;

    public decimal Salary
    {
        get
        {
            return _salary;
        }
    }

    public Employee(string firstName, string lastName, decimal salary):
      base(firstName, lastName)
    {

        this._salary = salary;

    }

    protected Employee(SerializationInfo info, StreamingContext context):
      base(info, context)
    {
        _salary = (decimal)(info.GetValue("_salary", decimal.GetType());
    }

    <SPAN class=code-changed>public override void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        base.GetObjectData(info, context);
        info.AddValue("_salary", _salary);
    }</SPAN>

}


</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00008">
      <Name>Custom Serialization -&gt; Class -&gt; Implement ISerializable if class expose events</Name>
      <Title>Implement ISerializable for serializable classes that expose events</Title>
      <ClassName>ImplementISerializableForClassesThatExposeEvents</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>6/25/2008</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00008</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ImplementISerializableForClassesThatExposeEvents.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Type which exposes events has <b>System.SerializableAttribute</b> attribute.<br />
<br /]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[For each event, both the Visual Basic .NET and the C# compiler define a hidden delegate field; 
delegate types aren't serializable and any attempt to serialize an instance that contains non-null
delegates will fail. By implementing custom serialization, you can skip these delegate fields in the
serialization process.<br />
<br /]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Implement interface <b>System.Runtime.Serialization.ISerializable</b> for the type</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Implement <b>System.Runtime.Serialization.ISerializable</b> for serializable
    classes that expose events.</li>
  </ul]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
<p>[Visual Basic]</p> 
<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

' Violation: type should implement ISerializable

&lt;Serializable&gt; _
Public Class Person

    Private _firstName As String
    Private _lastName As String

    ' <b>Changed</b> event type is not serializable
    Public Event Changed As EventHandler

    Public Property FirstName() As String
        Get
            Return _firstName
        End Get
        Set(ByVal newValue As String)
            _firstName = newValue
            RaiseEvent Changed(Me, EventArgs.Empty)
        End Set
    End Property

    Public Property LastName() As String
        Get
            Return _lastName
        End Get
        Set(ByVal newValue As String)
            _lastName = newValue
            RaiseEvent Changed(Me, EventArgs.Empty)
        End Set
    End Property

    Public Sub New(ByVal firstName As String, ByVal lastName As String)

        Me._firstName = firstName
        Me._lastName = lastName

    End Sub

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

<SPAN class=code-changed>Imports System.Runtime.Serialization</SPAN>
	
&lt;Serializable&gt; _
Public Class Person
    <SPAN class=code-changed>Implements ISerializable</SPAN>

    Private _firstName As String
    Private _lastName As String
    
    Public Event Changed As EventHandler

    Public Property FirstName() As String
        Get
            Return _firstName
        End Get
        Set(ByVal newValue As String)
            _firstName = newValue
            RaiseEvent Changed(Me, EventArgs.Empty)
        End Set
    End Property

    Public Property LastName() As String
        Get
            Return _lastName
        End Get
        Set(ByVal newValue As String)
            _lastName = newValue
            RaiseEvent Changed(Me, EventArgs.Empty)
        End Set
    End Property

    Public Sub New(ByVal firstName As String, ByVal lastName As String)

        Me._firstName = firstName
        Me._lastName = lastName

    End Sub

    <span class=code-changed>Protected Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)

        _firstName = CType(info.GetValue("_firstName", GetType(String)), String)
        _lastName = CType(info.GetValue("_lastName", GetType(String)), String)

    End Sub

    Public Overridable Sub GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext) _
      Implements ISerializable.GetObjectData

        info.AddValue("_firstName", _firstName)
        info.AddValue("_lastName", _lastName)

    End Sub</span>
    
End Class

	</pre>
<p>[C#]</p> 
<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

// Violation: type should implement ISerializable

[Serializable()]
public class Person
{

    private string _firstName;
    private string _lastName;
    
    // <b>Changed</b> event type is not serializable
    public event EventHandler Changed;


    public string FirstName
    {
        get
        {
            return _firstName;
        }
        set
        {
            _firstName = value;
            Changed(this, EventArgs.Empty);
        }
    }

    public string LastName
    {
        get
        {
            return _lastName;
        }
        set
        {
            _lastName = value;
            Changed(this, EventArgs.Empty);
        }
    }

    public Person(string firstName, string lastName)
    {
        this._firstName = firstName;
        this._lastName = lastName;
    }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

<SPAN class=code-changed>using System.Runtime.Serialization;</SPAN>

[Serializable()]
public class Person<SPAN class=code-changed>: ISerializable</SPAN>
{

    private string _firstName;
    private string _lastName;
    
    public event EventHandler Changed;


    public string FirstName
    {
        get
        {
            return _firstName;
        }
        set
        {
            _firstName = value;
            Changed(this, EventArgs.Empty);
        }
    }

    public string LastName
    {
        get
        {
            return _lastName;
        }
        set
        {
            _lastName = value;
            Changed(this, EventArgs.Empty);
        }
    }

    public Person(string firstName, string lastName)
    {
        this._firstName = firstName;
        this._lastName = lastName;
    }

    <SPAN class=code-changed>protected Person(SerializationInfo info, StreamingContext context)
    {
        _firstName = (string)info.GetValue("_firstName", string.GetType());
        _lastName = (string)info.GetValue("_lastName", string.GetType());
    }

    public virtual void ISerializable.GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext)
    {

        info.AddValue("_firstName", _firstName);
        info.AddValue("_lastName", _lastName);

    }</SPAN>

}

	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00009">
      <Name>Custom Serialization -&gt; Type -&gt; Implement serialization constructor</Name>
      <Title>Implement serialization constructor</Title>
      <ClassName>ImplementSerializationConstructor</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Error</Severity>
      <Targets>Class</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>10/22/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2229:ImplementSerializationConstructors</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00009</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ImplementSerializationConstructor.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The type implements the <b>System.Runtime.Serialization.ISerializable</b> interface, 
	but does not have a constructor with the <b> System.Runtime.Serialization.SerializationInfo</b>, 
	<b>System.Runtime.Serialization.StreamingContext</b> parameter signature. 
	<br /><br />- OR -<br /><br />
	The unsealed type implements the <b>System.Runtime.Serialization.ISerializable</b> interface 
	and have a serialization constructor (with the <b> System.Runtime.Serialization.SerializationInfo</b>, 
	<b>System.Runtime.Serialization.StreamingContext</b> parameter signature) with non <b>protected</b>
	access modifier.
	<br /><br />- OR -<br /><br />
	The sealed type <span class="code-fragment">{0}</span> implements 
	the <b>System.Runtime.Serialization.ISerializable</b> interface and have a serialization 
	constructor (with the <b> System.Runtime.Serialization.SerializationInfo</b>, 
	<b>System.Runtime.Serialization.StreamingContext</b> parameter signature) with
	non <b>private</b> modifier.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Implement serialization constructors', CheckId <b>CA2229</b></i>]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[You can add the <b>System.Runtime.Serialization.ISerializable</b> interface to a type to customize the serialization process.
	Both <b>GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</b> and the special serialization constructor must be implemented in that case.
	The serialization constructor is required when the object is deserialized. A <b>System.Runtime.Serialization.SerializationException</b> will be thrown when an attempt is made to deserialize a type without the constructor.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options depending from detected violation:
  <UL>
    <LI>Add constructor with <b> System.Runtime.Serialization.SerializationInfo</b>, 
	<b>System.Runtime.Serialization.StreamingContext</b> parameter signature and add 
	instance fields to the serialization process.	
    <LI>Add empty constructor with <b> System.Runtime.Serialization.SerializationInfo</b>, 
    <b>System.Runtime.Serialization.StreamingContext</b> parameter signature.
    <LI>Find constructor with <b> System.Runtime.Serialization.SerializationInfo</b>, 
    <b>System.Runtime.Serialization.StreamingContext</b> parameter signature and 
    change its modifier.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Implement serialization constructor.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">
<SPAN class=code-selected>

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

' Violation: The type Person implements <b>System.Runtime.Serialization.ISerializable</b> interface,
' but it does not have special serialization constructor.
</SPAN>

Imports System.Runtime.Serialization

&lt;Serializable()&gt; _
Public Class Person
    Implements ISerializable

    Private _firstName As String
    Private _lastName As String

    Public ReadOnly Property FirstName() As String
        Get
            Return _firstName
        End Get
    End Property

    Public ReadOnly Property LastName() As String
        Get
            Return _lastName
        End Get
    End Property

    Public Sub New(ByVal firstName As String, ByVal lastName As String)
        Me._firstName = firstName
        Me._lastName = lastName
    End Sub

    Public Overridable Sub GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext) _
        Implements ISerializable.GetObjectData

        info.AddValue("_firstName", _firstName)
        info.AddValue("_lastName", _lastName)
    End Sub

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

' The special serialization constructor is implemented
' and marked with protected access modifier.

Imports System.Runtime.Serialization

&lt;Serializable()&gt; _
Public Class Person
    Implements ISerializable

    Private _firstName As String
    Private _lastName As String
    
    Public ReadOnly Property FirstName() As String
        Get
            Return _firstName
        End Get
    End Property

    Public ReadOnly Property LastName() As String
        Get
            Return _lastName
        End Get
    End Property

    Public Sub New(ByVal firstName As String, ByVal lastName As String)
        Me._firstName = firstName
        Me._lastName = lastName
    End Sub

<SPAN class=code-changed>
    ' Special serialization constructor
    Protected Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)
        _firstName = CType(info.GetValue("_firstName", GetType(String)), String)
        _lastName = CType(info.GetValue("_lastName", GetType(String)), String)
    End Sub
</SPAN>

    Public Overridable Sub GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext) _
        Implements ISerializable.GetObjectData

        info.AddValue("_firstName", _firstName)
        info.AddValue("_lastName", _lastName)
    End Sub

End Class


</pre>
	<p>[C#]</p> 
	<pre class="code">
<SPAN class=code-selected>

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

// Violation: The type Person implements <b>System.Runtime.Serialization.ISerializable</b> interface,
// but it does not have special serialization constructor.
</SPAN>

using System.Runtime.Serialization;

[Serializable()]
public class Person: ISerializable
{

    private string _firstName;
    private string _lastName;

    public string FirstName
    {
        get
        {
            return _firstName;
        }
    }

    public string LastName
    {
        get
        {
            return _lastName;
        }
    }

    public Person(string firstName, string lastName)
    {
        this._firstName = firstName;
        this._lastName = lastName;
    }

    public virtual void ISerializable.GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext)
    {

        info.AddValue("_firstName", _firstName);
        info.AddValue("_lastName", _lastName);

    }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

// The special serialization constructor is implemented
// and marked with protected access modifier.

using System.Runtime.Serialization;

[Serializable()]
public class Person: ISerializable
{

    private string _firstName;
    private string _lastName;

    public string FirstName
    {
        get
        {
            return _firstName;
        }
    }

    public string LastName
    {
        get
        {
            return _lastName;
        }
    }

    public Person(string firstName, string lastName)
    {
        this._firstName = firstName;
        this._lastName = lastName;
    }

    <SPAN class=code-changed>// Special serialization constructor
    protected Person(SerializationInfo info, StreamingContext context)
    {
        _firstName = (string)info.GetValue("_firstName", string.GetType());
        _lastName = (string)info.GetValue("_lastName", string.GetType());
    }</SPAN>

    public virtual void ISerializable.GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext)
    {

        info.AddValue("_firstName", _firstName);
        info.AddValue("_lastName", _lastName);

    }

}


</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00010">
      <Name>Serialization -&gt; Method -&gt; Implement serialization methods correctly</Name>
      <Title>Implement serialization methods correctly</Title>
      <ClassName>ImplementSerializationMethodsCorrectly</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>10/29/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2238:ImplementSerializationMethodsCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00010</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ImplementSerializationMethodsCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The type has <b>System.SerializableAttribute</b> attribute 
	and has a method (with <b>System.Runtime.Serialization.StreamingContext</b> parameter signature)
	that handles a serialization event with incorrect visibility modifier.
	<br /><br />- OR -<br /><br />
	The type has <b>System.SerializableAttribute</b> attribute 
	and has a method that handles a serialization event
	with incorrect parameter list.
	<br /><br />- OR -<br /><br />
	The type has <b>System.SerializableAttribute</b> attribute 
	and has a method that handles a serialization event
	with incorrect parameter return type.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[According to Microsoft .NET Framework guidelines, method that handles a serialization event
	should take a single parameter of type <b>System.Runtime.Serialization.StreamingContext</b>,
	return <b>void</b>, and have <b>private</b> visibility modifier.
	<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Implement serialization methods correctly', CheckId <b>CA2238</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options depending from detected violation:
  <UL>
    <LI>Find method with <b>System.Runtime.Serialization.StreamingContext</b> parameter signature 
    and change its visibility modifier to <b>private</b>.
    <LI>Find method and change its parameter signature to
     <b>System.Runtime.Serialization.StreamingContext</b>.
    <LI>Find method and change return type to <b>void</b>.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Implement serialization methods correctly.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example shows shows correctly declared serialization event handlers.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System.Runtime.Serialization

&lt;SerializableAttribute&gt; _ 
Public Class SampleTypeWithEventHandlers

  &lt;OnSerializingAttribute&gt; _ 
  <SPAN class=code-changed>Private Sub</SPAN> OnSerializing(context As <SPAN class=code-changed>StreamingContext</SPAN>) 
  
    ...
  
  End Sub

  &lt;OnSerializedAttribute&gt; _ 
  <SPAN class=code-changed>Private Sub</SPAN> OnSerialized(context As <SPAN class=code-changed>StreamingContext</SPAN>) 
  
    ...
  
  End Sub

  &lt;OnDeserializingAttribute&gt; _ 
  <SPAN class=code-changed>Private Sub</SPAN> OnDeserializing(context As <SPAN class=code-changed>StreamingContext</SPAN>)
  
    ...
  
  End Sub

  &lt;OnDeserializedAttribute&gt; _ 
  <SPAN class=code-changed>Private Sub</SPAN> OnDeserialized(context As <SPAN class=code-changed>StreamingContext</SPAN>)
  
    ...
  
  End Sub

End Class


</pre>
	<p>[C#]</p> 
	<pre class="code">

<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System.Runtime.Serialization;

[SerializableAttribute]
public class SampleTypeWithEventHandlers
{

  [OnSerializingAttribute]
  <SPAN class=code-changed>private void</SPAN> OnSerializing(<SPAN class=code-changed>StreamingContext</SPAN> context) 
  {
  
    ...
  
  }

  [OnSerializedAttribute]
  <SPAN class=code-changed>private void</SPAN> OnSerialized(<SPAN class=code-changed>StreamingContext</SPAN> context) 
  {
  
    ...
  
  }

  [OnDeserializingAttribute]
  <SPAN class=code-changed>private void</SPAN> OnDeserializing(<SPAN class=code-changed>StreamingContext</SPAN> context)
  {
  
    ...
  
  }

  [OnDeserializedAttribute]
  <SPAN class=code-changed>private void</SPAN> OnDeserialized(<SPAN class=code-changed>StreamingContext</SPAN> context)
  {
  
    ...
  
  }

}


</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00011">
      <Name>Custom Serialization -&gt; Field -&gt; Include instance fields in the serialization/deserialization process</Name>
      <Title>Include instance fields in the serialization/deserialization process.</Title>
      <ClassName>IncludeInstanceFieldsInCustomSerializationCorrectly</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Error</Severity>
      <Targets>Field</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/13/2008</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2240:ImplementISerializableCorrectly</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00011</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/IncludeInstanceFieldsInCustomSerializationCorrectly.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The type implements the <b>System.Runtime.Serialization.ISerializable</b> interface, contains
	instance field that is not marked with the <b>System.NonSerializedAttribute</b> attribute. 
	<br /><br />- OR -<br /><br />
	The field is not included in the serialization process in 
	<B>GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</B> 
  method.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[If a type implements the <b>System.Runtime.Serialization.ISerializable</b> interface,
	than all of its instance fields should be included in the serialization/deserialization process
	of expicitly marked with <b>System.NonSerializedAttribute</b> attribute.<br />
	<br />
	To include the instance field in the serialization/deserialization process, the type must implement
	the <b>GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</b> 
	method and special serialization constructor.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Implement ISerializable correctly', CheckId <b>CA2240</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options depending from detected violation:
  <UL>
    <LI>Find method <B>GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)</B> 
    and insert <span class="code-fragment">AddValue()</span> call at the end of the method.
    <LI>Add <b>System.NonSerializedAttribute</b> to the instance field.
    <LI>Find serialization constructor and insert 
    <span class="code-fragment">GetValue()</span> 
    call at the end of the constructor.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Include instance fields in the serialization/deserialization process.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

' Sample serializable type	
&lt;Serializable()&gt;  _
Public Class MySerializableType
  Implements ISerializable
  
  Private _serializableField As Integer
  
  Public ReadOnly Property SerializableField() As Integer
    Get
      Return _serializableField
    End Get
  End Property


  Public Sub New(ByVal serializableField As Integer)
    _serializableField = serializableField
  End Sub 

  Protected Sub New(ByVal info As SerializationInfo, _
  ByVal context As StreamingContext) 
      _serializableField = info.GetInt32("serializableField")
  End Sub 'New
  
  Public Overridable Sub GetObjectData(ByVal info As _
    SerializationInfo, ByVal context As StreamingContext) 
    info.AddValue("serializableField", _serializableField)
  End Sub 
End Class	

' Sample non-serializable type	
Public Class MyNonSerializableType
  
  Private _nonSerializableField As Integer
  
  Public ReadOnly Property NonSerializableField() As Integer
    Get
      Return _nonSerializableField
    End Get
  End Property


  Public Sub New(ByVal nonSerializableField As Integer)
    _nonSerializableField = nonSerializableField
  End Sub 

End Class	

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>
	
&lt;Serializable()&gt; _
Public Class MyType

    Private _mySerializable As MySerializableType
    Private _myNonSerializable As MyNonSerializableType

    Public ReadOnly Property MySerializable() As MySerializableType
        Get
            Return _mySerializable
        End Get
    End Property

    Public ReadOnly Property MyNonSerializable() As MyNonSerializableType
        Get
            Return _myNonSerializable
        End Get
    End Property

    Public Sub New(ByVal mySerializable As MySerializableType, ByVal myNonSerializable As MyNonSerializableType)
        Me._mySerializable = mySerializable
        Me._myNonSerializable = myNonSerializable
    End Sub

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

&lt;Serializable()&gt; _
Public Class MyType
    <SPAN class=code-changed>Implements ISerializable</SPAN>

    Private _mySerializable As MySerializableType
    
    <SPAN class=code-changed>&lt;NonSerialized()&gt; _</SPAN>
    Private _myNonSerializable As MyNonSerializableType

    Public ReadOnly Property MySerializable() As MySerializableType
        Get
            Return _mySerializable
        End Get
    End Property

    Public ReadOnly Property MyNonSerializable() As MyNonSerializableType
        Get
            Return _myNonSerializable
        End Get
    End Property

    Public Sub New(ByVal mySerializable As MySerializableType, ByVal myNonSerializable As MyNonSerializableType)
        Me._mySerializable = mySerializable
        Me._myNonSerializable = myNonSerializable
    End Sub

    ' Special serialization constructor
    <SPAN class=code-changed>Protected Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)
        _mySerializable = CType(info.GetValue("mySerializable", GetType(MySerializableType)), MySerializableType)
    End Sub

    Public Overridable Sub GetObjectData(ByVal info As SerializationInfo, ByVal context As StreamingContext) _
        Implements ISerializable.GetObjectData

        info.AddValue("mySerializable", _mySerializable)

    End Sub</SPAN>

End Class


</pre>
	<p>[C#]</p>
	<pre class="code">

// Sample serializable type	
[Serializable()]
public class MySerializableType: ISerializable
{
  
  private int _serializableField;
  
  public int SerializableField
  {
    get
    {
      return _serializableField;
    }
  }


  public MySerializableType(int serializableField)
  {
    _serializableField = serializableField;
  }

  protected MySerializableType(SerializationInfo info, StreamingContext context) 
  {
    _serializableField = info.GetInt32("serializableField");
  }
  
  public virtual void GetObjectData(SerializationInfo info, StreamingContext context) 
  {
    info.AddValue("serializableField", _serializableField)
  }
  
}

// Sample non-serializable type	
public class MyNonSerializableType
{
  
  private int _nonSerializableField;
  
  public int NonSerializableField
  {
    get
    {
      return _nonSerializableField;
    }
  }


  public MyNonSerializableType(int nonSerializableField)
  {
    _nonSerializableField = nonSerializableField;
  }

}

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
	
[Serializable()]
public class MyType
{

    private MySerializableType _mySerializable;
    private MyNonSerializableType _myNonSerializable;

    public MySerializableType MySerializable
    {
        get
        {
            return _mySerializable;
        }
    }

    public MyNonSerializableType MyNonSerializable
    {
        get
        {
            return _myNonSerializable;
        }
    }

    public MyType(MySerializableType mySerializable, MyNonSerializableType myNonSerializable)
    {
        this._mySerializable = mySerializable;
        this._myNonSerializable = myNonSerializable;
    }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

[Serializable()]
public class MyType: <SPAN class=code-changed>ISerializable</SPAN>
{

    private MySerializableType _mySerializable;
    
    <SPAN class=code-changed>[NonSerialized()]</SPAN>
    private MyNonSerializableType _myNonSerializable;

    public MySerializableType MySerializable
    {
        get
        {
            return _mySerializable;
        }
    }

    public MyNonSerializableType MyNonSerializable
    {
        get
        {
            return _myNonSerializable;
        }
    }

    public MyType(MySerializableType mySerializable, MyNonSerializableType myNonSerializable)
    {
        this._mySerializable = mySerializable;
        this._myNonSerializable = myNonSerializable;
    }

    // Special serialization constructor
    <SPAN class=code-changed>protected MyType(SerializationInfo info, StreamingContext context)
    {
        _mySerializable = (MySerializableType)info.GetValue("mySerializable", MySerializableType.GetType())
    }

    public virtual void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
    {

        info.AddValue("mySerializable", _mySerializable);

    }</SPAN>

}


</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00012">
      <Name>Serialization -&gt; Field -&gt; Mark Non-Serializable With NonSerialized Attribute</Name>
      <Title>Mark all non-serializable fields with "NonSerialized" attribute</Title>
      <ClassName>MarkAllNonSerializableFields</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Error</Severity>
      <Targets>Field</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>5/10/2007</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2235:MarkAllNonSerializableFields</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00012</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/MarkAllNonSerializableFields.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[The type marked with <b>System.SerializableAttribute</b> attribute 
	and has an instance field of a type that is not serializable.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[When the type is serialized, a <b>System.Runtime.Serialization.SerializationException</b> 
	exception is thrown if a type contains an instance field of a type that is not serializable.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Mark all non-serializable fields', CheckId <b>CA2235</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Find field and mark it with <b>System.NonSerializedAttribute</b> attribute.</li>
    <LI>Find type and mark it with <b>System.SerializableAttribute</b> attribute.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Mark all non-serializable fields with "NonSerialized" attribute.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p> 
	<pre class="code">

Public Class ContactInformation

    Private _address As String
    Private _phone As String

    Public ReadOnly Property Address() As String
        Get
            Return _address
        End Get
    End Property

    Public ReadOnly Property Phone() As String
        Get
            Return _phone
        End Get
    End Property

    Public Sub New(ByVal address As String, ByVal phone As String)

        Me._address = address
        Me._phone = phone

    End Sub

End Class

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

&lt;Serializable&gt; _
Public Class Person

    Private _firstName As String
    Private _lastName As String

    ' Violation: _contactInformation field should be marked with NonSerialized attribute
    ' or ContactInformation type should be marked with Serializable attribute
    Private _contactInformation As ContactInformation

    Public ReadOnly Property FirstName() As String
        Get
            Return _firstName
        End Get
    End Property

    Public ReadOnly Property LastName() As String
        Get
            Return _lastName
        End Get
    End Property

    Public ReadOnly Property ContactInfo() As ContactInformation
        Get
            Return _contactInformation
        End Get
    End Property

    Public Sub New(ByVal firstName As String, ByVal lastName As String, _
        ByVal contactInfo As ContactInformation)

        Me._firstName = firstName
        Me._lastName = lastName
        Me._contactInformation = contactInfo

    End Sub

End Class


<SPAN class=code-selected>' This is the correct implementation</SPAN>

'Mark <b>_contactInformation</b> field with NonSerialized attribute
&lt;Serializable&gt; _
Public Class Person

    Private _firstName As String
    Private _lastName As String
    
    <SPAN class=code-changed>&lt;NonSerialized()&gt; _</SPAN>
    Private _contactInformation As ContactInformation

    Public ReadOnly Property FirstName() As String
        Get
            Return _firstName
        End Get
    End Property

    Public ReadOnly Property LastName() As String
        Get
            Return _lastName
        End Get
    End Property

    Public ReadOnly Property ContactInfo() As ContactInformation
        Get
            Return _contactInformation
        End Get
     End Property

    Public Sub New(ByVal firstName As String, ByVal middleName As String, _
        ByVal lastName As String, ByVal email As String, _
        ByVal contactInfo As ContactInformation)

        Me._firstName = firstName
        Me._lastName = lastName
        Me._contactInformation = contactInfo

    End Sub
    
End Class


- OR -


' Mark <b>ContactInformation</b> type with Serializable attribute
<SPAN class=code-changed>&lt;Serializable&gt; _	</SPAN>
Public Class ContactInformation

    Private _address As String
    Private _phone As String

    Public ReadOnly Property Address() As String
        Get
            Return _address
        End Get
    End Property

    Public ReadOnly Property Phone() As String
        Get
            Return _phone
        End Get
    End Property

    Public Sub New(ByVal address As String, ByVal phone As String)

        Me._address = address
        Me._phone = phone

    End Sub

End Class


	</pre>
	<p>[C#]</p> 
	<pre class="code">

public class ContactInformation
{

    private string _address;
    private string _phone;

    public string Address
    {
        get
        {
            return _address;
        }
    }

    public string Phone
    {
        get
        {
            return _phone;
        }
    }

    public ContactInformation(string address, string phone)
    {

        this._address = address;
        this._phone = phone;

    }

}

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

[Serializable()]
public class Person
{

    private string _firstName;
    private string _lastName;

    // Violation: _contactInformation field should be marked with NonSerialized attribute
    // or ContactInformation type should be marked with Serializable attribute
    private ContactInformation _contactInformation;

    public string FirstName
    {
        get
        {
            return _firstName;
        }
    }

    public string LastName
    {
        get
        {
            return _lastName;
        }
    }

    public ContactInformation ContactInfo
    {
        get
        {
            return _contactInformation;
        }
    }

    public Person(string firstName, string lastName, ContactInformation contactInfo)
    {

        this._firstName = firstName;
        this._lastName = lastName;
        this._contactInformation = contactInfo;

    }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

//Mark <b>_contactInformation</b> field with NonSerialized attribute
[Serializable()]
public class Person
{

    private string _firstName;
    private string _lastName;

    <SPAN class=code-changed>[NonSerialized()]</SPAN>
    private ContactInformation _contactInformation;

    public string FirstName
    {
        get
        {
            return _firstName;
        }
    }

    public string LastName
    {
        get
        {
            return _lastName;
        }
    }

    public ContactInformation ContactInfo
    {
        get
        {
            return _contactInformation;
        }
    }

    public Person(string firstName, string lastName, ContactInformation contactInfo)
    {

        this._firstName = firstName;
        this._lastName = lastName;
        this._contactInformation = contactInfo;

    }

}


- OR -


// Mark <b>ContactInformation</b> type with Serializable attribute
<SPAN class=code-changed>[Serializable()]</SPAN>
public class ContactInformation
{

    private string _address;
    private string _phone;

    public string Address
    {
        get
        {
            return _address;
        }
    }

    public string Phone
    {
        get
        {
            return _phone;
        }
    }

    public ContactInformation(string address, string phone)
    {

        this._address = address;
        this._phone = phone;

    }

}


	</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00013">
      <Name>Custom Serialization -&gt; Type -&gt; Mark ISerializable Types With Serializable Attribute</Name>
      <Title>Mark ISerializable types with "Serializable" attribute</Title>
      <ClassName>MarkDerivedTypesWithSpecifiedAttribute</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Error</Severity>
      <Targets>Class, Struct</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>5/10/2007</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2237:MarkISerializableTypesWithSerializable</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00013</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/MarkDerivedTypesWithSpecifiedAttribute.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>AttributeToCheck</Name>
          <Value>System.SerializableAttribute</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>MustImplement</Name>
          <Value>System.Runtime.Serialization.ISerializable</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[The type implements certain interface, but is not marked with specific attribute.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[If the type implements some certain interface, then it should be marked with specific attribute.<br />
	<br />
	Types implementing <b>System.Runtime.Serialization.ISerializable</b> interface must be marked
	with <b>SerializedAttribute</b> attribute. A type that implements 
	<b>System.Runtime.Serialization.ISerializable</b> interface but isn't marked with the 
	<b>SerializableAttribute</b> attributemight not be serialized under all circumstances and might not be
	recognized as serializable by reflection code that only checks for the presence of the attribute.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Mark ISerializable types with serializable', CheckId <b>CA2237</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Mark the type with specific attribute.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleConfigurableProperties><![CDATA[<ul>
		<li><i>AttributeToCheck</i> - Certain Attribute to be checked;</li>
		<li><i>MustImplement</i> - Type should implement the specified type or interface.</li>
	</ul>]]></HelpRuleConfigurableProperties>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Mark ISerializable types with "Serializable" attribute.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
	<p>[Visual Basic]</p>
	<pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

' Violation: type is not marked with <b>Serializable</b> attribute
Public Class MySerializableType
  Implements ISerializable
  
  Private _serializableField As Integer
  
  Public ReadOnly Property SerializableField() As Integer
    Get
      Return _serializableField
    End Get
  End Property


  Public Sub New(ByVal serializableField As Integer)
    _serializableField = serializableField
  End Sub 

  Protected Sub New(ByVal info As SerializationInfo, _
  ByVal context As StreamingContext) 
      _serializableField = info.GetInt32("serializableField")
  End Sub 'New
  
  Public Overridable Sub GetObjectData(ByVal info As _
    SerializationInfo, ByVal context As StreamingContext) 
    info.AddValue("serializableField", _serializableField)
  End Sub 
End Class	

<SPAN class=code-selected>' This is the correct implementation</SPAN>

<SPAN class=code-changed>&lt;Serializable()&gt;  _</SPAN>
Public Class MySerializableType
  Implements ISerializable
  
  Private _serializableField As Integer
  
  Public ReadOnly Property SerializableField() As Integer
    Get
      Return _serializableField
    End Get
  End Property


  Public Sub New(ByVal serializableField As Integer)
    _serializableField = serializableField
  End Sub 

  Protected Sub New(ByVal info As SerializationInfo, _
  ByVal context As StreamingContext) 
      _serializableField = info.GetInt32("serializableField")
  End Sub 'New
  
  Public Overridable Sub GetObjectData(ByVal info As _
    SerializationInfo, ByVal context As StreamingContext) 
    info.AddValue("serializableField", _serializableField)
  End Sub 
End Class	


</pre>
	<p>[C#]</p>
	<pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

// Violation: type is not marked with <b>Serializable</b> attribute
public class MySerializableType: ISerializable
{
  
  private int _serializableField;
  
  public int SerializableField
  {
    get
    {
      return _serializableField;
    }
  }

  public MySerializableType(int serializableField)
  {
    _serializableField = serializableField;
  }

  protected MySerializableType(SerializationInfo info, StreamingContext context)
  {
    _serializableField = info.GetInt32("serializableField");
  }
  
  public virtual void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
  {
    info.AddValue("serializableField", _serializableField);
  }
}

<SPAN class=code-selected>' This is the correct implementation</SPAN>

<SPAN class=code-changed>[Serializable()]</SPAN>
public class MySerializableType: ISerializable
{
  
  private int _serializableField;
  
  public int SerializableField
  {
    get
    {
      return _serializableField;
    }
  }

  public MySerializableType(int serializableField)
  {
    _serializableField = serializableField;
  }

  protected MySerializableType(SerializationInfo info, StreamingContext context)
  {
    _serializableField = info.GetInt32("serializableField");
  }
  
  public virtual void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
  {
    info.AddValue("serializableField", _serializableField);
  }
}


</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00026">
      <Name>Method -&gt; Provide 'default:' for each 'switch' statement</Name>
      <Title>Provide 'default:' for each 'switch' statement</Title>
      <ClassName>ProvideDefaultForEachSwitchStatement</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>3/25/2013</RuleModificationDate>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00026</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ProvideDefaultForEachSwitchStatement.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[<b>Switch</b> statement does not have a <b>default</b> statement.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Often, the <b>case</b> statements in a switch are the only logical options, so a
  <b>default</b> statement should be added to catch any options that are outside the
  accepted range of inputs.
  <br/><br/>- OR - <br/></br>
  Handle gracefully situations where some additional values are defined in an 
  enum and the switch has case statements for only
  the earlier values of the enum.]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <ul>
    <li>Add <b>default</b> statement.</li>
  </ul>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Provide 'default:' for each 'switch' statement.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br />
  <p>[C#]</p>
    <pre class="code">
<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>
      public class SomeClass
      {
        void method (int i)
        {
          switch (i) <SPAN class=code-selected>// Violates the rule</SPAN>
          {
            case 0:
              System.Console.WriteLine ("Zero");
              break;
          }
        }
      }

<SPAN class=code-selected>// This is the correct implementation</SPAN>
    public class SomeClass
    {
      void method (int i)
      {
        switch (i)
        {
          case 0:
            System.Console.WriteLine ("Zero");
            break;
          default: <SPAN class=code-selected>// Fixed </SPAN>
            break;
        }
      }
    }

  </pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00014">
      <Name>Serialization -&gt; Field -&gt; Provide deserialization methods for optional fields</Name>
      <Title>Provide deserialization methods for optional fields</Title>
      <ClassName>ProvideDeserializationMethodsForOptionalFields</ClassName>
      <Scope>Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Unsafe, SpecialName, Literal, Const, Volatile, WriteOnly, WithEvents, Default</Scope>
      <Severity>Warning</Severity>
      <Targets>Field</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>8/5/2009</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA2239:ProvideDeserializationMethodsForOptionalFields</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00014</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/ProvideDeserializationMethodsForOptionalFields.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Type marked with <b>System.SerializableAttribute</b> attribute, and has a field 
  with <b>System.Runtime.Serialization.OptionalFieldAttribute</b> attribute but 
  does not provide de-serialization event handling methods (with <b>OnDeserializingAttribute</b>
  and <b>OnDeserializedAttribute</b> attributes).<br>
  <br>]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[<b>System.Runtime.Serialization.OptionalFieldAttribute</b> specifies that a field
  can be missing from a serialization stream. This attribute allows to specify that
  new fields in a serializable type are ignored by the 
  <b>System.Runtime.Serialization.Formatters.Binary.BinaryFormatter</b> or the 
  <B>System.Runtime.Serialization.Formatters.Soap.SoapFormatter</B>. Field marked with 
  <b>System.Runtime.Serialization.OptionalFieldAttribute</b> attribute is serialized, but 
  it is ignored on de-serialization and retains the default value. De-serialization event 
  handlers should be created to initialize the field with the value, which depends from
  other deserialized values.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Provide deserialization methods for optional fields', CheckId <b>CA2239</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options depending from detected 
  violation:
  <UL>
    <LI>
      Add two deserialization event handling methods by applying <b>System.Runtime.Serialization.OnDeserializedAttribute</b>
      and <b>System.Runtime.Serialization.OnDeserializingAttribute</b>
    attributes.
    <LI>
      Add deserialization event handling method by applying <b>System.Runtime.Serialization.OnDeserializedAttribute</b>
    attribute.
    <LI>
      Add deserialization event handling method by applying <b>System.Runtime.Serialization.OnDeserializingAttribute</b>
    attribute.
    <LI>
      Initialize field in the deserialization event handling method marked with <b>System.Runtime.Serialization.OnDeserializedAttribute</b>
      attribute.
    </LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>
      Provide deserialization methods for optional fields.
    </li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following examples show code that triggers the rule violation as well as 
  the correct implementation.
  <br>
  <p>[Visual Basic]</p>
  <pre class="code">

<SPAN class=code-selected>' This code will trigger the rule violation</SPAN>

Imports System
Imports System.Reflection
Imports System.Runtime.Serialization

&lt;Assembly: AssemblyVersionAttribute("2.0.0.0")&gt;
Namespace SampleLibrary

  ' Violation: Type SerializationEventsSample does not provide
  ' de-serialization event handling methods
  &lt;SerializableAttribute&gt; _ 
  Public Class SerializationEventsSample

    &lt;OptionalFieldAttribute(VersionAdded := 2)&gt; _
    Private _optionalField As String = "Default Value"
    
    Public ReadOnly Property OptionalField() As String
      Get
        Return _optionalField
      End Get
    End Property

  End Class

End Namespace


<SPAN class=code-selected>' This is the correct implementation</SPAN>

Imports System
Imports System.Reflection
Imports System.Runtime.Serialization

&lt;Assembly: AssemblyVersionAttribute("2.0.0.0")&gt;
Namespace SampleLibrary

  &lt;SerializableAttribute&gt; _ 
  Public Class SerializationEventsSample

    &lt;OptionalFieldAttribute(VersionAdded := 2)&gt; _
    Private _optionalField As String = "Default Value"
    
    Public ReadOnly Property OptionalField() As String
      Get
        Return _optionalField
      End Get
    End Property

    <SPAN class=code-changed>&lt;OnDeserializingAttribute&gt; _ 
    Private Sub OnDeserializing(context As StreamingContext)
      _optionalField = "Default Value"
    End Sub

    &lt;OnDeserializedAttribute&gt; _ 
    Private Sub OnDeserialized(context As StreamingContext)
      ' Initialize _optionalField with the value, which depends from
      ' other deserialized values.
      
      ...
      
    End Sub</SPAN>

  End Class

End Namespace

</pre>
  <p>[C#]</p>
  <pre class="code">

<SPAN class=code-selected>// This code will trigger the rule violation</SPAN>

using System;
using System.Reflection;
using System.Runtime.Serialization;

[assembly:AssemblyVersionAttribute("2.0.0.0")]
namespace SampleLibrary
{

  // Violation: Type SerializationEventsSample does not provide
  // de-serialization event handling methods
  [SerializableAttribute()] 
  public class SerializationEventsSample
  {

    [OptionalFieldAttribute(VersionAdded = 2)]
    private string _optionalField = "Default Value";
    
    public string OptionalField
    {
      get
      {
        return _optionalField;
      }
    }

  }

}


<SPAN class=code-selected>// This is the correct implementation</SPAN>

using System;
using System.Reflection;
using System.Runtime.Serialization;

[assembly:AssemblyVersionAttribute("2.0.0.0")]
namespace SampleLibrary
{

  [SerializableAttribute()] 
  public class SerializationEventsSample
  {

    [OptionalFieldAttribute(VersionAdded = 2)]
    private string _optionalField = "Default Value";
    
    public string OptionalField
    {
      get
      {
        return _optionalField;
      }
    }

    <SPAN class=code-changed>[OnDeserializingAttribute()] 
    private void OnDeserializing(StreamingContext context)
    {
      _optionalField = "Default Value";
    }

    [OnDeserializedAttribute]
    private void OnDeserialized(StreamingContext context)
    {
      // Initialize _optionalField with the value, which depends from
      // other deserialized values.
      
      ...
      
    }</SPAN>

  }

}

</pre>]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="US00019">
      <Name>Method -&gt; Remove unused parameters</Name>
      <Title>Remove unused parameters</Title>
      <ClassName>RemoveUnusedParameters</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Warning</Severity>
      <Targets>Method</Targets>
      <CanCorrect>true</CanCorrect>
      <RuleCategory>Usage</RuleCategory>
      <RuleModificationDate>12/30/2010</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Usage, CA1801:ReviewUnusedParameters</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=US00019</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/RemoveUnusedParameters.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[A method includes parameter, which is not used in the body of the method.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Don't reserve one or more parameters for future use. Define only the parameters that are actually 
  currently used by the method. If additional parameters are required in future versions of the class,
  you can later define an overloaded method. Unused parameters may degrade performance.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Review unused parameters', CheckId <b>CA1801</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <li>Comment out unused parameter.</li>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Remove unused parameters.</li>
  </ul>
	<p>&nbsp;]]></HelpRuleInstances>
    </RuleInstance>
    <RuleInstance ruleID="XA00005">
      <Name>Xaml Property -&gt; Should be set once</Name>
      <Title>Property should be set once</Title>
      <ClassName>PropertyShouldBeSetOnce</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalError</Severity>
      <Targets>File</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Xaml</RuleCategory>
      <RuleModificationDate>10/16/2012</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Xaml, MSX1000:PropertiesCanOnlyBeSetOnce</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=XA00005</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/PropertyShouldBeSetOnce.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Xaml file contains property which is set more than once.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Properties can only be set once in XAML. There are three different ways to set a property in XAML: setting it as an XML attribute, as a property element, or as content.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rule 'Properties can only be set once', CheckId <b>MSX1000</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Set the property only once.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Property should be set once.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;Button Width="50"&gt;
    &lt;Button.Width&gt;50&lt;/Button.Width&gt;
    Click
&lt;/Button&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;Button&gt;
    &lt;Button.Width&gt;50&lt;/Button.Width&gt;
    Click
&lt;/Button&gt;

- OR -

&lt;Button Width="50"&gt;
    Click
&lt;/Button&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="XA00003">
      <Name>Xaml File -&gt; Should be well-formed</Name>
      <Title>Xaml file should be well-formed</Title>
      <ClassName>XamlShouldBeWellFormed</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>CriticalError</Severity>
      <Targets>File</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Xaml</RuleCategory>
      <RuleModificationDate>11/10/2011</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Xaml, MSX1001:XamlValidation</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=XA00003</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/XamlShouldBeWellFormed.htm</RuleHelpUrl>
      <RuleInstanceProperties />
      <HelpRuleProblem><![CDATA[Xaml file is not well-formed.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[All XAML documents must well-formed XML documents that use a defined set of element names.
  I.e. each property of a Document Information Item must be of correct type, and XAML must have tree structure.<br />
  <br />
	<i>This rule is similar to <b>FxCop</b> rules 'XAML validation problem', CheckId <b>MSX1001</b></i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Please check the resolution for the exact issue manually.</LI>
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Xaml should be well-formed.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;MyObject&gt;
    &lt;MyObject.FirstProperty&gt;First Value
    &lt;MyObject.SecondProperty&gt;Second Value
    &lt;MyObject.ThirdProperty&gt;Third Value
&lt;/MyObject&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;MyObject&gt;
    &lt;MyObject.FirstProperty&gt;First Value&lt;/MyObject.FirstProperty&gt;
    &lt;MyObject.SecondProperty&gt;Second Value&lt;/MyObject.SecondProperty&gt;
    &lt;MyObject.ThirdProperty&gt;Third Value&lt;/MyObject.ThirdProperty&gt;
&lt;/MyObject&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="XA00002">
      <Name>Xaml File -&gt; 'ControlTemplate' object should define 'TargetType' member</Name>
      <Title>ControlTemplate object should define TargetType member</Title>
      <ClassName>XamlMemberShouldNotBeEmpty</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>File</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Xaml</RuleCategory>
      <RuleModificationDate>11/10/2011</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Xaml.Workflow, XWF1000:SequenceActivityShouldHaveChildren;XWF1003:DelayDuration;XWF1004:ParallelShouldHaveBranches</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=XA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/XamlMemberShouldNotBeEmpty.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>XamlObjectNamespaces</Name>
          <Value>http://schemas.microsoft.com/winfx/2006/xaml/presentation,http://schemas.microsoft.com/netfx/2007/xaml/presentation,clr-namespace:System.Windows.Controls;assembly=PresentationFramework</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>XamlObjectName</Name>
          <Value>ControlTemplate</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>XamlMemberName</Name>
          <Value>TargetType</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Xaml file contains object and its member is empty.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Xaml object should always define specified member.<br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Sequence activity should have child activities', CheckId <b>XWF1000</b></li>
		<li>'Delay duration has not been set', CheckId <b>XWF1003</b></li>
		<li>'Parallel activity should have atleast one branch', CheckId <b>XWF1004</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Specifiy value for member manually.
    <LI>Remove empty member from object manually.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>ControlTemplate object should define TargetType member.</li>    
    <li>Delay object should define Duration member.</li>        
    <li>Parallel object should define Branches member.</li>    
    <li>Sequence object should define Activities member.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;Activity x:Class="Workflow1"
  xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
  &lt;Sequence&gt;
    &lt;WriteLine Text="Start Delay" /&gt;
    &lt;Delay /&gt;
    &lt;WriteLine Text="[&quot;Delay has completed at &quot; + DateTime.Now.ToString()]" /&gt;
  &lt;/Sequence&gt;
&lt;/Activity&gt; 
      
<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;Activity x:Class="Workflow1"
  xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
  &lt;Sequence&gt;
    &lt;WriteLine Text="Start Delay" /&gt;
    &lt;Delay Duration="[new TimeSpan(0, 0, 5)]" /&gt;
    &lt;WriteLine Text="[&quot;Delay has completed at &quot; + DateTime.Now.ToString()]" /&gt;
  &lt;/Sequence&gt;
&lt;/Activity&gt; 

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="XA00002">
      <Name>Xaml File -&gt; 'Delay' object should define 'Duration' member</Name>
      <Title>Delay object should define Duration member</Title>
      <ClassName>XamlMemberShouldNotBeEmpty</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>File</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Xaml</RuleCategory>
      <RuleModificationDate>11/10/2011</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Xaml.Workflow, XWF1000:SequenceActivityShouldHaveChildren;XWF1003:DelayDuration;XWF1004:ParallelShouldHaveBranches</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=XA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/XamlMemberShouldNotBeEmpty.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>XamlObjectNamespaces</Name>
          <Value>clr-namespace:System.Activities.Statements;assembly=System.Activities,http://schemas.microsoft.com/netfx/2009/xaml/activities</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>XamlObjectName</Name>
          <Value>Delay</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>XamlMemberName</Name>
          <Value>Duration</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Xaml file contains object and its member is empty.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Xaml object should always define specified member.<br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Sequence activity should have child activities', CheckId <b>XWF1000</b></li>
		<li>'Delay duration has not been set', CheckId <b>XWF1003</b></li>
		<li>'Parallel activity should have atleast one branch', CheckId <b>XWF1004</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Specifiy value for member manually.
    <LI>Remove empty member from object manually.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>ControlTemplate object should define TargetType member.</li>    
    <li>Delay object should define Duration member.</li>        
    <li>Parallel object should define Branches member.</li>    
    <li>Sequence object should define Activities member.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;Activity x:Class="Workflow1"
  xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
  &lt;Sequence&gt;
    &lt;WriteLine Text="Start Delay" /&gt;
    &lt;Delay /&gt;
    &lt;WriteLine Text="[&quot;Delay has completed at &quot; + DateTime.Now.ToString()]" /&gt;
  &lt;/Sequence&gt;
&lt;/Activity&gt; 
      
<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;Activity x:Class="Workflow1"
  xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
  &lt;Sequence&gt;
    &lt;WriteLine Text="Start Delay" /&gt;
    &lt;Delay Duration="[new TimeSpan(0, 0, 5)]" /&gt;
    &lt;WriteLine Text="[&quot;Delay has completed at &quot; + DateTime.Now.ToString()]" /&gt;
  &lt;/Sequence&gt;
&lt;/Activity&gt; 

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="XA00002">
      <Name>Xaml File -&gt; 'Parallel' object should define 'Branches' member</Name>
      <Title>Parallel object should define Branches member</Title>
      <ClassName>XamlMemberShouldNotBeEmpty</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>File</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Xaml</RuleCategory>
      <RuleModificationDate>11/10/2011</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Xaml.Workflow, XWF1000:SequenceActivityShouldHaveChildren;XWF1003:DelayDuration;XWF1004:ParallelShouldHaveBranches</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=XA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/XamlMemberShouldNotBeEmpty.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>XamlObjectNamespaces</Name>
          <Value>clr-namespace:System.Activities.Statements;assembly=System.Activities,http://schemas.microsoft.com/netfx/2009/xaml/activities</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>XamlObjectName</Name>
          <Value>Parallel</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>XamlMemberName</Name>
          <Value>Branches</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Xaml file contains object and its member is empty.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Xaml object should always define specified member.<br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Sequence activity should have child activities', CheckId <b>XWF1000</b></li>
		<li>'Delay duration has not been set', CheckId <b>XWF1003</b></li>
		<li>'Parallel activity should have atleast one branch', CheckId <b>XWF1004</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Specifiy value for member manually.
    <LI>Remove empty member from object manually.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>ControlTemplate object should define TargetType member.</li>    
    <li>Delay object should define Duration member.</li>        
    <li>Parallel object should define Branches member.</li>    
    <li>Sequence object should define Activities member.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;Activity x:Class="Workflow1"
  xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
  &lt;Sequence&gt;
    &lt;WriteLine Text="Start Delay" /&gt;
    &lt;Delay /&gt;
    &lt;WriteLine Text="[&quot;Delay has completed at &quot; + DateTime.Now.ToString()]" /&gt;
  &lt;/Sequence&gt;
&lt;/Activity&gt; 
      
<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;Activity x:Class="Workflow1"
  xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
  &lt;Sequence&gt;
    &lt;WriteLine Text="Start Delay" /&gt;
    &lt;Delay Duration="[new TimeSpan(0, 0, 5)]" /&gt;
    &lt;WriteLine Text="[&quot;Delay has completed at &quot; + DateTime.Now.ToString()]" /&gt;
  &lt;/Sequence&gt;
&lt;/Activity&gt; 

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="XA00002">
      <Name>Xaml File -&gt; 'Sequence' object should define 'Activities' member</Name>
      <Title>Sequence object should define Activities member</Title>
      <ClassName>XamlMemberShouldNotBeEmpty</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>File</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Xaml</RuleCategory>
      <RuleModificationDate>11/10/2011</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Xaml.Workflow, XWF1000:SequenceActivityShouldHaveChildren;XWF1003:DelayDuration;XWF1004:ParallelShouldHaveBranches</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=XA00002</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/XamlMemberShouldNotBeEmpty.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>XamlObjectNamespaces</Name>
          <Value>clr-namespace:System.Activities.Statements;assembly=System.Activities,http://schemas.microsoft.com/netfx/2009/xaml/activities</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>XamlObjectName</Name>
          <Value>Sequence</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>XamlMemberName</Name>
          <Value>Activities</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Xaml file contains object and its member is empty.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[Xaml object should always define specified member.<br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Sequence activity should have child activities', CheckId <b>XWF1000</b></li>
		<li>'Delay duration has not been set', CheckId <b>XWF1003</b></li>
		<li>'Parallel activity should have atleast one branch', CheckId <b>XWF1004</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Specifiy value for member manually.
    <LI>Remove empty member from object manually.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>ControlTemplate object should define TargetType member.</li>    
    <li>Delay object should define Duration member.</li>        
    <li>Parallel object should define Branches member.</li>    
    <li>Sequence object should define Activities member.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;Activity x:Class="Workflow1"
  xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
  &lt;Sequence&gt;
    &lt;WriteLine Text="Start Delay" /&gt;
    &lt;Delay /&gt;
    &lt;WriteLine Text="[&quot;Delay has completed at &quot; + DateTime.Now.ToString()]" /&gt;
  &lt;/Sequence&gt;
&lt;/Activity&gt; 
      
<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;Activity x:Class="Workflow1"
  xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
  &lt;Sequence&gt;
    &lt;WriteLine Text="Start Delay" /&gt;
    &lt;Delay Duration="[new TimeSpan(0, 0, 5)]" /&gt;
    &lt;WriteLine Text="[&quot;Delay has completed at &quot; + DateTime.Now.ToString()]" /&gt;
  &lt;/Sequence&gt;
&lt;/Activity&gt; 

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="XA00001">
      <Name>Xaml File -&gt; 'Assign' object should define 'To' member</Name>
      <Title>Assign object should define To member</Title>
      <ClassName>XamlObjectShouldContainSpecifiedMember</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>File</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Xaml</RuleCategory>
      <RuleModificationDate>11/10/2011</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Xaml.Workflow, XWF1001:AssignActivityTo;XWF1002:AssignActivityValue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=XA00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/XamlObjectShouldContainSpecifiedMember.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>XamlObjectNamespaces</Name>
          <Value>clr-namespace:System.Activities.Statements;assembly=System.Activities,http://schemas.microsoft.com/netfx/2009/xaml/activities</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>XamlObjectName</Name>
          <Value>Assign</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>XamlMemberName</Name>
          <Value>To</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Xaml file contains object without member specified.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This rule can be used to check if Xaml object has all required members specified.<br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Assign activity does not have a To specified', CheckId <b>XWF1001</b></li>
		<li>'Assign activity does not have a Value specified', CheckId <b>XWF1002</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Specifiy member for object manually.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Assign object should define To member.</li>
    <li>Assign object should define Value member.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;Activity 
  x:TypeArguments="x:Int32" 
  x:Class="Add" 
  xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
  &lt;x:Members&gt;
    &lt;x:Property Name="Operand1" Type="InArgument(x:Int32)" /&gt;
    &lt;x:Property Name="Operand2" Type="InArgument(x:Int32)" /&gt;
  &lt;/x:Members&gt;
  &lt;Sequence&gt;
    &lt;WriteLine Text="[Operand1.ToString() + &quot; + &quot; + Operand2.ToString()]" /&gt;
    &lt;Assign x:TypeArguments="x:Int32" Value="[Operand1 + Operand2]"&gt;
      &lt;Assign.To&gt;&lt;/Assign.To&gt;
    &lt;/Assign&gt;
  &lt;/Sequence&gt;
&lt;/Activity&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;Activity 
  x:TypeArguments="x:Int32" 
  x:Class="Add" 
  xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
  &lt;x:Members&gt;
    &lt;x:Property Name="Operand1" Type="InArgument(x:Int32)" /&gt;
    &lt;x:Property Name="Operand2" Type="InArgument(x:Int32)" /&gt;
  &lt;/x:Members&gt;
  &lt;Sequence&gt;
    &lt;WriteLine Text="[Operand1.ToString() + &quot; + &quot; + Operand2.ToString()]" /&gt;
    &lt;Assign x:TypeArguments="x:Int32" Value="[Operand1 + Operand2]"&gt;
      &lt;Assign.To&gt;
        &lt;OutArgument x:TypeArguments="x:Int32"&gt;
          &lt;ArgumentReference x:TypeArguments="x:Int32" ArgumentName="Result" /&gt;
        &lt;/OutArgument&gt;
      &lt;/Assign.To&gt;
    &lt;/Assign&gt;
  &lt;/Sequence&gt;
&lt;/Activity&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
    <RuleInstance ruleID="XA00001">
      <Name>Xaml File -&gt; 'Assign' object should define 'Value' member</Name>
      <Title>Assign object should define Value member</Title>
      <ClassName>XamlObjectShouldContainSpecifiedMember</ClassName>
      <Scope>New, Public, Protected, Internal, ProtectedInternal, Private, Abstract, Sealed, Static, Readonly, Virtual, Override, Extern, Unsafe, Literal, Const, Volatile, WriteOnly, WithEvents, Any</Scope>
      <Severity>Error</Severity>
      <Targets>File</Targets>
      <CanCorrect>false</CanCorrect>
      <RuleCategory>Xaml</RuleCategory>
      <RuleModificationDate>11/10/2011</RuleModificationDate>
      <RuleFxCopMapping>Microsoft.Xaml.Workflow, XWF1001:AssignActivityTo;XWF1002:AssignActivityValue</RuleFxCopMapping>
      <RuleAuthor>SubMain Team</RuleAuthor>
      <RuleEmail>support@submain.com</RuleEmail>
      <RuleSupportUrl>http://submain.com/support/codeit.right/rules/?ruleid=XA00001</RuleSupportUrl>
      <RuleHelpUrl>mk:@MSITStore:C:\Program Files (x86)\SubMain\CodeIt.Right Standard\Help\CodeIt.Right.chm::/Html/XamlObjectShouldContainSpecifiedMember.htm</RuleHelpUrl>
      <RuleInstanceProperties>
        <RuleInstanceProperty>
          <Name>XamlObjectNamespaces</Name>
          <Value>clr-namespace:System.Activities.Statements;assembly=System.Activities,http://schemas.microsoft.com/netfx/2009/xaml/activities</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>XamlObjectName</Name>
          <Value>Assign</Value>
        </RuleInstanceProperty>
        <RuleInstanceProperty>
          <Name>XamlMemberName</Name>
          <Value>Value</Value>
        </RuleInstanceProperty>
      </RuleInstanceProperties>
      <HelpRuleProblem><![CDATA[Xaml file contains object without member specified.]]></HelpRuleProblem>
      <HelpRuleDescription><![CDATA[This rule can be used to check if Xaml object has all required members specified.<br />
  <br />
	<i>This rule is similar to the following <b>FxCop</b> rules:
	<ul>
		<li>'Assign activity does not have a To specified', CheckId <b>XWF1001</b></li>
		<li>'Assign activity does not have a Value specified', CheckId <b>XWF1002</b></li>
	</ul>
	 </i>]]></HelpRuleDescription>
      <HelpRuleCorrectingViolations><![CDATA[The rule provides the following auto-correct options:
  <UL>
    <LI>Specifiy member for object manually.
  </UL>]]></HelpRuleCorrectingViolations>
      <HelpRuleInstances><![CDATA[Instances of this rule in the built-in profile:
  <ul>
    <li>Assign object should define To member.</li>
    <li>Assign object should define Value member.</li>
  </ul>]]></HelpRuleInstances>
      <HelpRuleExample><![CDATA[The following example show code that triggers the rule violation.
  <br />
  <pre class="code">

<SPAN class="code-selected">&lt;!-- This code will trigger the rule violation --&gt;</SPAN>

&lt;Activity 
  x:TypeArguments="x:Int32" 
  x:Class="Add" 
  xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
  &lt;x:Members&gt;
    &lt;x:Property Name="Operand1" Type="InArgument(x:Int32)" /&gt;
    &lt;x:Property Name="Operand2" Type="InArgument(x:Int32)" /&gt;
  &lt;/x:Members&gt;
  &lt;Sequence&gt;
    &lt;WriteLine Text="[Operand1.ToString() + &quot; + &quot; + Operand2.ToString()]" /&gt;
    &lt;Assign x:TypeArguments="x:Int32" Value="[Operand1 + Operand2]"&gt;
      &lt;Assign.To&gt;&lt;/Assign.To&gt;
    &lt;/Assign&gt;
  &lt;/Sequence&gt;
&lt;/Activity&gt;

<SPAN class=code-selected>&lt;!-- This is the correct implementation --&gt;</SPAN>

&lt;Activity 
  x:TypeArguments="x:Int32" 
  x:Class="Add" 
  xmlns="http://schemas.microsoft.com/netfx/2009/xaml/activities" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
  &lt;x:Members&gt;
    &lt;x:Property Name="Operand1" Type="InArgument(x:Int32)" /&gt;
    &lt;x:Property Name="Operand2" Type="InArgument(x:Int32)" /&gt;
  &lt;/x:Members&gt;
  &lt;Sequence&gt;
    &lt;WriteLine Text="[Operand1.ToString() + &quot; + &quot; + Operand2.ToString()]" /&gt;
    &lt;Assign x:TypeArguments="x:Int32" Value="[Operand1 + Operand2]"&gt;
      &lt;Assign.To&gt;
        &lt;OutArgument x:TypeArguments="x:Int32"&gt;
          &lt;ArgumentReference x:TypeArguments="x:Int32" ArgumentName="Result" /&gt;
        &lt;/OutArgument&gt;
      &lt;/Assign.To&gt;
    &lt;/Assign&gt;
  &lt;/Sequence&gt;
&lt;/Activity&gt;

	</pre>
  <p>&nbsp;]]></HelpRuleExample>
    </RuleInstance>
  </Profile>
</CodeItRightProfile>